<!DOCTYPE html>
<html>

<head>
    <title>æ³¢åŠ¨æ¨¡æ‹Ÿç©å…·</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        #waveCanvas {
            cursor: crosshair;
            height: auto;
            width: 100vh;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            background: #1a1a1a;
            color: white;
            flex-wrap: wrap;
        }

        .main {
            display: flex;
            align-items: center;
        }

        .tools {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-left: 16px;
        }

        .controls {
            display: grid;
            gap: 10px;
            grid-template-columns: repeat(2, 1fr);
            align-items: center;
        }

        .parameters {
            display: flex;
            flex-direction: column;
        }

        .param-div {
            display: flex;
            flex-direction: column;
        }

        button {
            padding: 8px;
            cursor: pointer;
            background: #333;
            border: 1px solid #666;
            color: white;
        }

        button.active {
            background: #4CAF50;
            border-color: #45a049;
        }

        .canvas-container {
            position: relative;
            margin: 10px;
        }

        .transceiver-marker {
            position: absolute;
            pointer-events: none;
            font-size: 1rem;
            transform: translate(-50%, -50%);
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #deviceList {
            padding: 10px;
            border: 1px solid #444;
            display: flex;
            flex-wrap: wrap;
            max-height: 100vh;
            min-width: min-content;
            max-width: fit-content;
            overflow-y: auto;
        }

        .device-item {
            margin: 5px;
            padding: 8px;
            background: #222;
        }

        .transceivers {
            gap: 10px;
            display: flex;
            flex-direction: column;
            margin: 8px;
        }


        select {
            background-color: #333;
            /* Dark background color for select dropdown */
            color: #fff;
            /* Light text color for select options */
            padding: 8px;
            border: 1px solid #666;
            /* Dark border color */
            border-radius: 4px;
            appearance: none;
            /* Remove default appearance */
            transition: background-color 0.3s;
        }

        select:hover,
        select:focus {
            background-color: #444;
            /* Change background color on hover/focus */
        }

        input[type="number"] {
            background-color: #333;
            /* Dark background color for input */
            color: #fff;
            /* Light text color for input */
            padding: 8px;
            border: 1px solid #666;
            /* Dark border color */
            border-radius: 4px;
            appearance: none;
            /* Remove default appearance */
            transition: background-color 0.3s;
        }

        .selected {
            border: 3px solid #4CAF50;
        }

        @media (max-width: 1024px) {
            body {
                flex-direction: column;
            }
        }

        @media (max-width: 700px) {
            canvas {
                width: 100%;
            }

            body {
                max-width: 100%;
            }

            .main {
                flex-direction: column;
            }

            .controls {
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }

            .transceivers {
                flex-direction: row;
            }

            #waveCanvas {
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <div class="main">
        <div class="canvas-container">
            <canvas id="waveCanvas"></canvas>
        </div>


        <div class="tools">
            <div class="controls">
                <button id="btnWave" class="toggle active">ğŸŒŠ æ”¾æ³¢</button>
                <button id="btnObstacle" class="toggle">ğŸ§± ç»˜åˆ¶</button>
                <button id="btnErase" class="toggle">ğŸ§¹ æ“¦é™¤</button>

                <div>
                    <input type="file" id="importImage" accept="image/*" hidden>
                    <button onclick="document.getElementById('importImage').click()">ğŸ–¼ï¸ å¯¼å…¥</button>
                </div>

                <button id="btnStop">ğŸ›‘ åœæ³¢</button>
                <button id="btnClear">âŒ æ¸…ç©º</button>
                <button id="btnPacket" class="toggle">ğŸ“¦ æ³¢åŒ…</button>
            </div>

            <div class="parameters">
                é˜»å°¼ï¼š<input type="number" id="damping" min="0" max="0.1" step="0.001" value="0.005">
                æŒ¯å¹…ï¼š<input type="number" id="amplitude" min="0.01" max="100" step="0.1" value="10">
                é¢‘ç‡ï¼š<input type="number" id="frequency" min="0" max="15" step="0.1" value="5">
                ç¬”åˆ·å¤§å°ï¼š<input type="range" id="brushSize" min="1" max="20" value="3"> <span id="brushSizeValue">3</span>
                ç¬”åˆ·ææ–™ï¼š<div id="material">
                </div>
                æ³¢å½¢ï¼š<select id="waveType">
                    <option value="sine">æ­£å¼¦æ³¢</option>
                    <option value="square">æ–¹æ³¢</option>
                    <option value="sawtooth">é”¯é½¿æ³¢</option>
                    <option value="triangle">ä¸‰è§’æ³¢</option>
                    <option value="noise">å™ªå£°</option>
                </select>
                æ³¢åŒ…ï¼š<select id="wavePackets">
                <option value="gauss">é«˜æ–¯</option>
                <option value="rect">çŸ©å½¢</option>
                <option value="sinc">Sinc</option>
                </select>
                æ¸²æŸ“æ¨¡å¼ï¼š<select id="renderMode">
                    <option value="normal">æ­£å¸¸</option>
                    <option value="water">æ°´æ± </option>
                </select>
            </div>

            <div class="transceivers">
                <button id="btnTrans" class="toggle">ğŸ”Š æ·»åŠ å‘å°„å™¨</button>
                <button id="btnRecv" class="toggle">ğŸ¤ æ·»åŠ æ¥æ”¶å™¨</button>
            </div>
        </div>
    </div>
    <div id="deviceList"></div>

    <script>
        class Transceiver {
            static idCounter = 0

            constructor(type, x, y) {
                this.id = `${type === 'transmitter' ? 'tx' : 'rx'}${Transceiver.idCounter++}`
                this.type = type
                this.x = Math.round(x)
                this.y = Math.round(y)
                this.marker = this.createMarker()
                this.panel = this.createControlPanel()
                this.initializePanel();
            }

            createMarker() {
                const marker = document.createElement('span')
                marker.className = 'transceiver-marker'
                marker.textContent = this.type === 'transmitter' ? 'ğŸ”Š' : 'ğŸ¤'
                marker.style.left = `${this.x / canvas.width * 100}%`
                marker.style.top = `${this.y / canvas.height * 100}%`
                document.querySelector('.canvas-container').appendChild(marker)

                const devLabel = document.createElement('div')
                devLabel.textContent = this.id;
                devLabel.style.color = 'white'
                devLabel.style.fontSize = '12px'
                marker.appendChild(devLabel)
                return marker
            }

            updatePosition(x, y) {
                this.x = x
                this.y = y
                this.marker.style.left = `${x}px`
                this.marker.style.top = `${y}px`
            }

            remove() {
                this.marker.remove()
                this.panel.remove()
            }

            createControlPanel() {
                const panel = document.createElement('div')
                panel.className = 'device-item'

                // æ·»åŠ è®¾å¤‡åç§°
                const name = document.createElement('div')
                name.textContent = this.type === 'transmitter' ? 'ğŸ”Šå‘å°„å™¨' : 'ğŸ¤æ¥æ”¶å™¨'
                panel.appendChild(name)

                // æ·»åŠ id
                const id = document.createElement('div')
                id.textContent = "ID: " + this.id
                panel.appendChild(id)

                // æ·»åŠ åæ ‡
                const pos = document.createElement('div')
                pos.textContent = `(${this.x.toFixed(0)}, ${this.y.toFixed(0)})`
                panel.appendChild(pos)

                return panel;
            }

            initializePanel() {

            }

            updatePanel() {

            }
        }

        class Transmitter extends Transceiver {
            constructor(x, y) {
                super('transmitter', x, y)
                this.frequency = 5
                this.amplitude = 10
                this.phase = 0
                this.enabled = true
                this.waveType = 'sine'
                this.audioBuffer = null
                this.audioPtr = 0
                this.sampleRate = 8000
            }

            applyEffect(buffer, tick) {
                if (!this.enabled) return
                if (this.waveType === 'audio') {
                    if (!this.audioBuffer) return
                    const idx = this.y * N + this.x;
                    buffer[idx] += this.audioBuffer.getChannelData(0)[this.audioPtr] * this.amplitude
                    this.audioPtr = (this.audioPtr + 1) % this.audioBuffer.length
                } else {
                    const idx = this.y * N + this.x;
                    const value = generateWave(this.waveType, this.frequency, this.phase, this.amplitude, tick / 60)
                    buffer[idx] += value
                }
            }

            initializePanel() {
                // æ·»åŠ å‚æ•°æ§åˆ¶
                const paramDiv = document.createElement('div')
                paramDiv.className = 'param-div'

                const freqLabel = document.createElement('label')
                freqLabel.textContent = 'é¢‘ç‡:'
                paramDiv.appendChild(freqLabel)
                const freqInput = document.createElement('input')
                freqInput.type = 'number'
                freqInput.max = 15
                freqInput.min = 0.1
                freqInput.step = 0.1
                freqInput.value = this.frequency
                freqInput.addEventListener('change', () => this.frequency = parseFloat(freqInput.value))
                paramDiv.appendChild(freqInput)
                this.freqInput = freqInput

                const ampLabel = document.createElement('label')
                ampLabel.textContent = 'æŒ¯å¹…:'
                paramDiv.appendChild(ampLabel)
                const ampInput = document.createElement('input')
                ampInput.type = 'number'
                ampInput.max = 100
                ampInput.min = 0.1
                ampInput.step = 0.1
                ampInput.value = this.amplitude
                ampInput.addEventListener('change', () => this.amplitude = parseFloat(ampInput.value))
                paramDiv.appendChild(ampInput)
                this.ampInput = ampInput

                const phaseLabel = document.createElement('label')
                phaseLabel.textContent = 'ç›¸ä½:'
                paramDiv.appendChild(phaseLabel)
                const phaseInput = document.createElement('input')
                phaseInput.type = 'number'
                phaseInput.max = 3.141
                phaseInput.min = -3.141
                phaseInput.step = 0.01
                phaseInput.value = this.phase
                phaseInput.addEventListener('change', () => this.phase = parseFloat(phaseInput.value))
                paramDiv.appendChild(phaseInput)
                this.phaseInput = phaseInput

                this.panel.appendChild(paramDiv)

                const waveTypeLabel = document.createElement('label')
                waveTypeLabel.textContent = 'æ³¢å½¢:'
                this.panel.appendChild(waveTypeLabel)
                const waveTypeSelect = document.createElement('select')
                waveTypeSelect.addEventListener('change', () => this.waveType = waveTypeSelect.value)
                const waveTypes = ['sine', 'square', 'sawtooth', 'triangle', 'noise']
                waveTypes.forEach(type => {
                    const option = document.createElement('option')
                    option.value = type
                    option.textContent = type
                    waveTypeSelect.appendChild(option)
                })
                waveTypeSelect.value = this.waveType
                waveTypeSelect.addEventListener('change', () => this.waveType = waveTypeSelect.value)
                this.panel.appendChild(waveTypeSelect)
                this.waveTypeSelect = waveTypeSelect

                // æ·»åŠ éŸ³é¢‘ä¸Šä¼ 
                this.playbackTime = document.createElement('div')
                this.panel.appendChild(this.playbackTime)

                this.slider = document.createElement('input')
                this.slider.type = 'range'
                this.slider.min = 0
                this.slider.max = 100
                this.slider.value = 0
                this.slider.addEventListener('input', e => {
                    this.audioPtr = Math.floor(this.audioBuffer.length * e.target.value / 100)
                })
                this.panel.appendChild(this.slider)

                this.panel.appendChild(document.createElement('br'))

                const sampleRateLabel = document.createElement('label')
                sampleRateLabel.textContent = 'é‡‡æ ·ç‡:'
                this.panel.appendChild(sampleRateLabel)
                const sampleRateInput = document.createElement('input')
                sampleRateInput.type = 'number'
                sampleRateInput.max = 48000
                sampleRateInput.min = 1000
                sampleRateInput.value = 8000
                sampleRateInput.addEventListener('change', e => {
                    this.sampleRate = parseInt(e.target.value)
                })
                this.panel.appendChild(sampleRateInput)
                this.sampleRateInput = sampleRateInput


                const audioUpload = document.createElement('input')
                audioUpload.type = 'file'
                audioUpload.accept = 'audio/*'
                audioUpload.hidden = true
                audioUpload.addEventListener('change', e => {
                    const file = e.target.files[0]
                    if (file) {
                        const reader = new FileReader()
                        reader.onload = e => {
                            const audioCtx = new AudioContext({ sampleRate: this.sampleRate })
                            audioCtx.decodeAudioData(e.target.result).then(buffer => {
                                this.audioBuffer = buffer
                                this.waveType = 'audio'
                            })
                        }
                        reader.readAsArrayBuffer(file)
                    }
                })
                this.panel.appendChild(audioUpload)

                this.panel.appendChild(document.createElement('br'))


                const toggleBtn = document.createElement('button')
                toggleBtn.textContent = this.enabled ? 'â–¶ï¸' : 'â¸ï¸'
                toggleBtn.addEventListener('click', () => {
                    this.enabled = !this.enabled
                    toggleBtn.textContent = this.enabled ? 'â¸ï¸' : 'â–¶ï¸'
                })
                this.panel.appendChild(toggleBtn)

                const uploadBtn = document.createElement('button')
                uploadBtn.textContent = 'ğŸµ'
                uploadBtn.addEventListener('click', () => audioUpload.click())
                this.panel.appendChild(uploadBtn)

                // æ·»åŠ åˆ é™¤æŒ‰é’®
                const removeBtn = document.createElement('button')
                removeBtn.textContent = 'âŒ'
                removeBtn.addEventListener('click', () => removeDevice(this.id))
                this.panel.appendChild(removeBtn)
            }

            updatePanel() {
                this.freqInput.value = this.frequency
                this.ampInput.value = this.amplitude
                this.phaseInput.value = this.phase
                this.waveTypeSelect.value = this.waveType
                this.sampleRateInput.value = this.sampleRate
            }

            repaint() {
                if (this.audioBuffer) {
                    this.playbackTime.textContent = `æ’­æ”¾è¿›åº¦: ${(this.audioPtr / this.sampleRate).toFixed(3)}s / ${(this.audioBuffer.length / this.sampleRate).toFixed(3)}s`
                    this.slider.value = this.audioPtr / this.audioBuffer.length * 100
                }
            }
        }

        class Receiver extends Transceiver {
            constructor(x, y) {
                super('receiver', x, y)
                this.sampleRate = 8000
                this.buffer = new Float32Array(4096)
                this.writePointer = 0
                this.lastSampleTime = 0
                this.paused = false
                this.maxBufferSize = 64 * 1024 * 1024 / Float32Array.BYTES_PER_ELEMENT;
            }

            recordSample(waveValue) {
                if (this.paused) return;
                if (this.writePointer >= this.maxBufferSize) return;
                else if (this.writePointer >= this.buffer.length) {
                    // è‡ªåŠ¨æ‰©å®¹
                    this.expandBuffer();
                }
                this.buffer[this.writePointer++] = waveValue;
            }

            expandBuffer() {
                const newBuffer = new Float32Array(this.buffer.length * 2);
                newBuffer.set(this.buffer)
                this.buffer = newBuffer;
                console.log('Buffer expanded to ' + this.buffer.length);
            }

            exportWAV() {
                const exportLength = this.writePointer;
                const wavBuffer = new ArrayBuffer(44 + exportLength * 4);
                const view = new DataView(wavBuffer);

                // WAV å¤´éƒ¨
                writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + exportLength * 4, true);
                writeString(view, 8, 'WAVE');
                writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 3, true); // PCM float
                view.setUint16(22, 1, true);
                view.setUint32(24, this.sampleRate, true);
                view.setUint32(28, this.sampleRate * 4, true); // byte rate
                view.setUint16(32, 4, true); // block align
                view.setUint16(34, 32, true); // bits per sample
                writeString(view, 36, 'data');
                view.setUint32(40, exportLength * 4, true);

                // PCMæ•°æ® (float32)
                let offset = 44;
                for (let i = 0; i < exportLength; i++) {
                    view.setFloat32(offset, this.buffer[i], true);
                    offset += 4;
                }

                const blob = new Blob([view], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `recording_${this.id}.wav`;
                a.click();
            }

            setPaused(paused) {
                this.paused = paused
            }

            setSamplerate(sr) {
                this.sampleRate = sr;
            }

            initializePanel() {
                // æ·»åŠ å‚æ•°ç¼–è¾‘
                const paramDiv = document.createElement('div')
                paramDiv.className = 'param-div';

                const srLabel = document.createElement('label');
                srLabel.innerText = 'é‡‡æ ·ç‡ï¼š'
                paramDiv.appendChild(srLabel)

                const srInput = document.createElement('input')
                srInput.type = 'number'
                srInput.max = 48000;
                srInput.min = 1000;
                srInput.value = 8000;
                srInput.addEventListener('change', e => {
                    this.sampleRate = srInput.value;
                })
                paramDiv.appendChild(srInput);
                this.panel.appendChild(paramDiv)
                this.srInput = srInput

                // æ·»åŠ å·²å½•æ—¶é•¿æ˜¾ç¤º
                const duration = document.createElement('div')
                this.panel.appendChild(duration)
                this.durationDisplay = duration

                // æ·»åŠ æ³¢å½¢æ˜¾ç¤º
                const receiverCanvas = document.createElement('canvas');
                receiverCanvas.style.width = '150px'
                receiverCanvas.style.height = '112.5px'
                receiverCanvas.style.border = '1px solid #ffffff40'
                const receiverCtx = receiverCanvas.getContext('2d')
                receiverCtx.strokeStyle = 'white';
                this.panel.appendChild(receiverCanvas);
                this.receiverCtx = receiverCtx;
                this.receiverCanvas = receiverCanvas;

                const rmsDisplay = document.createElement('div');
                this.panel.appendChild(rmsDisplay);
                this.rmsDisplay = rmsDisplay;

                const resizeObserver = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        if (entry.target === receiverCanvas) {
                            receiverCanvas.width = receiverCanvas.clientWidth * window.devicePixelRatio;
                            receiverCanvas.height = receiverCanvas.clientHeight * window.devicePixelRatio;
                            receiverCtx.strokeStyle = 'white';
                        }
                    }
                });
                resizeObserver.observe(receiverCanvas)

                // æ·»åŠ æš‚åœæŒ‰é’®
                const toggleBtn = document.createElement('button')
                toggleBtn.textContent = 'â¸ï¸'
                toggleBtn.addEventListener('click', () => {
                    this.setPaused(toggleBtn.textContent === 'â¸ï¸')
                    toggleBtn.textContent = toggleBtn.textContent === 'â¸ï¸' ? 'â–¶ï¸' : 'â¸ï¸'
                })
                this.panel.appendChild(toggleBtn)

                const exportBtn = document.createElement('button')
                exportBtn.textContent = 'ğŸ“¤'
                exportBtn.addEventListener('click', () => this.exportWAV())
                this.panel.appendChild(exportBtn)

                const eraseBtn = document.createElement('button')
                eraseBtn.textContent = 'ğŸ§¹'
                eraseBtn.addEventListener('click', () => this.erase())
                this.panel.appendChild(eraseBtn)

                // æ·»åŠ åˆ é™¤æŒ‰é’®
                const removeBtn = document.createElement('button')
                removeBtn.textContent = 'âŒ'
                removeBtn.addEventListener('click', () => removeDevice(this.id))
                this.panel.appendChild(removeBtn)
            }

            updatePanel() {
                this.srInput.value = this.sampleRate
            }

            repaint() {
                const durationSec = this.writePointer / this.sampleRate
                this.durationDisplay.textContent = `å·²å½•åˆ¶: ${durationSec.toFixed(3)}s`

                let samples = this.buffer.slice(this.writePointer - 100, this.writePointer);

                let half = this.receiverCanvas.height / 2;
                let step = this.receiverCanvas.width / samples.length;

                this.receiverCtx.clearRect(0, 0, this.receiverCanvas.width, this.receiverCanvas.height)
                this.receiverCtx.beginPath()
                this.receiverCtx.moveTo(0, samples[0] * half + half)

                let rms = 0;
                for (let x = 0; x < samples.length; x++) {
                    let sample = samples[x]
                    this.receiverCtx.lineTo(x * step, sample * half + half)
                    rms += sample * sample;
                }
                rms /= samples.length;
                rms = Math.sqrt(rms);
                this.rmsDisplay.innerText = `RMS: ${(Math.log(rms) * 10).toFixed(1)} dB`
                this.receiverCtx.stroke();
            }

            erase() {
                this.buffer.fill(0)
                this.writePointer = 0
            }
        }
        
        class WavePacket {
    constructor(x,y,frequency, amplitude, phase, lifetime) {
    	this.x=Math.floor(x);
    	this.y=Math.floor(y);
        this.frequency = frequency;  // æ³¢åŒ…é¢‘ç‡ï¼ˆHzï¼‰
        this.amplitude = amplitude;  // æœ€å¤§æŒ¯å¹…
        this.phase = phase;          // åˆå§‹ç›¸ä½ï¼ˆå¼§åº¦ï¼‰
        this.lifetime = lifetime;    // æ³¢åŒ…æŒç»­æ—¶é—´ï¼ˆå•ä½ï¼šé‡‡æ ·ç‚¹æ•°ï¼‰
        this.tick = -1;              // å½“å‰é‡‡æ ·ç‚¹è®¡æ•°å™¨ï¼ˆä»0å¼€å§‹ï¼‰
        this.sampleRate = 60;        // é‡‡æ ·ç‡ï¼ˆæ¯ç§’é‡‡æ ·æ•°ï¼‰
    }
    
    applyEffect(buffer) {
                    const idx = this.y * N + this.x;
                    buffer[idx] += this.getSample();
            }
    
    getSample() {
        this.tick++; // æ¯æ¬¡è·å–æ ·æœ¬æ—¶æ¨è¿›è®¡æ•°å™¨
        return 0;    // åŸºç±»é»˜è®¤è¿”å›0ï¼Œç”±å­ç±»è¦†ç›–å®ç°
    }
}

class GaussianWavePacket extends WavePacket {
    getSample() {
        super.getSample(); // è°ƒç”¨çˆ¶ç±»æ–¹æ³•æ¨è¿›tickè®¡æ•°å™¨

        // è¶…å‡ºç”Ÿå‘½å‘¨æœŸåè¿”å›0ï¼ˆé˜²æ­¢æ— é™ç”Ÿæˆï¼‰
        if (this.tick >= this.lifetime) return 0;

        // é«˜æ–¯åŒ…ç»œè®¡ç®—ï¼ˆä»¥æ³¢åŒ…ä¸­å¿ƒä¸ºå¯¹ç§°ç‚¹ï¼‰
        const center = this.lifetime * 0.5; // æ³¢åŒ…ä¸­å¿ƒä½ç½®ï¼ˆé‡‡æ ·ç‚¹æ•°ï¼‰
        const delta = this.tick - center;    // å½“å‰ç‚¹ä¸ä¸­å¿ƒçš„åç§»é‡
        
        // é«˜æ–¯å®½åº¦æ§åˆ¶ï¼ˆÏƒè®¾ä¸ºç”Ÿå‘½å‘¨æœŸé•¿åº¦çš„20%ï¼‰
        const sigma = this.lifetime * 0.2; 
        const exponent = -(delta ** 2) / (2 * sigma ** 2);
        const envelope = this.amplitude * Math.exp(exponent);

        // è½½æ³¢ä¿¡å·è®¡ç®—ï¼ˆè€ƒè™‘é‡‡æ ·ç‡è½¬æ¢ä¸ºå®é™…æ—¶é—´ï¼‰
        const time = this.tick / this.sampleRate; // å½“å‰æ—¶é—´ï¼ˆç§’ï¼‰
        const phase = 2 * Math.PI * this.frequency * time + this.phase;
        
        return envelope * Math.cos(phase);
    }
}

// çŸ©å½¢æ³¢åŒ…ï¼ˆçŸ©å½¢çª—+ä½™å¼¦è½½æ³¢ï¼‰
class RectangularWavePacket extends WavePacket {
    getSample() {
        super.getSample();
        
        // è¶…å‡ºç”Ÿå‘½å‘¨æœŸè¿”å›0
        if (this.tick >= this.lifetime) return 0;

        // çŸ©å½¢åŒ…ç»œï¼šåœ¨ç”Ÿå‘½å‘¨æœŸå†…ä¿æŒæ’å®šæŒ¯å¹…
        const envelope = (this.tick >= 0 && this.tick < this.lifetime) 
            ? this.amplitude 
            : 0;

        // è½½æ³¢ä¿¡å·è®¡ç®—
        const time = this.tick / this.sampleRate;
        const phase = 2 * Math.PI * this.frequency * time + this.phase;
        
        return envelope * Math.cos(phase);
    }
}

// Sincæ³¢åŒ…ï¼ˆsincå‡½æ•°åŒ…ç»œ+ä½™å¼¦è½½æ³¢ï¼‰
class SincWavePacket extends WavePacket {
    getSample() {
        super.getSample();
        
        // è¶…å‡ºç”Ÿå‘½å‘¨æœŸè¿”å›0
        if (this.tick >= this.lifetime) return 0;

        // è®¡ç®—ä¸­å¿ƒå¯¹ç§°æ—¶é—´è½´
        const center = this.lifetime / 2;
        const delta = (this.tick - center) / this.sampleRate; // è½¬æ¢ä¸ºç§’
        
        // é¿å…é™¤ä»¥é›¶çš„sincè®¡ç®—
        let sinc;
        if (delta === 0) {
            sinc = 1; // sinc(0) = 1
        } else {
            const omega = Math.PI * 2 * this.frequency; // æ§åˆ¶ä¸»ç“£å®½åº¦
            sinc = Math.sin(omega * delta) / (omega * delta);
        }

        // åŒ…ç»œæŒ¯å¹…ä¸è½½æ³¢åˆæˆ
        const envelope = this.amplitude * sinc;
        const phase = 2 * Math.PI * this.frequency * (this.tick / this.sampleRate) + this.phase;
        
        return envelope * Math.cos(phase);
    }
}



        const materialDefs = [
            {},
            { // å¢™ä½“
                'name': 'å¢™å£',
                'color': [200, 50, 50],
                'damping': 1.0,
                'waveSpeed': 0.625
            },
            { // é€é•œ
                'name': 'é€é•œ',
                'color': [50, 100, 100],
                'damping': 0.0,
                'waveSpeed': 0.25,
            },
            { // é€é•œ
                'name': 'æµ·ç»µ',
                'color': [226, 210, 74],
                'damping': 0.1,
                'waveSpeed': 0.625,
            }
        ]


        // åˆå§‹åŒ–å‚æ•°
        const N = 512;           // ç½‘æ ¼å°ºå¯¸
        let airDamping = 0.005;   // é˜»å°¼ç³»æ•°
        const waveSpeed = 0.625;   // æ³¢é€Ÿ

        // è·å–Canvasä¸Šä¸‹æ–‡
        const canvas = document.getElementById('waveCanvas');
        const ctx = canvas.getContext('2d');

        // è®¾ç½®Canvaså°ºå¯¸
        canvas.width = N;
        canvas.height = N;

        // åˆå§‹åŒ–æ³¢åœºå’Œéšœç¢ç‰©
        let buffers = [
            new Float32Array(N * N),
            new Float32Array(N * N),
            new Float32Array(N * N)
        ];
        let obstacles = new Uint8Array(N * N); // éšœç¢ç‰©æ ‡è®°
        let current = 0;
        let tick = 0;

        // åˆ›å»ºImageDataç”¨äºå¿«é€Ÿç»˜åˆ¶
        const imageData = ctx.createImageData(N, N);
        const data = imageData.data;

        // äº¤äº’ç›¸å…³å˜é‡
        let mousePos = null;
        let isDrawing = false;
        let currentMode = 'wave'; // wave/obstacle/erase/trans/recv
        let brushSize = 3;
        let renderMode = 'normal';

        // æ·»åŠ å‘å°„å™¨
        let transceivers = new Set();
        let wavePackets = new Set();

        // è·å–UIå…ƒç´ 
        const frequency = document.getElementById('frequency');
        const amplitude = document.getElementById('amplitude');
        const brushSizeInput = document.getElementById('brushSize');
        const dampingInput = document.getElementById('damping');
        const waveType = document.getElementById('waveType');
        const deviceList = document.getElementById('deviceList')
        const materialSelect = document.getElementById('material')

        // åˆå§‹åŒ–ææ–™é€‰æ‹©
        materialDefs.forEach((material, idx) => {
            if (idx === 0) return;
            const materialButton = document.createElement('button')
            materialButton.style.backgroundColor = `rgb(${material.color.join(',')})`
            materialButton.appendChild(document.createTextNode(material.name || `ææ–™${idx}`))
            materialButton.addEventListener('click', () => {
                materialSelect.value = idx
                // set selected
                document.querySelectorAll('#material button').forEach(b => b.classList.remove('selected'))
                materialButton.classList.add('selected')
            })

            // æ£€æµ‹å…ƒç´ äº®åº¦è®¾ç½®æ–‡å­—æ˜¯é»‘è¿˜æ˜¯ç™½
            const brightness = (material.color[0] * 299 + material.color[1] * 587 + material.color[2] * 114) / 1000;
            materialButton.style.color = brightness > 125 ? 'black' : 'white';

            materialSelect.appendChild(materialButton)
        })
        // è®¾ç½®ç¬¬ä¸€ä¸ªæŒ‰é’®ä¸ºå·²é€‰æ‹©
        materialSelect.value = 1
        materialSelect.children[0].classList.add('selected')

        // æ¨¡å¼åˆ‡æ¢æŒ‰é’®
        document.querySelectorAll('.toggle').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentMode = btn.id.replace('btn', '').toLowerCase();
            });
        });

        // é˜»å°¼ç³»æ•°æ§åˆ¶
        dampingInput.addEventListener('change', () => {
            airDamping = parseFloat(dampingInput.value);
        });

        // ç¬”åˆ·å¤§å°æ§åˆ¶
        brushSizeInput.addEventListener('input', () => {
            brushSize = parseInt(brushSizeInput.value);
            document.getElementById('brushSizeValue').textContent = brushSize;
        });

        // æ³¢åŠ¨æ–¹ç¨‹æ›´æ–°
        function updateWave() {
            const prev = (current + 2) % 3;
            const curr = current;
            const next = (current + 1) % 3;

            // ä¿®æ”¹åçš„æ‹‰æ™®æ‹‰æ–¯ç®—å­è®¡ç®—ï¼ˆåŒ…å«å¯¹è§’çº¿é¡¹ï¼‰
            for (let y = 1; y < N - 1; y++) {
                for (let x = 1; x < N - 1; x++) {
                    const idx = y * N + x;
                    const waveSpeedF = materialDefs[obstacles[idx]]?.waveSpeed || waveSpeed;

                    // æ ‡å‡†æ‹‰æ™®æ‹‰æ–¯é¡¹
                    const laplacian =
                        buffers[curr][idx - 1] +
                        buffers[curr][idx + 1] +
                        buffers[curr][idx - N] +
                        buffers[curr][idx + N] -
                        4 * buffers[curr][idx];

                    // æ–°å¢å¯¹è§’çº¿é¡¹ï¼ˆå„å‘åŒæ€§ä¿®æ­£ï¼‰
                    const diagLaplacian =
                        buffers[curr][idx - N - 1] +
                        buffers[curr][idx - N + 1] +
                        buffers[curr][idx + N - 1] +
                        buffers[curr][idx + N + 1] -
                        4 * buffers[curr][idx];

                    // æ··åˆæ‹‰æ™®æ‹‰æ–¯ç®—å­
                    const blendedLaplacian = 0.8 * laplacian + 0.2 * diagLaplacian;

                    // ä¿®æ”¹åçš„æ›´æ–°æ–¹ç¨‹
                    buffers[next][idx] = (
                        buffers[curr][idx] * 2 -
                        buffers[prev][idx] + blendedLaplacian * waveSpeedF
                    ) * (1 - airDamping);

                    if (obstacles[idx]) {
                        buffers[next][idx] *= (1 - materialDefs[obstacles[idx]].damping);
                        continue;
                    }
                }
            }

            transceivers.forEach(dev => {
                if (dev instanceof Transmitter) {
                    dev.applyEffect(buffers[current], tick)
                } else if (dev instanceof Receiver) {
                    const idx = dev.y * N + dev.x;
                    dev.recordSample(buffers[current][idx])
                }
            })
            
            wavePackets.forEach(packet=>{
            	packet.applyEffect(buffers[current])
            	//if (this.tick >= this.lifetime) 
            })

            tick++;
            current = next;
        }

        // æ¸²æŸ“å‡½æ•°
        function render() {
            switch (renderMode) {
                case 'water':
                    renderWater()
                    break;
                default:
                    renderNormal();
                    break;
            }
        }

        function renderNormal() {
            for (let i = 0; i < N * N; i++) {
                const idx = i << 2;

                const val = clamp(Math.sqrt(Math.abs(buffers[current][i])), 0, 1) * 255;
                if (buffers[current][i] > 0) {
                    data[idx] = val;    // R
                    data[idx + 1] = val * 0.5;  // G
                    data[idx + 2] = 0;  // B
                } else {
                    data[idx] = 0;    // R
                    data[idx + 1] = val * 0.5;  // G
                    data[idx + 2] = val;  // B
                }

                if (obstacles[i]) {
                    let material = materialDefs[obstacles[i]];
                    data[idx] += material.color[0];    // R
                    data[idx + 1] += material.color[1];   // G
                    data[idx + 2] += material.color[2];   // B
                }

                data[idx + 3] = 255;      // A
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function renderWater() {
            // åŸºç¡€æ°´è“è‰²
            const baseR = 0x13, baseG = 0x99, baseB = 0xde;
            // å…‰ç…§æ–¹å‘ï¼š45Â°ï¼ˆå•ä½å‘é‡ï¼‰
            const lightAngle = Math.PI / 4;
            const Lx = Math.cos(lightAngle);
            const Ly = Math.sin(lightAngle);
            // è°ƒèŠ‚äº®åº¦å˜åŒ–çš„ç³»æ•°ï¼Œæ ¹æ®å®é™…æ³¢åŠ¨å¹…åº¦è°ƒæ•´
            const shadingCoefficient = 1;

            // å¯¹æ¯ä¸ªåƒç´ è®¡ç®—æ¸²æŸ“é¢œè‰²
            for (let y = 0; y < N; y++) {
                for (let x = 0; x < N; x++) {
                    const i = y * N + x;

                    if (obstacles[i]) {
                        let material = materialDefs[obstacles[i]];
                        const idx = i << 2;
                        data[idx] = material.color[0];    // R
                        data[idx + 1] = material.color[1];   // G
                        data[idx + 2] = material.color[2];   // B
                        data[idx + 3] = 255;  // ä¸é€æ˜
                    } else {
                        let dx = 0, dy = 0;

                        // å¯¹å†…éƒ¨åƒç´ ä½¿ç”¨ä¸­å¤®å·®åˆ†ï¼ˆè¾¹ç•Œä¸Šç®€å•å–0æ¢¯åº¦ï¼‰
                        if (x > 0 && x < N - 1) {
                            dx = (buffers[current][i + 1] - buffers[current][i - 1]) * 0.5;
                        }
                        if (y > 0 && y < N - 1) {
                            dy = (buffers[current][i + N] - buffers[current][i - N]) * 0.5;
                        }
                        // æ¢¯åº¦æ¨¡é•¿
                        const gradMag = Math.sqrt(dx * dx + dy * dy);

                        // è®¡ç®—äº®åº¦ç³»æ•°
                        let brightnessFactor = 1; // é»˜è®¤æ— æ¢¯åº¦æ—¶ç³»æ•°ä¸º1
                        if (gradMag > 0) {
                            // è®¡ç®—æ¢¯åº¦å‘é‡ä¸å…‰æ–¹å‘çš„ä½™å¼¦å€¼
                            const cosAngle = (dx * Lx + dy * Ly) / gradMag;
                            brightnessFactor = 1 + shadingCoefficient * gradMag * cosAngle;
                        }

                        // æ ¹æ®äº®åº¦ç³»æ•°è°ƒæ•´åŸºç¡€è‰²
                        const R = clamp(Math.floor(baseR * brightnessFactor), 0, 255);
                        const G = clamp(Math.floor(baseG * brightnessFactor), 0, 255);
                        const B = clamp(Math.floor(baseB * brightnessFactor), 0, 255);

                        // å†™å…¥ imageData æ•°ç»„
                        const idx = (i << 2);
                        data[idx] = R;        // Ré€šé“
                        data[idx + 1] = G;    // Gé€šé“
                        data[idx + 2] = B;    // Bé€šé“
                        data[idx + 3] = 255;  // ä¸é€æ˜

                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }


        // æ·»åŠ éšœç¢ç‰©/æ“¦é™¤
        function modifyObstacles(x, y, isAdd) {
            const r = brushSize;
            for (let xx = -r; xx <= r; xx++) {
                for (let yy = -r; yy <= r; yy++) {
                    const nx = x + xx;
                    const ny = y + yy;
                    if (nx < 0 || nx >= N || ny < 0 || ny >= N) continue;
                    const idx = ny * N + nx;
                    obstacles[idx] = isAdd ? materialSelect.value : 0;
                }
            }
        }

        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        canvas.addEventListener('click', (e) => {
        	    const rect = canvas.getBoundingClientRect()
            const x = (e.clientX - rect.left) * (N / rect.width)
            const y = (e.clientY - rect.top) * (N / rect.height)
            
            switch (currentMode){
            	case "trans":
            	case "recv":
        
            const dev = currentMode === 'trans'
                ? new Transmitter(x, y)
                : new Receiver(x, y)

            transceivers.add(dev)
            deviceList.appendChild(dev.panel)
            updateDeviceList()
            currentMode = '';
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        
            break;
            case "packet":
            const type=document.getElementById("wavePackets").value
            
            switch (type){
            	case "gauss":
            	wavePackets.add(new GaussianWavePacket(x,y,frequency.value, amplitude.value, 0, 60));
            	break;
            		case "rect":
            	wavePackets.add(new RectangularWavePacket(x,y,frequency.value, amplitude.value, 0, 60));
            	break
            		case "sinc":
            	wavePackets.add(new SincWavePacket(x,y,frequency.value, amplitude.value, 0, 60));
            	break
            }
            }

            })

        function updateDeviceList() {
            transceivers.forEach(dev => dev.updatePanel())
        }


        function removeDevice(id) {
            for (const dev of transceivers) {
                if (dev.id === id) {
                    dev.remove();
                    transceivers.delete(dev)
                    updateDeviceList()
                    return
                }
            }
        }

        // å¯¼å…¥éšœç¢å›¾
        // æ·»åŠ å›¾åƒå¤„ç†å‡½æ•°
        function handleImageUpload(file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const img = new Image();
                img.onload = function () {
                    processImage(img);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function processImage(img) {
            // åˆ›å»ºä¸´æ—¶Canvasè¿›è¡Œé¢„å¤„ç†
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            // è®¾ç½®å°ºå¯¸ä¸º512x512
            tempCanvas.width = N;
            tempCanvas.height = N;

            // ç»˜åˆ¶å¹¶ç¼©æ”¾å›¾åƒ
            tempCtx.drawImage(img, 0, 0, N, N);

            // è·å–å›¾åƒæ•°æ®
            const imageData = tempCtx.getImageData(0, 0, N, N);
            const pixels = imageData.data;

            // äºŒå€¼åŒ–å¤„ç†å¹¶æ›´æ–°éšœç¢ç‰©
            for (let i = 0; i < N * N; i++) {
                const r = pixels[i * 4];
                const g = pixels[i * 4 + 1];
                const b = pixels[i * 4 + 2];

                // è®¡ç®—äº®åº¦ï¼ˆYUV/YIQæ¨¡å‹ï¼‰
                const brightness = r * 0.299 + g * 0.587 + b * 0.114;
                obstacles[i] = brightness > 128 ? 0 : 1; // é˜ˆå€¼128
            }

            // è§¦å‘é‡ç»˜
            render();
        }

        function clear() {
            for (const buffer of buffers) {
                buffer.fill(0);
            }
            obstacles.fill(0);
            for (const dev of transceivers) {
                removeDevice(dev.id)
            }
        }

        document.getElementById('btnStop').addEventListener('click', () => {
            for (const buffer of buffers) {
                buffer.fill(0);
            }
        });

        document.getElementById('btnClear').addEventListener('click', clear);

        // ç»‘å®šæ–‡ä»¶è¾“å…¥äº‹ä»¶
        document.getElementById('importImage').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleImageUpload(file);
        });

        // è¾…åŠ©å‡½æ•°
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i))
            }
        }

        // ç”Ÿæˆæ³¢å½¢

        /** * ç”Ÿæˆæ³¢å½¢
            * @param {string} type æ³¢å½¢ç±»å‹
            * @param {number} f é¢‘ç‡
            * @param {number} p ç›¸ä½
            * @param {number} a æŒ¯å¹…
            * @param {number} t æ—¶é—´
            * @returns {number} æ³¢å½¢å€¼
         */
        function generateWave(type, f, p, a, t) {
            switch (type) {
                case 'sine':
                    return Math.sin(2 * Math.PI * f * t + p) * a;
                case 'square':
                    return Math.sign(Math.sin(2 * Math.PI * f * t + p)) * a;
                case 'sawtooth':
                    return (2 * (f * t + p) % 2 - 1) * a;
                case 'triangle':
                    return Math.abs((2 * (f * t + p) % 2 - 1)) * a;
                case 'noise':
                    return (Math.random() * 2 - 1) * a;
            }
        }


        // äº‹ä»¶å¤„ç†
        function updateMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / canvas.offsetWidth;
            const scaleY = canvas.height / canvas.offsetHeight;
            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);
            mousePos = [x, y];
        }

        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            updateMousePos(e);
        });

        canvas.addEventListener('mousemove', (e) => {
            updateMousePos(e);
            if (!isDrawing) return;
        });

        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseleave', () => isDrawing = false);

        // è§¦æ‘¸äº‹ä»¶å¤„ç†
        canvas.addEventListener('touchstart', (e) => {
            // e.preventDefault();
            isDrawing = true;
            updateMousePos(e.touches[0]);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            updateMousePos(e.touches[0]);
            if (!isDrawing) return;

        }, { passive: false });

        canvas.addEventListener('touchend', () => isDrawing = false);

        const renderSelect = document.getElementById('renderMode');

        renderSelect.addEventListener('change', e => {
            renderMode = renderSelect.value;
        })

        // æ³¢åŠ¨æ¿€åŠ±
        function addDisturbance(x, y) {
            if (x < 0 || x >= N || y < 0 || y >= N) return;
            const idx = y * N + x;
            const t = tick / 60;
            buffers[current][idx] += generateWave(waveType.value, frequency.value, 0, amplitude.value, t) //Math.sin(2 * Math.PI * frequency.value * t) * amplitude.value;
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            if (isDrawing) touch();
            updateWave();
            render();
            for (const dev of transceivers) {
                dev.repaint()
            }
        }

        function touch() {
            if (currentMode === 'wave') {
                addDisturbance(mousePos[0], mousePos[1]);
            } else {
                modifyObstacles(mousePos[0], mousePos[1], currentMode === 'obstacle');
            }
        }
        animate();

        function acquireWakelock() {
            if ('wakeLock' in navigator) {
                try {
                    navigator.wakeLock.request('screen').then(lock => {
                        lock.addEventListener('release', e => {
                            console.log("wakelock released");
                        })
                    });
                } catch (error) {
                    console.error(error);
                }
            }
        }

        document.addEventListener("visibilitychange", function () {
            if (document.visibilityState === 'visible') {
                acquireWakelock();
            }
        });

    </script>
</body>

</html>