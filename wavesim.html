<!DOCTYPE html>
<html>

<head>
    <title>波动模拟玩具</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        #waveCanvas {
            cursor: crosshair;
            height: auto;
            width: 100vh;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            background: #1a1a1a;
            color: white;
            flex-wrap: wrap;
        }

        .main {
            display: flex;
            align-items: center;
        }

        .tools {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-left: 16px;
        }

        .controls {
            display: grid;
            gap: 10px;
            grid-template-columns: repeat(2, 1fr);
            align-items: center;
        }

        .parameters {
            display: flex;
            flex-direction: column;
        }

        .param-div {
            display: flex;
            flex-direction: column;
        }

        button {
            padding: 8px;
            cursor: pointer;
            background: #333;
            border: 1px solid #666;
            color: white;
        }

        button.active {
            background: #4CAF50;
            border-color: #45a049;
        }

        .canvas-container {
            position: relative;
            margin: 10px;
        }

        .transceiver-marker {
            position: absolute;
            pointer-events: none;
            font-size: 1rem;
            transform: translate(-50%, -50%);
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #deviceList {
            padding: 10px;
            border: 1px solid #444;
            display: flex;
            flex-wrap: wrap;
            max-height: 100vh;
            min-width: min-content;
            max-width: fit-content;
            overflow-y: auto;
        }

        .device-item {
            margin: 5px;
            padding: 8px;
            background: #222;
        }

        .transceivers {
            gap: 10px;
            display: flex;
            flex-direction: column;
            margin: 8px;
        }


        select {
            background-color: #333;
            /* Dark background color for select dropdown */
            color: #fff;
            /* Light text color for select options */
            padding: 8px;
            border: 1px solid #666;
            /* Dark border color */
            border-radius: 4px;
            appearance: none;
            /* Remove default appearance */
            transition: background-color 0.3s;
        }

        select:hover,
        select:focus {
            background-color: #444;
            /* Change background color on hover/focus */
        }

        input[type="number"] {
            background-color: #333;
            /* Dark background color for input */
            color: #fff;
            /* Light text color for input */
            padding: 8px;
            border: 1px solid #666;
            /* Dark border color */
            border-radius: 4px;
            appearance: none;
            /* Remove default appearance */
            transition: background-color 0.3s;
        }

        .selected {
            border: 3px solid #4CAF50;
        }

        @media (max-width: 1024px) {
            body {
                flex-direction: column;
            }
        }

        @media (max-width: 700px) {
            canvas {
                width: 100%;
            }

            body {
                max-width: 100%;
            }

            .main {
                flex-direction: column;
            }

            .controls {
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }

            .transceivers {
                flex-direction: row;
            }

            #waveCanvas {
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <div class="main">
        <div class="canvas-container">
            <canvas id="waveCanvas"></canvas>
        </div>


        <div class="tools">
            <div class="controls">
                <button id="btnWave" class="toggle active">🌊 放波</button>
                <button id="btnObstacle" class="toggle">🧱 绘制</button>
                <button id="btnErase" class="toggle">🧹 擦除</button>

                <div>
                    <input type="file" id="importImage" accept="image/*" hidden>
                    <button onclick="document.getElementById('importImage').click()">🖼️ 导入</button>
                </div>

                <button id="btnStop">🛑 停波</button>
                <button id="btnClear">❌ 清空</button>
                <button id="btnPacket" class="toggle">📦 波包</button>
            </div>

            <div class="parameters">
                阻尼：<input type="number" id="damping" min="0" max="0.1" step="0.001" value="0.005">
                振幅：<input type="number" id="amplitude" min="0.01" max="100" step="0.1" value="10">
                频率：<input type="number" id="frequency" min="0" max="15" step="0.1" value="5">
                笔刷大小：<input type="range" id="brushSize" min="1" max="20" value="3"> <span id="brushSizeValue">3</span>
                笔刷材料：<div id="material">
                </div>
                波形：<select id="waveType">
                    <option value="sine">正弦波</option>
                    <option value="square">方波</option>
                    <option value="sawtooth">锯齿波</option>
                    <option value="triangle">三角波</option>
                    <option value="noise">噪声</option>
                </select>
                波包：<select id="wavePackets">
                <option value="gauss">高斯</option>
                <option value="rect">矩形</option>
                <option value="sinc">Sinc</option>
                </select>
                渲染模式：<select id="renderMode">
                    <option value="normal">正常</option>
                    <option value="water">水池</option>
                </select>
            </div>

            <div class="transceivers">
                <button id="btnTrans" class="toggle">🔊 添加发射器</button>
                <button id="btnRecv" class="toggle">🎤 添加接收器</button>
            </div>
        </div>
    </div>
    <div id="deviceList"></div>

    <script>
        class Transceiver {
            static idCounter = 0

            constructor(type, x, y) {
                this.id = `${type === 'transmitter' ? 'tx' : 'rx'}${Transceiver.idCounter++}`
                this.type = type
                this.x = Math.round(x)
                this.y = Math.round(y)
                this.marker = this.createMarker()
                this.panel = this.createControlPanel()
                this.initializePanel();
            }

            createMarker() {
                const marker = document.createElement('span')
                marker.className = 'transceiver-marker'
                marker.textContent = this.type === 'transmitter' ? '🔊' : '🎤'
                marker.style.left = `${this.x / canvas.width * 100}%`
                marker.style.top = `${this.y / canvas.height * 100}%`
                document.querySelector('.canvas-container').appendChild(marker)

                const devLabel = document.createElement('div')
                devLabel.textContent = this.id;
                devLabel.style.color = 'white'
                devLabel.style.fontSize = '12px'
                marker.appendChild(devLabel)
                return marker
            }

            updatePosition(x, y) {
                this.x = x
                this.y = y
                this.marker.style.left = `${x}px`
                this.marker.style.top = `${y}px`
            }

            remove() {
                this.marker.remove()
                this.panel.remove()
            }

            createControlPanel() {
                const panel = document.createElement('div')
                panel.className = 'device-item'

                // 添加设备名称
                const name = document.createElement('div')
                name.textContent = this.type === 'transmitter' ? '🔊发射器' : '🎤接收器'
                panel.appendChild(name)

                // 添加id
                const id = document.createElement('div')
                id.textContent = "ID: " + this.id
                panel.appendChild(id)

                // 添加坐标
                const pos = document.createElement('div')
                pos.textContent = `(${this.x.toFixed(0)}, ${this.y.toFixed(0)})`
                panel.appendChild(pos)

                return panel;
            }

            initializePanel() {

            }

            updatePanel() {

            }
        }

        class Transmitter extends Transceiver {
            constructor(x, y) {
                super('transmitter', x, y)
                this.frequency = 5
                this.amplitude = 10
                this.phase = 0
                this.enabled = true
                this.waveType = 'sine'
                this.audioBuffer = null
                this.audioPtr = 0
                this.sampleRate = 8000
            }

            applyEffect(buffer, tick) {
                if (!this.enabled) return
                if (this.waveType === 'audio') {
                    if (!this.audioBuffer) return
                    const idx = this.y * N + this.x;
                    buffer[idx] += this.audioBuffer.getChannelData(0)[this.audioPtr] * this.amplitude
                    this.audioPtr = (this.audioPtr + 1) % this.audioBuffer.length
                } else {
                    const idx = this.y * N + this.x;
                    const value = generateWave(this.waveType, this.frequency, this.phase, this.amplitude, tick / 60)
                    buffer[idx] += value
                }
            }

            initializePanel() {
                // 添加参数控制
                const paramDiv = document.createElement('div')
                paramDiv.className = 'param-div'

                const freqLabel = document.createElement('label')
                freqLabel.textContent = '频率:'
                paramDiv.appendChild(freqLabel)
                const freqInput = document.createElement('input')
                freqInput.type = 'number'
                freqInput.max = 15
                freqInput.min = 0.1
                freqInput.step = 0.1
                freqInput.value = this.frequency
                freqInput.addEventListener('change', () => this.frequency = parseFloat(freqInput.value))
                paramDiv.appendChild(freqInput)
                this.freqInput = freqInput

                const ampLabel = document.createElement('label')
                ampLabel.textContent = '振幅:'
                paramDiv.appendChild(ampLabel)
                const ampInput = document.createElement('input')
                ampInput.type = 'number'
                ampInput.max = 100
                ampInput.min = 0.1
                ampInput.step = 0.1
                ampInput.value = this.amplitude
                ampInput.addEventListener('change', () => this.amplitude = parseFloat(ampInput.value))
                paramDiv.appendChild(ampInput)
                this.ampInput = ampInput

                const phaseLabel = document.createElement('label')
                phaseLabel.textContent = '相位:'
                paramDiv.appendChild(phaseLabel)
                const phaseInput = document.createElement('input')
                phaseInput.type = 'number'
                phaseInput.max = 3.141
                phaseInput.min = -3.141
                phaseInput.step = 0.01
                phaseInput.value = this.phase
                phaseInput.addEventListener('change', () => this.phase = parseFloat(phaseInput.value))
                paramDiv.appendChild(phaseInput)
                this.phaseInput = phaseInput

                this.panel.appendChild(paramDiv)

                const waveTypeLabel = document.createElement('label')
                waveTypeLabel.textContent = '波形:'
                this.panel.appendChild(waveTypeLabel)
                const waveTypeSelect = document.createElement('select')
                waveTypeSelect.addEventListener('change', () => this.waveType = waveTypeSelect.value)
                const waveTypes = ['sine', 'square', 'sawtooth', 'triangle', 'noise']
                waveTypes.forEach(type => {
                    const option = document.createElement('option')
                    option.value = type
                    option.textContent = type
                    waveTypeSelect.appendChild(option)
                })
                waveTypeSelect.value = this.waveType
                waveTypeSelect.addEventListener('change', () => this.waveType = waveTypeSelect.value)
                this.panel.appendChild(waveTypeSelect)
                this.waveTypeSelect = waveTypeSelect

                // 添加音频上传
                this.playbackTime = document.createElement('div')
                this.panel.appendChild(this.playbackTime)

                this.slider = document.createElement('input')
                this.slider.type = 'range'
                this.slider.min = 0
                this.slider.max = 100
                this.slider.value = 0
                this.slider.addEventListener('input', e => {
                    this.audioPtr = Math.floor(this.audioBuffer.length * e.target.value / 100)
                })
                this.panel.appendChild(this.slider)

                this.panel.appendChild(document.createElement('br'))

                const sampleRateLabel = document.createElement('label')
                sampleRateLabel.textContent = '采样率:'
                this.panel.appendChild(sampleRateLabel)
                const sampleRateInput = document.createElement('input')
                sampleRateInput.type = 'number'
                sampleRateInput.max = 48000
                sampleRateInput.min = 1000
                sampleRateInput.value = 8000
                sampleRateInput.addEventListener('change', e => {
                    this.sampleRate = parseInt(e.target.value)
                })
                this.panel.appendChild(sampleRateInput)
                this.sampleRateInput = sampleRateInput


                const audioUpload = document.createElement('input')
                audioUpload.type = 'file'
                audioUpload.accept = 'audio/*'
                audioUpload.hidden = true
                audioUpload.addEventListener('change', e => {
                    const file = e.target.files[0]
                    if (file) {
                        const reader = new FileReader()
                        reader.onload = e => {
                            const audioCtx = new AudioContext({ sampleRate: this.sampleRate })
                            audioCtx.decodeAudioData(e.target.result).then(buffer => {
                                this.audioBuffer = buffer
                                this.waveType = 'audio'
                            })
                        }
                        reader.readAsArrayBuffer(file)
                    }
                })
                this.panel.appendChild(audioUpload)

                this.panel.appendChild(document.createElement('br'))


                const toggleBtn = document.createElement('button')
                toggleBtn.textContent = this.enabled ? '▶️' : '⏸️'
                toggleBtn.addEventListener('click', () => {
                    this.enabled = !this.enabled
                    toggleBtn.textContent = this.enabled ? '⏸️' : '▶️'
                })
                this.panel.appendChild(toggleBtn)

                const uploadBtn = document.createElement('button')
                uploadBtn.textContent = '🎵'
                uploadBtn.addEventListener('click', () => audioUpload.click())
                this.panel.appendChild(uploadBtn)

                // 添加删除按钮
                const removeBtn = document.createElement('button')
                removeBtn.textContent = '❌'
                removeBtn.addEventListener('click', () => removeDevice(this.id))
                this.panel.appendChild(removeBtn)
            }

            updatePanel() {
                this.freqInput.value = this.frequency
                this.ampInput.value = this.amplitude
                this.phaseInput.value = this.phase
                this.waveTypeSelect.value = this.waveType
                this.sampleRateInput.value = this.sampleRate
            }

            repaint() {
                if (this.audioBuffer) {
                    this.playbackTime.textContent = `播放进度: ${(this.audioPtr / this.sampleRate).toFixed(3)}s / ${(this.audioBuffer.length / this.sampleRate).toFixed(3)}s`
                    this.slider.value = this.audioPtr / this.audioBuffer.length * 100
                }
            }
        }

        class Receiver extends Transceiver {
            constructor(x, y) {
                super('receiver', x, y)
                this.sampleRate = 8000
                this.buffer = new Float32Array(4096)
                this.writePointer = 0
                this.lastSampleTime = 0
                this.paused = false
                this.maxBufferSize = 64 * 1024 * 1024 / Float32Array.BYTES_PER_ELEMENT;
            }

            recordSample(waveValue) {
                if (this.paused) return;
                if (this.writePointer >= this.maxBufferSize) return;
                else if (this.writePointer >= this.buffer.length) {
                    // 自动扩容
                    this.expandBuffer();
                }
                this.buffer[this.writePointer++] = waveValue;
            }

            expandBuffer() {
                const newBuffer = new Float32Array(this.buffer.length * 2);
                newBuffer.set(this.buffer)
                this.buffer = newBuffer;
                console.log('Buffer expanded to ' + this.buffer.length);
            }

            exportWAV() {
                const exportLength = this.writePointer;
                const wavBuffer = new ArrayBuffer(44 + exportLength * 4);
                const view = new DataView(wavBuffer);

                // WAV 头部
                writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + exportLength * 4, true);
                writeString(view, 8, 'WAVE');
                writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 3, true); // PCM float
                view.setUint16(22, 1, true);
                view.setUint32(24, this.sampleRate, true);
                view.setUint32(28, this.sampleRate * 4, true); // byte rate
                view.setUint16(32, 4, true); // block align
                view.setUint16(34, 32, true); // bits per sample
                writeString(view, 36, 'data');
                view.setUint32(40, exportLength * 4, true);

                // PCM数据 (float32)
                let offset = 44;
                for (let i = 0; i < exportLength; i++) {
                    view.setFloat32(offset, this.buffer[i], true);
                    offset += 4;
                }

                const blob = new Blob([view], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `recording_${this.id}.wav`;
                a.click();
            }

            setPaused(paused) {
                this.paused = paused
            }

            setSamplerate(sr) {
                this.sampleRate = sr;
            }

            initializePanel() {
                // 添加参数编辑
                const paramDiv = document.createElement('div')
                paramDiv.className = 'param-div';

                const srLabel = document.createElement('label');
                srLabel.innerText = '采样率：'
                paramDiv.appendChild(srLabel)

                const srInput = document.createElement('input')
                srInput.type = 'number'
                srInput.max = 48000;
                srInput.min = 1000;
                srInput.value = 8000;
                srInput.addEventListener('change', e => {
                    this.sampleRate = srInput.value;
                })
                paramDiv.appendChild(srInput);
                this.panel.appendChild(paramDiv)
                this.srInput = srInput

                // 添加已录时长显示
                const duration = document.createElement('div')
                this.panel.appendChild(duration)
                this.durationDisplay = duration

                // 添加波形显示
                const receiverCanvas = document.createElement('canvas');
                receiverCanvas.style.width = '150px'
                receiverCanvas.style.height = '112.5px'
                receiverCanvas.style.border = '1px solid #ffffff40'
                const receiverCtx = receiverCanvas.getContext('2d')
                receiverCtx.strokeStyle = 'white';
                this.panel.appendChild(receiverCanvas);
                this.receiverCtx = receiverCtx;
                this.receiverCanvas = receiverCanvas;

                const rmsDisplay = document.createElement('div');
                this.panel.appendChild(rmsDisplay);
                this.rmsDisplay = rmsDisplay;

                const resizeObserver = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        if (entry.target === receiverCanvas) {
                            receiverCanvas.width = receiverCanvas.clientWidth * window.devicePixelRatio;
                            receiverCanvas.height = receiverCanvas.clientHeight * window.devicePixelRatio;
                            receiverCtx.strokeStyle = 'white';
                        }
                    }
                });
                resizeObserver.observe(receiverCanvas)

                // 添加暂停按钮
                const toggleBtn = document.createElement('button')
                toggleBtn.textContent = '⏸️'
                toggleBtn.addEventListener('click', () => {
                    this.setPaused(toggleBtn.textContent === '⏸️')
                    toggleBtn.textContent = toggleBtn.textContent === '⏸️' ? '▶️' : '⏸️'
                })
                this.panel.appendChild(toggleBtn)

                const exportBtn = document.createElement('button')
                exportBtn.textContent = '📤'
                exportBtn.addEventListener('click', () => this.exportWAV())
                this.panel.appendChild(exportBtn)

                const eraseBtn = document.createElement('button')
                eraseBtn.textContent = '🧹'
                eraseBtn.addEventListener('click', () => this.erase())
                this.panel.appendChild(eraseBtn)

                // 添加删除按钮
                const removeBtn = document.createElement('button')
                removeBtn.textContent = '❌'
                removeBtn.addEventListener('click', () => removeDevice(this.id))
                this.panel.appendChild(removeBtn)
            }

            updatePanel() {
                this.srInput.value = this.sampleRate
            }

            repaint() {
                const durationSec = this.writePointer / this.sampleRate
                this.durationDisplay.textContent = `已录制: ${durationSec.toFixed(3)}s`

                let samples = this.buffer.slice(this.writePointer - 100, this.writePointer);

                let half = this.receiverCanvas.height / 2;
                let step = this.receiverCanvas.width / samples.length;

                this.receiverCtx.clearRect(0, 0, this.receiverCanvas.width, this.receiverCanvas.height)
                this.receiverCtx.beginPath()
                this.receiverCtx.moveTo(0, samples[0] * half + half)

                let rms = 0;
                for (let x = 0; x < samples.length; x++) {
                    let sample = samples[x]
                    this.receiverCtx.lineTo(x * step, sample * half + half)
                    rms += sample * sample;
                }
                rms /= samples.length;
                rms = Math.sqrt(rms);
                this.rmsDisplay.innerText = `RMS: ${(Math.log(rms) * 10).toFixed(1)} dB`
                this.receiverCtx.stroke();
            }

            erase() {
                this.buffer.fill(0)
                this.writePointer = 0
            }
        }
        
        class WavePacket {
    constructor(x,y,frequency, amplitude, phase, lifetime) {
    	this.x=Math.floor(x);
    	this.y=Math.floor(y);
        this.frequency = frequency;  // 波包频率（Hz）
        this.amplitude = amplitude;  // 最大振幅
        this.phase = phase;          // 初始相位（弧度）
        this.lifetime = lifetime;    // 波包持续时间（单位：采样点数）
        this.tick = -1;              // 当前采样点计数器（从0开始）
        this.sampleRate = 60;        // 采样率（每秒采样数）
    }
    
    applyEffect(buffer) {
                    const idx = this.y * N + this.x;
                    buffer[idx] += this.getSample();
            }
    
    getSample() {
        this.tick++; // 每次获取样本时推进计数器
        return 0;    // 基类默认返回0，由子类覆盖实现
    }
}

class GaussianWavePacket extends WavePacket {
    getSample() {
        super.getSample(); // 调用父类方法推进tick计数器

        // 超出生命周期后返回0（防止无限生成）
        if (this.tick >= this.lifetime) return 0;

        // 高斯包络计算（以波包中心为对称点）
        const center = this.lifetime * 0.5; // 波包中心位置（采样点数）
        const delta = this.tick - center;    // 当前点与中心的偏移量
        
        // 高斯宽度控制（σ设为生命周期长度的20%）
        const sigma = this.lifetime * 0.2; 
        const exponent = -(delta ** 2) / (2 * sigma ** 2);
        const envelope = this.amplitude * Math.exp(exponent);

        // 载波信号计算（考虑采样率转换为实际时间）
        const time = this.tick / this.sampleRate; // 当前时间（秒）
        const phase = 2 * Math.PI * this.frequency * time + this.phase;
        
        return envelope * Math.cos(phase);
    }
}

// 矩形波包（矩形窗+余弦载波）
class RectangularWavePacket extends WavePacket {
    getSample() {
        super.getSample();
        
        // 超出生命周期返回0
        if (this.tick >= this.lifetime) return 0;

        // 矩形包络：在生命周期内保持恒定振幅
        const envelope = (this.tick >= 0 && this.tick < this.lifetime) 
            ? this.amplitude 
            : 0;

        // 载波信号计算
        const time = this.tick / this.sampleRate;
        const phase = 2 * Math.PI * this.frequency * time + this.phase;
        
        return envelope * Math.cos(phase);
    }
}

// Sinc波包（sinc函数包络+余弦载波）
class SincWavePacket extends WavePacket {
    getSample() {
        super.getSample();
        
        // 超出生命周期返回0
        if (this.tick >= this.lifetime) return 0;

        // 计算中心对称时间轴
        const center = this.lifetime / 2;
        const delta = (this.tick - center) / this.sampleRate; // 转换为秒
        
        // 避免除以零的sinc计算
        let sinc;
        if (delta === 0) {
            sinc = 1; // sinc(0) = 1
        } else {
            const omega = Math.PI * 2 * this.frequency; // 控制主瓣宽度
            sinc = Math.sin(omega * delta) / (omega * delta);
        }

        // 包络振幅与载波合成
        const envelope = this.amplitude * sinc;
        const phase = 2 * Math.PI * this.frequency * (this.tick / this.sampleRate) + this.phase;
        
        return envelope * Math.cos(phase);
    }
}



        const materialDefs = [
            {},
            { // 墙体
                'name': '墙壁',
                'color': [200, 50, 50],
                'damping': 1.0,
                'waveSpeed': 0.625
            },
            { // 透镜
                'name': '透镜',
                'color': [50, 100, 100],
                'damping': 0.0,
                'waveSpeed': 0.25,
            },
            { // 透镜
                'name': '海绵',
                'color': [226, 210, 74],
                'damping': 0.1,
                'waveSpeed': 0.625,
            }
        ]


        // 初始化参数
        const N = 512;           // 网格尺寸
        let airDamping = 0.005;   // 阻尼系数
        const waveSpeed = 0.625;   // 波速

        // 获取Canvas上下文
        const canvas = document.getElementById('waveCanvas');
        const ctx = canvas.getContext('2d');

        // 设置Canvas尺寸
        canvas.width = N;
        canvas.height = N;

        // 初始化波场和障碍物
        let buffers = [
            new Float32Array(N * N),
            new Float32Array(N * N),
            new Float32Array(N * N)
        ];
        let obstacles = new Uint8Array(N * N); // 障碍物标记
        let current = 0;
        let tick = 0;

        // 创建ImageData用于快速绘制
        const imageData = ctx.createImageData(N, N);
        const data = imageData.data;

        // 交互相关变量
        let mousePos = null;
        let isDrawing = false;
        let currentMode = 'wave'; // wave/obstacle/erase/trans/recv
        let brushSize = 3;
        let renderMode = 'normal';

        // 添加发射器
        let transceivers = new Set();
        let wavePackets = new Set();

        // 获取UI元素
        const frequency = document.getElementById('frequency');
        const amplitude = document.getElementById('amplitude');
        const brushSizeInput = document.getElementById('brushSize');
        const dampingInput = document.getElementById('damping');
        const waveType = document.getElementById('waveType');
        const deviceList = document.getElementById('deviceList')
        const materialSelect = document.getElementById('material')

        // 初始化材料选择
        materialDefs.forEach((material, idx) => {
            if (idx === 0) return;
            const materialButton = document.createElement('button')
            materialButton.style.backgroundColor = `rgb(${material.color.join(',')})`
            materialButton.appendChild(document.createTextNode(material.name || `材料${idx}`))
            materialButton.addEventListener('click', () => {
                materialSelect.value = idx
                // set selected
                document.querySelectorAll('#material button').forEach(b => b.classList.remove('selected'))
                materialButton.classList.add('selected')
            })

            // 检测元素亮度设置文字是黑还是白
            const brightness = (material.color[0] * 299 + material.color[1] * 587 + material.color[2] * 114) / 1000;
            materialButton.style.color = brightness > 125 ? 'black' : 'white';

            materialSelect.appendChild(materialButton)
        })
        // 设置第一个按钮为已选择
        materialSelect.value = 1
        materialSelect.children[0].classList.add('selected')

        // 模式切换按钮
        document.querySelectorAll('.toggle').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentMode = btn.id.replace('btn', '').toLowerCase();
            });
        });

        // 阻尼系数控制
        dampingInput.addEventListener('change', () => {
            airDamping = parseFloat(dampingInput.value);
        });

        // 笔刷大小控制
        brushSizeInput.addEventListener('input', () => {
            brushSize = parseInt(brushSizeInput.value);
            document.getElementById('brushSizeValue').textContent = brushSize;
        });

        // 波动方程更新
        function updateWave() {
            const prev = (current + 2) % 3;
            const curr = current;
            const next = (current + 1) % 3;

            // 修改后的拉普拉斯算子计算（包含对角线项）
            for (let y = 1; y < N - 1; y++) {
                for (let x = 1; x < N - 1; x++) {
                    const idx = y * N + x;
                    const waveSpeedF = materialDefs[obstacles[idx]]?.waveSpeed || waveSpeed;

                    // 标准拉普拉斯项
                    const laplacian =
                        buffers[curr][idx - 1] +
                        buffers[curr][idx + 1] +
                        buffers[curr][idx - N] +
                        buffers[curr][idx + N] -
                        4 * buffers[curr][idx];

                    // 新增对角线项（各向同性修正）
                    const diagLaplacian =
                        buffers[curr][idx - N - 1] +
                        buffers[curr][idx - N + 1] +
                        buffers[curr][idx + N - 1] +
                        buffers[curr][idx + N + 1] -
                        4 * buffers[curr][idx];

                    // 混合拉普拉斯算子
                    const blendedLaplacian = 0.8 * laplacian + 0.2 * diagLaplacian;

                    // 修改后的更新方程
                    buffers[next][idx] = (
                        buffers[curr][idx] * 2 -
                        buffers[prev][idx] + blendedLaplacian * waveSpeedF
                    ) * (1 - airDamping);

                    if (obstacles[idx]) {
                        buffers[next][idx] *= (1 - materialDefs[obstacles[idx]].damping);
                        continue;
                    }
                }
            }

            transceivers.forEach(dev => {
                if (dev instanceof Transmitter) {
                    dev.applyEffect(buffers[current], tick)
                } else if (dev instanceof Receiver) {
                    const idx = dev.y * N + dev.x;
                    dev.recordSample(buffers[current][idx])
                }
            })
            
            wavePackets.forEach(packet=>{
            	packet.applyEffect(buffers[current])
            	//if (this.tick >= this.lifetime) 
            })

            tick++;
            current = next;
        }

        // 渲染函数
        function render() {
            switch (renderMode) {
                case 'water':
                    renderWater()
                    break;
                default:
                    renderNormal();
                    break;
            }
        }

        function renderNormal() {
            for (let i = 0; i < N * N; i++) {
                const idx = i << 2;

                const val = clamp(Math.sqrt(Math.abs(buffers[current][i])), 0, 1) * 255;
                if (buffers[current][i] > 0) {
                    data[idx] = val;    // R
                    data[idx + 1] = val * 0.5;  // G
                    data[idx + 2] = 0;  // B
                } else {
                    data[idx] = 0;    // R
                    data[idx + 1] = val * 0.5;  // G
                    data[idx + 2] = val;  // B
                }

                if (obstacles[i]) {
                    let material = materialDefs[obstacles[i]];
                    data[idx] += material.color[0];    // R
                    data[idx + 1] += material.color[1];   // G
                    data[idx + 2] += material.color[2];   // B
                }

                data[idx + 3] = 255;      // A
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function renderWater() {
            // 基础水蓝色
            const baseR = 0x13, baseG = 0x99, baseB = 0xde;
            // 光照方向：45°（单位向量）
            const lightAngle = Math.PI / 4;
            const Lx = Math.cos(lightAngle);
            const Ly = Math.sin(lightAngle);
            // 调节亮度变化的系数，根据实际波动幅度调整
            const shadingCoefficient = 1;

            // 对每个像素计算渲染颜色
            for (let y = 0; y < N; y++) {
                for (let x = 0; x < N; x++) {
                    const i = y * N + x;

                    if (obstacles[i]) {
                        let material = materialDefs[obstacles[i]];
                        const idx = i << 2;
                        data[idx] = material.color[0];    // R
                        data[idx + 1] = material.color[1];   // G
                        data[idx + 2] = material.color[2];   // B
                        data[idx + 3] = 255;  // 不透明
                    } else {
                        let dx = 0, dy = 0;

                        // 对内部像素使用中央差分（边界上简单取0梯度）
                        if (x > 0 && x < N - 1) {
                            dx = (buffers[current][i + 1] - buffers[current][i - 1]) * 0.5;
                        }
                        if (y > 0 && y < N - 1) {
                            dy = (buffers[current][i + N] - buffers[current][i - N]) * 0.5;
                        }
                        // 梯度模长
                        const gradMag = Math.sqrt(dx * dx + dy * dy);

                        // 计算亮度系数
                        let brightnessFactor = 1; // 默认无梯度时系数为1
                        if (gradMag > 0) {
                            // 计算梯度向量与光方向的余弦值
                            const cosAngle = (dx * Lx + dy * Ly) / gradMag;
                            brightnessFactor = 1 + shadingCoefficient * gradMag * cosAngle;
                        }

                        // 根据亮度系数调整基础色
                        const R = clamp(Math.floor(baseR * brightnessFactor), 0, 255);
                        const G = clamp(Math.floor(baseG * brightnessFactor), 0, 255);
                        const B = clamp(Math.floor(baseB * brightnessFactor), 0, 255);

                        // 写入 imageData 数组
                        const idx = (i << 2);
                        data[idx] = R;        // R通道
                        data[idx + 1] = G;    // G通道
                        data[idx + 2] = B;    // B通道
                        data[idx + 3] = 255;  // 不透明

                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }


        // 添加障碍物/擦除
        function modifyObstacles(x, y, isAdd) {
            const r = brushSize;
            for (let xx = -r; xx <= r; xx++) {
                for (let yy = -r; yy <= r; yy++) {
                    const nx = x + xx;
                    const ny = y + yy;
                    if (nx < 0 || nx >= N || ny < 0 || ny >= N) continue;
                    const idx = ny * N + nx;
                    obstacles[idx] = isAdd ? materialSelect.value : 0;
                }
            }
        }

        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        canvas.addEventListener('click', (e) => {
        	    const rect = canvas.getBoundingClientRect()
            const x = (e.clientX - rect.left) * (N / rect.width)
            const y = (e.clientY - rect.top) * (N / rect.height)
            
            switch (currentMode){
            	case "trans":
            	case "recv":
        
            const dev = currentMode === 'trans'
                ? new Transmitter(x, y)
                : new Receiver(x, y)

            transceivers.add(dev)
            deviceList.appendChild(dev.panel)
            updateDeviceList()
            currentMode = '';
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        
            break;
            case "packet":
            const type=document.getElementById("wavePackets").value
            
            switch (type){
            	case "gauss":
            	wavePackets.add(new GaussianWavePacket(x,y,frequency.value, amplitude.value, 0, 60));
            	break;
            		case "rect":
            	wavePackets.add(new RectangularWavePacket(x,y,frequency.value, amplitude.value, 0, 60));
            	break
            		case "sinc":
            	wavePackets.add(new SincWavePacket(x,y,frequency.value, amplitude.value, 0, 60));
            	break
            }
            }

            })

        function updateDeviceList() {
            transceivers.forEach(dev => dev.updatePanel())
        }


        function removeDevice(id) {
            for (const dev of transceivers) {
                if (dev.id === id) {
                    dev.remove();
                    transceivers.delete(dev)
                    updateDeviceList()
                    return
                }
            }
        }

        // 导入障碍图
        // 添加图像处理函数
        function handleImageUpload(file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                const img = new Image();
                img.onload = function () {
                    processImage(img);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function processImage(img) {
            // 创建临时Canvas进行预处理
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            // 设置尺寸为512x512
            tempCanvas.width = N;
            tempCanvas.height = N;

            // 绘制并缩放图像
            tempCtx.drawImage(img, 0, 0, N, N);

            // 获取图像数据
            const imageData = tempCtx.getImageData(0, 0, N, N);
            const pixels = imageData.data;

            // 二值化处理并更新障碍物
            for (let i = 0; i < N * N; i++) {
                const r = pixels[i * 4];
                const g = pixels[i * 4 + 1];
                const b = pixels[i * 4 + 2];

                // 计算亮度（YUV/YIQ模型）
                const brightness = r * 0.299 + g * 0.587 + b * 0.114;
                obstacles[i] = brightness > 128 ? 0 : 1; // 阈值128
            }

            // 触发重绘
            render();
        }

        function clear() {
            for (const buffer of buffers) {
                buffer.fill(0);
            }
            obstacles.fill(0);
            for (const dev of transceivers) {
                removeDevice(dev.id)
            }
        }

        document.getElementById('btnStop').addEventListener('click', () => {
            for (const buffer of buffers) {
                buffer.fill(0);
            }
        });

        document.getElementById('btnClear').addEventListener('click', clear);

        // 绑定文件输入事件
        document.getElementById('importImage').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleImageUpload(file);
        });

        // 辅助函数
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i))
            }
        }

        // 生成波形

        /** * 生成波形
            * @param {string} type 波形类型
            * @param {number} f 频率
            * @param {number} p 相位
            * @param {number} a 振幅
            * @param {number} t 时间
            * @returns {number} 波形值
         */
        function generateWave(type, f, p, a, t) {
            switch (type) {
                case 'sine':
                    return Math.sin(2 * Math.PI * f * t + p) * a;
                case 'square':
                    return Math.sign(Math.sin(2 * Math.PI * f * t + p)) * a;
                case 'sawtooth':
                    return (2 * (f * t + p) % 2 - 1) * a;
                case 'triangle':
                    return Math.abs((2 * (f * t + p) % 2 - 1)) * a;
                case 'noise':
                    return (Math.random() * 2 - 1) * a;
            }
        }


        // 事件处理
        function updateMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / canvas.offsetWidth;
            const scaleY = canvas.height / canvas.offsetHeight;
            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);
            mousePos = [x, y];
        }

        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            updateMousePos(e);
        });

        canvas.addEventListener('mousemove', (e) => {
            updateMousePos(e);
            if (!isDrawing) return;
        });

        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseleave', () => isDrawing = false);

        // 触摸事件处理
        canvas.addEventListener('touchstart', (e) => {
            // e.preventDefault();
            isDrawing = true;
            updateMousePos(e.touches[0]);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            updateMousePos(e.touches[0]);
            if (!isDrawing) return;

        }, { passive: false });

        canvas.addEventListener('touchend', () => isDrawing = false);

        const renderSelect = document.getElementById('renderMode');

        renderSelect.addEventListener('change', e => {
            renderMode = renderSelect.value;
        })

        // 波动激励
        function addDisturbance(x, y) {
            if (x < 0 || x >= N || y < 0 || y >= N) return;
            const idx = y * N + x;
            const t = tick / 60;
            buffers[current][idx] += generateWave(waveType.value, frequency.value, 0, amplitude.value, t) //Math.sin(2 * Math.PI * frequency.value * t) * amplitude.value;
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            if (isDrawing) touch();
            updateWave();
            render();
            for (const dev of transceivers) {
                dev.repaint()
            }
        }

        function touch() {
            if (currentMode === 'wave') {
                addDisturbance(mousePos[0], mousePos[1]);
            } else {
                modifyObstacles(mousePos[0], mousePos[1], currentMode === 'obstacle');
            }
        }
        animate();

        function acquireWakelock() {
            if ('wakeLock' in navigator) {
                try {
                    navigator.wakeLock.request('screen').then(lock => {
                        lock.addEventListener('release', e => {
                            console.log("wakelock released");
                        })
                    });
                } catch (error) {
                    console.error(error);
                }
            }
        }

        document.addEventListener("visibilitychange", function () {
            if (document.visibilityState === 'visible') {
                acquireWakelock();
            }
        });

    </script>
</body>

</html>