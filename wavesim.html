<!DOCTYPE html>
<html>

<head>
    <title>æ³¢åŠ¨æ¨¡æ‹Ÿç©å…·</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        #waveCanvas {
            cursor: crosshair;
            width: 100vh;
            height: auto;
        }

        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #1a1a1a;
            color: white;
            max-width: 75%;
            margin: auto;
        }

        .main {

            display: flex;
            align-items: center;
        }

        .tools {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-left: 16px;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-direction: column;
        }

        .parameters {
            display: flex;
            flex-direction: column;
        }

        .param-div {
            display: flex;
            flex-direction: column;
        }

        button {
            padding: 8px;
            cursor: pointer;
            background: #333;
            border: 1px solid #666;
            color: white;
        }

        button.active {
            background: #4CAF50;
            border-color: #45a049;
        }

        .canvas-container {
            position: relative;
            margin: 10px;
        }

        .transceiver-marker {
            position: absolute;
            pointer-events: none;
            font-size: 24px;
            transform: translate(-50%, -50%);
        }

        #deviceList {
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
            border: 1px solid #444;
            display: flex;
            flex-wrap: wrap;
        }

        .device-item {
            margin: 5px;
            padding: 8px;
            background: #222;
        }

        @media (max-width: 700px) {
            canvas {
                width: 100%;
            }

            body {
                max-width: 90%;
                flex-direction: column;
            }

            .controls {
                flex-direction: row;
            }
        }
    </style>
</head>

<body>
    <div class="main">
        <div class="canvas-container">
            <canvas id="waveCanvas"></canvas>
        </div>


        <div class="tools">
            <div class="controls">
                <button id="btnWave" class="active">ğŸŒŠ æ³¢åŠ¨æ¨¡å¼</button>
                <button id="btnObstacle">ğŸ§± ç»˜åˆ¶éšœç¢</button>
                <button id="btnErase">ğŸ§¹ æ“¦é™¤éšœç¢</button>
            </div>

            <div class="parameters">
                é˜»å°¼ï¼š<input type="number" id="damping" min="0" max="0.1" step="0.001" value="0.005">
                æŒ¯å¹…ï¼š<input type="number" id="amplitude" min="0.01" max="100" step="0.1" value="10">
                é¢‘ç‡ï¼š<input type="number" id="frequency" min="0" max="15" step="0.1" value="5">
                ç¬”åˆ·å¤§å°ï¼š<input type="range" id="brushSize" min="1" max="20" value="3"> <span id="brushSizeValue">3</span>
            </div>

            <div>
                <button id="btnTrans">â• æ·»åŠ å‘å°„å™¨</button>
                <button id="btnRecv">â• æ·»åŠ æ¥æ”¶å™¨</button>
            </div>
        </div>
    </div>
    <div id="deviceList"></div>

    <script>
        class Transceiver {
            static idCounter = 0

            constructor(type, x, y) {
                this.id = `dev_${Transceiver.idCounter++}`
                this.type = type
                this.x = Math.round(x)
                this.y = Math.round(y)
                this.marker = this.createMarker()
            }

            createMarker() {
                const marker = document.createElement('span')
                marker.className = 'transceiver-marker'
                marker.textContent = this.type === 'transmitter' ? 'ğŸ“¡' : 'ğŸ“»'
                marker.style.left = `${this.x / canvas.width * 100}%`
                marker.style.top = `${this.y / canvas.height * 100}%`
                document.querySelector('.canvas-container').appendChild(marker)
                return marker
            }

            updatePosition(x, y) {
                this.x = x
                this.y = y
                this.marker.style.left = `${x}px`
                this.marker.style.top = `${y}px`
            }

            remove() {
                this.marker.remove()
            }
        }

        class Transmitter extends Transceiver {
            constructor(x, y) {
                super('transmitter', x, y)
                this.frequency = 5
                this.amplitude = 10
                this.phase = 0
                this.enabled = true
            }

            applyEffect(buffer, tick) {
                if (!this.enabled) return
                const idx = this.y * N + this.x;
                const value = Math.sin(2 * Math.PI * this.frequency * (tick / 60) + this.phase) * this.amplitude
                buffer[idx] += value
            }
        }

        class Receiver extends Transceiver {
            constructor(x, y) {
                super('receiver', x, y)
                this.sampleRate = 3600
                this.buffer = new Float32Array(65536)
                this.writePointer = 0
                this.lastSampleTime = 0
                this.paused = false
            }

            recordSample(waveValue) {
                if (this.paused) return
                if (this.writePointer >= this.buffer.length) return
                this.buffer[this.writePointer++] = waveValue
            }

            exportWAV() {
                const exportLength = this.writePointer;
                const wavBuffer = new ArrayBuffer(44 + exportLength * 4);
                const view = new DataView(wavBuffer);

                // WAV å¤´éƒ¨
                writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + exportLength * 4, true);
                writeString(view, 8, 'WAVE');
                writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 3, true); // PCM float
                view.setUint16(22, 1, true);
                view.setUint32(24, this.sampleRate, true);
                view.setUint32(28, this.sampleRate * 4, true); // byte rate
                view.setUint16(32, 4, true); // block align
                view.setUint16(34, 32, true); // bits per sample
                writeString(view, 36, 'data');
                view.setUint32(40, exportLength * 4, true);

                // PCMæ•°æ® (float32)
                let offset = 44;
                for (let i = 0; i < exportLength; i++) {
                    view.setFloat32(offset, this.buffer[i], true);
                    offset += 4;
                }

                const blob = new Blob([view], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `recording_${this.id}.wav`;
                a.click();
            }

            setPaused(paused) {
                this.paused = paused
            }

            setSamplerate(sr) {
                this.sampleRate = sr;
            }
        }


        // åˆå§‹åŒ–å‚æ•°
        const N = 512;           // ç½‘æ ¼å°ºå¯¸
        const cellSize = 1;      // åƒç´ å¤§å°
        let damping = 0.005;   // é˜»å°¼ç³»æ•°
        const waveSpeed = 0.5;   // æ³¢é€Ÿ

        // è·å–Canvasä¸Šä¸‹æ–‡
        const canvas = document.getElementById('waveCanvas');
        const ctx = canvas.getContext('2d');

        // è®¾ç½®Canvaså°ºå¯¸
        canvas.width = N;
        canvas.height = N;

        // åˆå§‹åŒ–æ³¢åœºå’Œéšœç¢ç‰©
        let buffers = [
            new Float32Array(N * N),
            new Float32Array(N * N),
            new Float32Array(N * N)
        ];
        let obstacles = new Uint8Array(N * N); // éšœç¢ç‰©æ ‡è®°
        let current = 0;
        let tick = 0;

        // åˆ›å»ºImageDataç”¨äºå¿«é€Ÿç»˜åˆ¶
        const imageData = ctx.createImageData(N, N);
        const data = imageData.data;

        // äº¤äº’ç›¸å…³å˜é‡
        let mousePos = null;
        let isDrawing = false;
        let currentMode = 'wave'; // wave/obstacle/erase/trans/recv
        let brushSize = 3;

        // æ·»åŠ å‘å°„å™¨
        let transceivers = []

        // è·å–UIå…ƒç´ 
        const frequency = document.getElementById('frequency');
        const amplitude = document.getElementById('amplitude');
        const brushSizeInput = document.getElementById('brushSize');
        const dampingInput = document.getElementById('damping');

        // æ¨¡å¼åˆ‡æ¢æŒ‰é’®
        document.querySelectorAll('button').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentMode = btn.id.replace('btn', '').toLowerCase();
            });
        });

        // é˜»å°¼ç³»æ•°æ§åˆ¶
        dampingInput.addEventListener('change', () => {
            damping = parseFloat(dampingInput.value);
        });

        // ç¬”åˆ·å¤§å°æ§åˆ¶
        brushSizeInput.addEventListener('input', () => {
            brushSize = parseInt(brushSizeInput.value);
            document.getElementById('brushSizeValue').textContent = brushSize;
        });

        // æ³¢åŠ¨æ–¹ç¨‹æ›´æ–°
        function updateWave() {
            const prev = (current + 2) % 3;
            const curr = current;
            const next = (current + 1) % 3;

            // æ¸…é™¤éšœç¢ç‰©ä½ç½®çš„æ³¢åŠ¨
            for (let i = 0; i < N * N; i++) {
                if (obstacles[i]) buffers[prev][i] = buffers[curr][i] = buffers[next][i] = 0;
            }

            // ä¿®æ”¹åçš„æ‹‰æ™®æ‹‰æ–¯ç®—å­è®¡ç®—ï¼ˆåŒ…å«å¯¹è§’çº¿é¡¹ï¼‰
            for (let y = 1; y < N - 1; y++) {
                for (let x = 1; x < N - 1; x++) {
                    const idx = y * N + x;
                    if (obstacles[idx]) continue;

                    // æ ‡å‡†æ‹‰æ™®æ‹‰æ–¯é¡¹
                    const laplacian =
                        buffers[curr][idx - 1] +
                        buffers[curr][idx + 1] +
                        buffers[curr][idx - N] +
                        buffers[curr][idx + N] -
                        4 * buffers[curr][idx];

                    // æ–°å¢å¯¹è§’çº¿é¡¹ï¼ˆå„å‘åŒæ€§ä¿®æ­£ï¼‰
                    const diagLaplacian =
                        buffers[curr][idx - N - 1] +
                        buffers[curr][idx - N + 1] +
                        buffers[curr][idx + N - 1] +
                        buffers[curr][idx + N + 1] -
                        4 * buffers[curr][idx];

                    // æ··åˆæ‹‰æ™®æ‹‰æ–¯ç®—å­
                    const blendedLaplacian = 0.8 * laplacian + 0.2 * diagLaplacian;

                    // ä¿®æ”¹åçš„æ›´æ–°æ–¹ç¨‹
                    buffers[next][idx] = (
                        buffers[curr][idx] * 2 -
                        buffers[prev][idx] + blendedLaplacian * waveSpeed
                    ) * (1 - damping);
                }
            }

            transceivers.forEach(dev => {
                if (dev instanceof Transmitter) {
                    dev.applyEffect(buffers[current], tick)
                } else if (dev instanceof Receiver) {
                    const idx = dev.y * N + dev.x;
                    dev.recordSample(buffers[current][idx])
                }
            })

            tick++;
            current = next;
        }

        // æ¸²æŸ“å‡½æ•°
        function render() {
            for (let i = 0; i < N * N; i++) {
                const idx = i * 4;
                if (obstacles[i]) {
                    data[idx] = 200;    // R
                    data[idx + 1] = 50;   // G
                    data[idx + 2] = 50;   // B
                } else {
                    const val = Math.min(Math.abs(buffers[current][i]) * 255, 255);
                    if (buffers[current][i] > 0) {
                        data[idx] = val;    // R
                        data[idx + 1] = val / 2;  // G
                        data[idx + 2] = 0;  // B
                    } else {

                        data[idx] = 0;    // R
                        data[idx + 1] = val / 2;  // G
                        data[idx + 2] = val;  // B
                    }
                }
                data[idx + 3] = 255;      // A
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // æ·»åŠ éšœç¢ç‰©/æ“¦é™¤
        function modifyObstacles(x, y, isAdd) {
            const r = brushSize;
            for (let xx = -r; xx <= r; xx++) {
                for (let yy = -r; yy <= r; yy++) {
                    const nx = x + xx;
                    const ny = y + yy;
                    if (nx < 0 || nx >= N || ny < 0 || ny >= N) continue;
                    const idx = ny * N + nx;
                    obstacles[idx] = isAdd ? 1 : 0;
                }
            }
        }


        canvas.addEventListener('click', (e) => {
            if (currentMode != 'trans' && currentMode != 'recv') return

            const rect = canvas.getBoundingClientRect()
            const x = (e.clientX - rect.left) * (N / rect.width)
            const y = (e.clientY - rect.top) * (N / rect.height)

            const dev = currentMode === 'trans'
                ? new Transmitter(x, y)
                : new Receiver(x, y)

            transceivers.push(dev)
            updateDeviceList()
            currentMode = '';

            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        })


        function updateDeviceList() {
            const list = document.getElementById('deviceList')
            list.innerHTML = '';
            transceivers.forEach(dev => {
                const item = document.createElement('div')
                item.className = 'device-item'

                // æ·»åŠ è®¾å¤‡åç§°
                const name = document.createElement('div')
                name.textContent = dev.type === 'transmitter' ? 'å‘å°„å™¨' : 'æ¥æ”¶å™¨'
                item.appendChild(name)

                // æ·»åŠ id
                const id = document.createElement('div')
                id.textContent = "ID: " + dev.id
                item.appendChild(id)

                // æ·»åŠ åæ ‡
                const pos = document.createElement('div')
                pos.textContent = `(${dev.x.toFixed(0)}, ${dev.y.toFixed(0)})`
                item.appendChild(pos)

                // æ·»åŠ åŠŸèƒ½
                if (dev instanceof Transmitter) {

                    // æ·»åŠ å‚æ•°æ§åˆ¶
                    const paramDiv = document.createElement('div')
                    paramDiv.className = 'param-div'

                    const freqLabel = document.createElement('label')
                    freqLabel.textContent = 'é¢‘ç‡:'
                    paramDiv.appendChild(freqLabel)
                    const freqInput = document.createElement('input')
                    freqInput.type = 'number'
                    freqInput.max = 15
                    freqInput.min = 0.1
                    freqInput.step = 0.1
                    freqInput.value = dev.frequency
                    freqInput.addEventListener('change', () => dev.frequency = parseFloat(freqInput.value))
                    paramDiv.appendChild(freqInput)

                    const ampLabel = document.createElement('label')
                    ampLabel.textContent = 'æŒ¯å¹…:'
                    paramDiv.appendChild(ampLabel)
                    const ampInput = document.createElement('input')
                    ampInput.type = 'number'
                    ampInput.max = 100
                    ampInput.min = 0.1
                    ampInput.step = 0.1
                    ampInput.value = dev.amplitude
                    ampInput.addEventListener('change', () => dev.amplitude = parseFloat(ampInput.value))
                    paramDiv.appendChild(ampInput)

                    const phaseLabel = document.createElement('label')
                    phaseLabel.textContent = 'ç›¸ä½:'
                    paramDiv.appendChild(phaseLabel)
                    const phaseInput = document.createElement('input')
                    phaseInput.type = 'number'
                    ampInput.max = 3.141
                    ampInput.min = 0
                    ampInput.step = 0.01
                    phaseInput.value = dev.phase
                    phaseInput.addEventListener('change', () => dev.phase = parseFloat(phaseInput.value))
                    paramDiv.appendChild(phaseInput)

                    item.appendChild(paramDiv)


                    const toggleBtn = document.createElement('button')
                    toggleBtn.textContent = dev.enabled ? 'æš‚åœ' : 'æ’­æ”¾'
                    toggleBtn.addEventListener('click', () => {
                        dev.enabled = !dev.enabled
                        toggleBtn.textContent = dev.enabled ? 'æš‚åœ' : 'æ’­æ”¾'
                    })
                    item.appendChild(toggleBtn)
                } else
                    if (dev instanceof Receiver) {
                        // æ·»åŠ å·²å½•æ—¶é•¿æ˜¾ç¤º
                        const duration = document.createElement('div')
                        item.appendChild(duration)

                        // æ·»åŠ å‚æ•°ç¼–è¾‘
                        const paramDiv = document.createElement('div')
                        paramDiv.className = 'param-div';

                        const srLabel = document.createElement('label');
                        srLabel.innerText = 'é‡‡æ ·ç‡ï¼š'
                        paramDiv.appendChild(srLabel)

                        const srInput = document.createElement('input')
                        srInput.max = 48000;
                        srInput.min = 1000;
                        srInput.value = 3600;
                        srInput.addEventListener('change', e => {
                            dev.sampleRate = srInput.value;
                        })
                        paramDiv.appendChild(srInput);
                        item.appendChild(paramDiv)

                        const receiverCanvas = document.createElement('canvas');
                        receiverCanvas.width = 100;
                        receiverCanvas.height = 75;
                        const receiverCtx = receiverCanvas.getContext('2d')
                        receiverCtx.strokeStyle = 'white';
                        item.appendChild(receiverCanvas);

                        const rmsDisplay = document.createElement('div');
                        item.appendChild(rmsDisplay);

                        // æ·»åŠ æš‚åœæŒ‰é’®
                        const toggleBtn = document.createElement('button')
                        toggleBtn.textContent = 'æš‚åœ'
                        toggleBtn.addEventListener('click', () => {
                            dev.setPaused(toggleBtn.textContent === 'æš‚åœ')
                            toggleBtn.textContent = toggleBtn.textContent === 'æš‚åœ' ? 'ç»§ç»­' : 'æš‚åœ'
                        })
                        item.appendChild(toggleBtn)

                        const exportBtn = document.createElement('button')
                        exportBtn.textContent = 'å¯¼å‡ºå½•éŸ³'
                        exportBtn.addEventListener('click', () => dev.exportWAV())
                        item.appendChild(exportBtn)


                        setInterval(() => {
                            const durationSec = dev.writePointer / dev.sampleRate
                            duration.textContent = `å·²å½•åˆ¶: ${durationSec.toFixed(2)}s`

                            let samples = dev.buffer.slice(dev.writePointer - 100, dev.writePointer);

                            receiverCtx.clearRect(0, 0, receiverCanvas.width, receiverCanvas.height)
                            receiverCtx.beginPath()
                            receiverCtx.moveTo(0, 37.5)

                            let rms = 0;
                            for (let x = 0; x < samples.length; x++) {
                                let sample = samples[x]
                                receiverCtx.lineTo(x, sample * 37.5 + 37.5)
                                rms += sample * sample;
                            }
                            rms /= samples.length;
                            rms = Math.sqrt(rms);
                            rmsDisplay.innerText = `RMS: ${(Math.log(rms) * 10).toFixed(1)} dB`
                            receiverCtx.stroke();
                        }, 1000)
                    }

                // æ·»åŠ åˆ é™¤æŒ‰é’®
                const removeBtn = document.createElement('button')
                removeBtn.textContent = 'âŒ'
                removeBtn.addEventListener('click', () => removeDevice(dev.id))
                item.appendChild(removeBtn)

                list.appendChild(item)
            })
        }


        function removeDevice(id) {
            const index = transceivers.findIndex(d => d.id === id)
            transceivers[index].remove()
            transceivers.splice(index, 1)
            updateDeviceList()
        }

        // è¾…åŠ©å‡½æ•°
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i))
            }
        }


        // äº‹ä»¶å¤„ç†
        function updateMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / canvas.offsetWidth;
            const scaleY = canvas.height / canvas.offsetHeight;
            const x = Math.floor((e.clientX - rect.left) * scaleX);
            const y = Math.floor((e.clientY - rect.top) * scaleY);
            mousePos = [x, y];
        }

        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            updateMousePos(e);
        });

        canvas.addEventListener('mousemove', (e) => {
            updateMousePos(e);
            if (!isDrawing) return;
        });

        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseleave', () => isDrawing = false);

        // è§¦æ‘¸äº‹ä»¶å¤„ç†
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDrawing = true;
            updateMousePos(e.touches[0]);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            updateMousePos(e.touches[0]);
            if (!isDrawing) return;

        }, { passive: false });

        canvas.addEventListener('touchend', () => isDrawing = false);

        // æ³¢åŠ¨æ¿€åŠ±
        function addDisturbance(x, y) {
            if (x < 0 || x >= N || y < 0 || y >= N) return;
            const idx = y * N + x;
            const t = tick / 60;
            buffers[current][idx] += Math.sin(2 * Math.PI * frequency.value * t) * amplitude.value;
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            if (isDrawing) touch();
            updateWave();
            render();
        }

        function touch() {
            if (currentMode === 'wave') {
                addDisturbance(mousePos[0], mousePos[1]);
            } else {
                modifyObstacles(mousePos[0], mousePos[1], currentMode === 'obstacle');
            }
        }
        animate();
    </script>
</body>

</html>