<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‹¼è±†åƒç´ æå–å™¨</title>
    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: #1e1e1e;
            --border-color: #333;
            --text-main: #e0e0e0;
            --text-sub: #aaaaaa;
            --accent: #007acc;
            --accent-hover: #005f9e;
            --handle-color: #ff0055;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* é¡¶éƒ¨å·¥å…·æ  */
        header {
            background-color: var(--panel-bg);
            border-bottom: 1px solid var(--border-color);
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-size: 1.2rem;
            color: var(--accent);
            margin-right: 20px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }

        input[type="number"] {
            background: #2c2c2c;
            border: 1px solid #444;
            color: white;
            padding: 5px;
            border-radius: 4px;
            width: 50px;
        }

        button {
            background-color: var(--accent);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s;
        }

        button:hover {
            background-color: var(--accent-hover);
        }

        button.secondary {
            background-color: #444;
        }

        button.danger {
            background-color: #a33;
        }

        /* ä¸»åŒºåŸŸ */
        .workspace {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* å·¦ä¾§ï¼šæºå›¾ç¼–è¾‘ */
        .source-pane {
            flex: 1;
            position: relative;
            background-color: #000;
            overflow: hidden;
            border-right: 1px solid var(--border-color);
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

        /* ç”»å¸ƒå åŠ å±‚ */
        .canvas-stack {
            position: relative;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        canvas {
            display: block;
        }

        /* è¦†ç›–åœ¨æºå›¾ä¸Šçš„äº¤äº’å±‚ */
        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            mix-blend-mode: difference;
        }

        /* å³ä¾§ï¼šé¢„è§ˆä¸è®¾ç½® */
        .sidebar {
            width: 400px;
            background-color: var(--panel-bg);
            display: flex;
            flex-direction: column;
            border-left: 1px solid var(--border-color);
            overflow-y: auto;
        }

        .panel-section {
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .panel-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 0.95rem;
            color: var(--text-sub);
            display: flex;
            justify-content: space-between;
        }

        /* ç»“æœé¢„è§ˆåŒº */
        .preview-container {
            background: #111;
            padding: 10px;
            border-radius: 4px;
            overflow: auto;
            max-height: 400px;
            display: flex;
            align-items: flex-start;
        }

        /* è°ƒè‰²æ¿ç½‘æ ¼ */
        .palette-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(28px, 1fr));
            gap: 4px;
        }

        .swatch {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            border: 1px solid #444;
            cursor: pointer;
            position: relative;
        }

        .swatch:hover::after {
            content: 'Ã—';
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            font-weight: bold;
        }

        /* æç¤ºä¿¡æ¯ */
        .hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 20px;
            pointer-events: none;
            font-size: 0.85rem;
        }
    </style>
</head>

<body>

    <header>
        <h1>æ‹¼è±†åƒç´ æå–å™¨</h1>
        <div class="control-group">
            <label>æå–å°ºå¯¸(å®½xé«˜):</label>
            <input type="number" id="inpWidth" value="30" min="2">
            <span>x</span>
            <input type="number" id="inpHeight" value="30" min="2">
        </div>
        <div class="control-group">
            <input type="file" id="inpFile" accept="image/*" style="display:none">
            <button onclick="document.getElementById('inpFile').click()">ğŸ“‚ ä¸Šä¼ å›¾ç‰‡</button>
        </div>
        <div class="control-group" style="margin-left: auto;">
            <button id="btnDownload">ğŸ’¾ ä¸‹è½½å›¾çº¸</button>
            <button id="btnDownloadSource">ğŸ–¼ï¸ ä¸‹è½½åŸåƒç´ </button>
        </div>
    </header>

    <div class="workspace">
        <div class="source-pane" id="sourcePane">
            <div class="canvas-stack" id="canvasStack">
                <canvas id="imgCanvas"></canvas>
                <canvas id="overlayCanvas"></canvas>
            </div>
            <div class="hint">æ‹–åŠ¨å››ä¸ªçº¢ç‚¹è°ƒæ•´å–æ ·èŒƒå›´</div>
        </div>

        <div class="sidebar">
            <div class="panel-section">
                <div class="panel-title">å®æ—¶é¢„è§ˆ</div>
                <div class="preview-container">
                    <canvas id="resultCanvas"></canvas>
                </div>
                <div style="margin-top: 10px; display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="chkQuantize" checked>
                    <label for="chkQuantize">å¼€å¯é‡åŒ–</label>
                </div>
                <div style="margin-top: 5px; display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="chkDither">
                    <label for="chkDither">å¼€å¯æŠ–åŠ¨ (Floyd-Steinberg)</label>
                </div>
            </div>

            <div class="panel-section" style="flex: 1;">
                <div class="panel-title">
                    <span>è°ƒè‰²æ¿ (<span id="lblColorCount">0</span>è‰²)</span>
                    <div>
                        <button class="secondary" style="font-size: 0.8rem; padding: 2px 8px;"
                            onclick="resetPalette()">é‡ç½®</button>
                        <button class="secondary" style="font-size: 0.8rem; padding: 2px 8px;" onclick="addColor()">+
                            æ·»åŠ </button>
                    </div>
                </div>
                <div class="palette-grid" id="paletteBox"></div>
            </div>
        </div>
    </div>

    <script>
        /**
         * æ ¸å¿ƒé€»è¾‘ï¼š
         * 1. ç»´æŠ¤4ä¸ªæ§åˆ¶ç‚¹ï¼ˆCornersï¼‰ã€‚
         * 2. ä½¿ç”¨åŒçº¿æ€§æ’å€¼ (Bilinear Interpolation) è®¡ç®—ç½‘æ ¼åæ ‡ã€‚
         * 3. åœ¨åŸå›¾ä¸­é‡‡æ ·å¯¹åº”åæ ‡çš„åƒç´ ã€‚
         * 4. é¢œè‰²é‡åŒ–å¹¶æ˜¾ç¤ºã€‚
         */

        // --- çŠ¶æ€ç®¡ç† ---
        const state = {
            gridW: 30,
            gridH: 30,
            palette: [],
            corners: [], // [{x,y}, {x,y}, {x,y}, {x,y}] (TL, TR, BR, BL)
            isDragging: -1, // index of point being dragged
            imgData: null, // Source image pixel data
            srcWidth: 0,
            srcHeight: 0,
            dither: false,
            quantize: true
        };

        const DEFAULT_PALETTE = [
            [0, 0, 0], [60, 60, 60], [120, 120, 120], [210, 210, 210], [255, 255, 255],
            [96, 0, 24], [237, 28, 36], [255, 127, 39], [246, 170, 9], [249, 221, 59],
            [255, 250, 188], [14, 185, 104], [19, 230, 123], [135, 255, 94], [12, 129, 110],
            [16, 174, 166], [19, 225, 190], [96, 247, 242], [40, 80, 158], [64, 147, 228],
            [107, 80, 246], [153, 177, 251], [120, 12, 153], [170, 56, 185], [224, 159, 249],
            [203, 0, 122], [236, 31, 128], [243, 141, 169], [104, 70, 52], [149, 104, 42],
            [248, 178, 119]
        ];

        // --- DOM å…ƒç´  ---
        const els = {
            imgCanvas: document.getElementById('imgCanvas'),
            overlayCanvas: document.getElementById('overlayCanvas'),
            resultCanvas: document.getElementById('resultCanvas'),
            inpFile: document.getElementById('inpFile'),
            inpWidth: document.getElementById('inpWidth'),
            inpHeight: document.getElementById('inpHeight'),
            paletteBox: document.getElementById('paletteBox'),
            countLbl: document.getElementById('lblColorCount'),
            chkQuantize: document.getElementById('chkQuantize'),
            chkDither: document.getElementById('chkDither'),
            dlBtn: document.getElementById('btnDownload'),
            dlSrcBtn: document.getElementById('btnDownloadSource'),
            canvasStack: document.getElementById('canvasStack')
        };

        const ctxImg = els.imgCanvas.getContext('2d');
        const ctxOverlay = els.overlayCanvas.getContext('2d');
        const ctxRes = els.resultCanvas.getContext('2d');

        // --- åˆå§‹åŒ– ---
        function init() {
            loadPalette();

            // äº‹ä»¶ç›‘å¬
            els.inpFile.addEventListener('change', handleFile);
            els.inpWidth.addEventListener('change', updateGridSize);
            els.inpHeight.addEventListener('change', updateGridSize);
            els.chkQuantize.addEventListener('change', () => { state.quantize = els.chkQuantize.checked; process(); });
            els.chkDither.addEventListener('change', () => { state.dither = els.chkDither.checked; process(); });
            els.dlBtn.addEventListener('click', downloadResult);
            els.dlSrcBtn.addEventListener('click', downloadSourcePixels);

            // Canvas äº¤äº’
            els.overlayCanvas.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);

            // é»˜è®¤ç©ºçŠ¶æ€
            resizeCanvas(400, 300);
            ctxImg.fillStyle = "#222";
            ctxImg.fillRect(0, 0, 400, 300);
            ctxImg.fillStyle = "#555";
            ctxImg.font = "20px Arial";
            ctxImg.textAlign = "center";
            ctxImg.fillText("è¯·ä¸Šä¼ å›¾ç‰‡", 200, 150);
        }

        // --- æ–‡ä»¶å¤„ç† ---
        function handleFile(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (evt) => {
                const img = new Image();
                img.onload = () => {
                    setupImage(img);
                };
                img.src = evt.target.result;
            };
            reader.readAsDataURL(file);
        }

        function setupImage(img) {
            // é™åˆ¶ Canvas æœ€å¤§æ˜¾ç¤ºå°ºå¯¸ï¼Œé¿å…è¿‡å¤§å¡é¡¿
            const MAX_W = 800;
            const MAX_H = 600;
            let w = img.width;
            let h = img.height;

            // ç®€å•çš„ç¼©æ”¾é€»è¾‘é€‚åº”å±å¹•
            const scale = Math.min(1, Math.min(MAX_W / w, MAX_H / h));
            w = Math.floor(w * scale);
            h = Math.floor(h * scale);

            state.srcWidth = w;
            state.srcHeight = h;

            resizeCanvas(w, h);

            // ç»˜åˆ¶å›¾ç‰‡
            ctxImg.drawImage(img, 0, 0, w, h);
            // è·å–åƒç´ æ•°æ®ç”¨äºåç»­å¤„ç†
            state.imgData = ctxImg.getImageData(0, 0, w, h);

            // åˆå§‹åŒ–4ä¸ªè§’ç‚¹ (inset 20%)
            const padX = w * 0.2;
            const padY = h * 0.2;
            state.corners = [
                { x: padX, y: padY },           // Top Left
                { x: w - padX, y: padY },       // Top Right
                { x: w - padX, y: h - padY },   // Bottom Right
                { x: padX, y: h - padY }        // Bottom Left
            ];

            updateGridSize(); // è§¦å‘é‡ç»˜
        }

        function resizeCanvas(w, h) {
            els.imgCanvas.width = w;
            els.imgCanvas.height = h;
            els.overlayCanvas.width = w;
            els.overlayCanvas.height = h;
            els.canvasStack.style.width = w + 'px';
            els.canvasStack.style.height = h + 'px';
        }

        function updateGridSize() {
            state.gridW = parseInt(els.inpWidth.value) || 10;
            state.gridH = parseInt(els.inpHeight.value) || 10;
            drawOverlay();
            process();
        }

        // --- äº¤äº’é€»è¾‘ (æ‹–åŠ¨è§’ç‚¹) ---
        function onMouseDown(e) {
            if (!state.corners.length) return;
            const { offsetX, offsetY } = e;

            // æ£€æµ‹ç‚¹å‡»äº†å“ªä¸ªç‚¹ (é˜ˆå€¼ 15px)
            let closestIndex = -1;
            let minDist = 15; // Hit radius

            state.corners.forEach((p, i) => {
                const dist = Math.hypot(p.x - offsetX, p.y - offsetY);
                if (dist < minDist) {
                    minDist = dist;
                    closestIndex = i;
                }
            });

            if (closestIndex !== -1) {
                state.isDragging = closestIndex;
            }
        }

        function onMouseMove(e) {
            if (state.isDragging === -1) return;

            // è®¡ç®—ç›¸å¯¹äº overlayCanvas çš„åæ ‡
            const rect = els.overlayCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // é™åˆ¶åæ ‡åœ¨ç”»å¸ƒå†…
            state.corners[state.isDragging].x = Math.max(0, Math.min(state.srcWidth, x));
            state.corners[state.isDragging].y = Math.max(0, Math.min(state.srcHeight, y));

            drawOverlay();
            // å®æ—¶å¤„ç†å¯èƒ½è¾ƒå¡ï¼Œå¯ä»¥ç”¨ requestAnimationFrame ä¼˜åŒ–ï¼Œè¿™é‡Œä¸ºäº†ç®€åŒ–ç›´æ¥è°ƒç”¨
            // ä¸ºäº†æµç•…åº¦ï¼Œæ‹–æ‹½æ—¶å¯ä»¥ä¸åšé‡åŒ–å¤„ç†ï¼Œåªç”»ç½‘æ ¼ï¼Ÿ
            // ä¸ºäº†ä½“éªŒå¥½ï¼Œæˆ‘ä»¬åªåœ¨ UI æ›´æ–° overlayï¼Œå¤„ç†ç¨å¾®èŠ‚æµ
            if (!state.pendingProcess) {
                state.pendingProcess = setTimeout(() => {
                    process();
                    state.pendingProcess = null;
                }, 30);
            }
        }

        function onMouseUp() {
            state.isDragging = -1;
            process(); // Final process
        }

        // --- ç»˜åˆ¶è¦†ç›–å±‚ (ç½‘æ ¼å’Œæ‰‹æŸ„) ---
        function drawOverlay() {
            const ctx = ctxOverlay;
            ctx.clearRect(0, 0, state.srcWidth, state.srcHeight);
            if (!state.corners.length) return;

            // 1. ç»˜åˆ¶æ‰­æ›²çš„ç½‘æ ¼
            // 1. ç»˜åˆ¶æ‰­æ›²çš„ç½‘æ ¼
            ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
            ctx.lineWidth = 1;
            ctx.beginPath();

            const [tl, tr, br, bl] = state.corners;

            // ç»˜åˆ¶å‚ç›´çº¿ (Vertical Grid Lines)
            for (let i = 0; i <= state.gridW; i++) {
                const u = i / state.gridW;
                // Top edge interpolation
                const tx = tl.x + (tr.x - tl.x) * u;
                const ty = tl.y + (tr.y - tl.y) * u;
                // Bottom edge interpolation
                const bx = bl.x + (br.x - bl.x) * u;
                const by = bl.y + (br.y - bl.y) * u;

                ctx.moveTo(tx, ty);
                ctx.lineTo(bx, by);
            }

            // ç»˜åˆ¶æ°´å¹³çº¿ (Horizontal Grid Lines)
            for (let j = 0; j <= state.gridH; j++) {
                const v = j / state.gridH;
                // Left edge
                const lx = tl.x + (bl.x - tl.x) * v;
                const ly = tl.y + (bl.y - tl.y) * v;
                // Right edge
                const rx = tr.x + (br.x - tr.x) * v;
                const ry = tr.y + (br.y - tr.y) * v;

                ctx.moveTo(lx, ly);
                ctx.lineTo(rx, ry);
            }
            ctx.stroke();

            // 2. ç»˜åˆ¶4ä¸ªæ§åˆ¶ç‚¹æ‰‹æŸ„
            state.corners.forEach((p, i) => {
                ctx.fillStyle = (i === state.isDragging) ? "#fff" : "var(--handle-color)";
                ctx.beginPath();
                ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        // --- åƒç´ æå–ä¸å¤„ç† ---
        function process() {
            if (!state.imgData || !state.corners.length) return;

            const w = state.gridW;
            const h = state.gridH;

            // å‡†å¤‡åƒç´ æ•°æ®æ•°ç»„
            const pixels = new Uint8ClampedArray(w * h * 4);
            const src = state.imgData.data;
            const sw = state.imgData.width;
            const sh = state.imgData.height;

            const [tl, tr, br, bl] = state.corners;

            // éå†ç›®æ ‡ç½‘æ ¼çš„æ¯ä¸€ä¸ªâ€œè±†å­â€
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    // è®¡ç®—ç½‘æ ¼ä¸­å¿ƒç‚¹ (u, v)
                    const u = (x + 0.5) / w;
                    const v = (y + 0.5) / h;

                    // åŒçº¿æ€§æ’å€¼è®¡ç®—åœ¨åŸå›¾ä¸­çš„åæ ‡
                    // Top point
                    const tx = tl.x + (tr.x - tl.x) * u;
                    const ty = tl.y + (tr.y - tl.y) * u;
                    // Bottom point
                    const bx = bl.x + (br.x - bl.x) * u;
                    const by = bl.y + (br.y - bl.y) * u;

                    // Final point
                    const sx = Math.floor(tx + (bx - tx) * v);
                    const sy = Math.floor(ty + (by - ty) * v);

                    // é‡‡æ ·é¢œè‰²
                    let r = 0, g = 0, b = 0, a = 255;

                    // è¾¹ç•Œæ£€æŸ¥
                    if (sx >= 0 && sx < sw && sy >= 0 && sy < sh) {
                        const idx = (sy * sw + sx) * 4;
                        r = src[idx];
                        g = src[idx + 1];
                        b = src[idx + 2];
                    }

                    const targetIdx = (y * w + x) * 4;
                    pixels[targetIdx] = r;
                    pixels[targetIdx + 1] = g;
                    pixels[targetIdx + 2] = b;
                    pixels[targetIdx + 3] = 255;
                }
            }

            // æŠ–åŠ¨ä¸é‡åŒ–
            if (state.quantize) {
                if (state.dither) {
                    applyFloydSteinberg(pixels, w, h);
                } else {
                    applyNearestColor(pixels);
                }
            }
            // else: pixels already contain sampled RGB values

            // ç»˜åˆ¶ç»“æœ
            renderPreview(pixels, w, h);
        }

        // --- é¢œè‰²ç®—æ³• (åŒä¸Šä¸€ç‰ˆ) ---
        function getClosestColor(r, g, b) {
            let minDist = Infinity;
            let closest = state.palette[0] || [0, 0, 0];

            for (let col of state.palette) {
                // åŠ æƒè·ç¦» (Redmean è¿‘ä¼¼)
                const dr = r - col[0];
                const dg = g - col[1];
                const db = b - col[2];
                // 0.299, 0.587, 0.114 is luminance, but usually 0.3, 0.59, 0.11 is used for color distance simple approximation
                const dist = (dr * dr) * 0.3 + (dg * dg) * 0.59 + (db * db) * 0.11;
                if (dist < minDist) {
                    minDist = dist;
                    closest = col;
                }
            }
            return closest;
        }

        function applyNearestColor(data) {
            for (let i = 0; i < data.length; i += 4) {
                const [r, g, b] = getClosestColor(data[i], data[i + 1], data[i + 2]);
                data[i] = r;
                data[i + 1] = g;
                data[i + 2] = b;
            }
        }

        function applyFloydSteinberg(data, w, h) {
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    const oldR = data[i];
                    const oldG = data[i + 1];
                    const oldB = data[i + 2];

                    const [newR, newG, newB] = getClosestColor(oldR, oldG, oldB);

                    data[i] = newR;
                    data[i + 1] = newG;
                    data[i + 2] = newB;

                    const errR = oldR - newR;
                    const errG = oldG - newG;
                    const errB = oldB - newB;

                    // Distribute error
                    distributeErr(data, x + 1, y, w, h, errR, errG, errB, 7 / 16);
                    distributeErr(data, x - 1, y + 1, w, h, errR, errG, errB, 3 / 16);
                    distributeErr(data, x, y + 1, w, h, errR, errG, errB, 5 / 16);
                    distributeErr(data, x + 1, y + 1, w, h, errR, errG, errB, 1 / 16);
                }
            }
        }

        function distributeErr(data, x, y, w, h, er, eg, eb, f) {
            if (x < 0 || x >= w || y < 0 || y >= h) return;
            const i = (y * w + x) * 4;
            data[i] = Math.min(255, Math.max(0, data[i] + er * f));
            data[i + 1] = Math.min(255, Math.max(0, data[i + 1] + eg * f));
            data[i + 2] = Math.min(255, Math.max(0, data[i + 2] + eb * f));
        }

        // --- æ¸²æŸ“æœ€ç»ˆæ•ˆæœ (Grid with Gaps) ---
        function renderPreview(data, w, h) {
            const beadSize = 16;
            const gap = 1;
            const cellSize = beadSize + gap;

            els.resultCanvas.width = w * cellSize + gap;
            els.resultCanvas.height = h * cellSize + gap;

            // æ¸…é™¤èƒŒæ™¯
            ctxRes.fillStyle = "#111"; // é»‘è‰²åº•æ¿
            ctxRes.fillRect(0, 0, els.resultCanvas.width, els.resultCanvas.height);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    // åæ ‡
                    const cx = gap + x * cellSize;
                    const cy = gap + y * cellSize;

                    // ç”»è±†å­ (åœ†å½¢)
                    ctxRes.fillStyle = `rgb(${r},${g},${b})`;
                    ctxRes.beginPath();
                    ctxRes.arc(cx + beadSize / 2, cy + beadSize / 2, beadSize / 2, 0, Math.PI * 2);
                    ctxRes.fill();

                    // ç®€å•é«˜å…‰
                    ctxRes.fillStyle = "rgba(255,255,255,0.25)";
                    ctxRes.beginPath();
                    ctxRes.arc(cx + beadSize * 0.35, cy + beadSize * 0.35, beadSize * 0.2, 0, Math.PI * 2);
                    ctxRes.fill();
                }
            }
        }

        // --- è°ƒè‰²æ¿ç®¡ç† ---
        function loadPalette() {
            const saved = localStorage.getItem('pixelBeadPalette');
            if (saved) {
                state.palette = JSON.parse(saved);
            } else {
                state.palette = JSON.parse(JSON.stringify(DEFAULT_PALETTE));
            }
            renderPalette();
        }

        function renderPalette() {
            els.paletteBox.innerHTML = '';
            state.palette.forEach((rgb, idx) => {
                const div = document.createElement('div');
                div.className = 'swatch';
                div.style.backgroundColor = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
                div.title = `RGB: ${rgb.join(',')}`;
                div.onclick = () => {
                    if (confirm("åˆ é™¤æ­¤é¢œè‰²?")) {
                        state.palette.splice(idx, 1);
                        savePalette();
                    }
                };
                els.paletteBox.appendChild(div);
            });
            els.countLbl.textContent = state.palette.length;
        }

        function addColor() {
            const input = document.createElement('input');
            input.type = 'color';
            input.onchange = (e) => {
                const hex = e.target.value;
                const r = parseInt(hex.substr(1, 2), 16);
                const g = parseInt(hex.substr(3, 2), 16);
                const b = parseInt(hex.substr(5, 2), 16);
                state.palette.push([r, g, b]);
                savePalette();
            };
            input.click();
        }

        function resetPalette() {
            state.palette = JSON.parse(JSON.stringify(DEFAULT_PALETTE));
            savePalette();
        }

        function savePalette() {
            localStorage.setItem('pixelBeadPalette', JSON.stringify(state.palette));
            renderPalette();
            process();
        }

        function downloadResult() {
            const link = document.createElement('a');
            link.download = 'bead_pattern.png';
            link.href = els.resultCanvas.toDataURL();
            link.click();
        }

        function downloadSourcePixels() {
            if (!state.imgData || !state.corners.length) return;

            const w = state.gridW;
            const h = state.gridH;

            // Create temporary canvas
            const cvs = document.createElement('canvas');
            cvs.width = w;
            cvs.height = h;
            const ctx = cvs.getContext('2d');

            // Get current processing result (re-run logic partially or just use what we have, 
            // but process() modifies a local array. Let's just create imageData from what we would have.)

            // Re-run sampling logic simply
            const imgData = ctx.createImageData(w, h);
            // We need to re-run the sampling loop because 'process' only renders to preview
            // Actually 'process' creates 'pixels' array. We could cache it in state if we wanted, 
            // but re-running is cheap enough for a click action.

            // Copy-paste sampling logic or refactor? Re-running is safer to ensure state consistency.
            // Let's refactor slightly: extract sampling to a function that returns the pixel array.
            // For now, to minimize diff, let's just duplicate the sampling logic for the download function
            // or even better, let 'process' store the last result?
            // "pixels" in process() is local. Let's make it state or start a new sampling.

            const [tl, tr, br, bl] = state.corners;
            const src = state.imgData.data;
            const sw = state.imgData.width;
            const sh = state.imgData.height;
            const pixels = imgData.data;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const u = (x + 0.5) / w;
                    const v = (y + 0.5) / h;
                    const tx = tl.x + (tr.x - tl.x) * u;
                    const ty = tl.y + (tr.y - tl.y) * u;
                    const bx = bl.x + (br.x - bl.x) * u;
                    const by = bl.y + (br.y - bl.y) * u;
                    const sx = Math.floor(tx + (bx - tx) * v);
                    const sy = Math.floor(ty + (by - ty) * v);

                    let r = 0, g = 0, b = 0;
                    if (sx >= 0 && sx < sw && sy >= 0 && sy < sh) {
                        const idx = (sy * sw + sx) * 4;
                        r = src[idx];
                        g = src[idx + 1];
                        b = src[idx + 2];
                    }
                    const i = (y * w + x) * 4;
                    pixels[i] = r;
                    pixels[i + 1] = g;
                    pixels[i + 2] = b;
                    pixels[i + 3] = 255;
                }
            }

            // Put on canvas
            ctx.putImageData(imgData, 0, 0);

            const link = document.createElement('a');
            link.download = 'pixel_source_1x1.png';
            link.href = cvs.toDataURL();
            link.click();
        }

        // å¯åŠ¨
        init();

    </script>
</body>

</html>