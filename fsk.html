<html>

<head>
    <title>音频Modem</title>

    <meta http-equiv="Content-Type" content="text/html; charset=utf8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        :root {
            --bg-gradient: linear-gradient(45deg, #0a0e1a, #1a1f2c);
            --neon-cyan: #00f3ff;
            --neon-purple: #bd00ff;
            --dark-bg: #0d1117;
            --text-primary: #e1e7f0;
            --text-secondary: #b6becc;
            --border-radius: 8px;
            --border-width: 2px;
            --glow: 0 0 15px;
        }

        body {
            background: var(--bg-gradient);
            color: var(--text-primary);
            font-family: 'Segoe UI', system-ui, sans-serif;
            line-height: 1.6;
            min-height: 100vh;
            margin: 0;
            padding: 2rem;
            box-sizing: border-box;
        }

        #title {
            text-align: center;
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: var(--glow) rgba(0, 243, 255, 0.2);
            margin-bottom: 2rem;
        }

        textarea {
            background: var(--dark-bg);
            border: var(--border-width) solid #2d3746;
            border-radius: var(--border-radius);
            color: var(--text-primary);
            padding: 1rem;
            font-size: 1rem;
            transition: all 0.3s ease;
            width: 100%;
            height: 50vh;
            resize: vertical;
        }

        textarea:focus {
            border-color: var(--neon-cyan);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
            outline: none;
        }

        button,
        input::file-selector-button {
            background: linear-gradient(135deg, #1a2333, #0d1117);
            border: var(--border-width) solid #2d3746;
            color: var(--text-secondary);
            padding: 0.8rem 1.5rem;
            border-radius: var(--border-radius);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            margin: 8px;
        }

        button:hover,
        input::file-selector-button:hover {
            color: var(--neon-cyan);
            border-color: var(--neon-cyan);
            box-shadow: var(--glow) rgba(0, 243, 255, 0.3);
        }

        button:disabled {
            color: #1a2333;
            border-color: #2d3746
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                    transparent,
                    rgba(0, 243, 255, 0.1),
                    transparent);
            transition: 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        #audio-inputs {
            margin: 1.5rem 0;
        }

        select {
            background: var(--dark-bg);
            border: var(--border-width) solid #2d3746;
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 6px;
            margin-left: 1rem;
        }

        input[type="number"] {
            background: var(--dark-bg);
            border: var(--border-width) solid #2d3746;
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 6px;
            margin-left: 1rem;
        }

        input[type="number"]:focus {
            border-color: var(--neon-cyan);
            outline: none;
        }

        select:focus {
            border-color: var(--neon-cyan);
            outline: none;
        }

        hr {
            border: 1px solid #2d3746;
            margin: 1rem 0;
        }

        #constellation {
            background: var(--dark-bg);
            border: var(--border-width) solid #2d3746;
            border-radius: var(--border-radius);
            margin-top: 1rem;
            max-width: 500px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        .btn-container {
            display: flex;
            justify-content: center;
            align-items: stretch;
        }

        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .params {
            display: grid;
            grid-template-columns: 1fr 2fr;
            row-gap: 8px;
        }

        .title-text {
            text-align: center;
            font-size: 1.5rem;
            font-weight: 600;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: var(--glow) rgba(0, 243, 255, 0.2);
            margin-bottom: 1rem;
        }

        canvas {
            border: var(--border-width) solid #2d3746;
            border-radius: var(--border-radius);
            margin-top: 1rem;
            width: 100%;
            image-rendering: pixelated;
        }

        details {
            background: var(--dark-bg);
            border: var(--border-width) solid #2d3746;
            border-radius: var(--border-radius);
            margin: 1rem 0;
            transition: all 0.3s ease;
        }

        details[open] {
            border-color: var(--neon-cyan);
            box-shadow: var(--glow) rgba(0, 243, 255, 0.2);
        }

        summary {
            color: var(--text-secondary);
            padding: 0.75rem;
            cursor: pointer;
            position: relative;
            list-style: none;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        summary::-webkit-details-marker {
            display: none;
        }

        summary:after {
            content: "▶";
            color: var(--text-secondary);
            position: absolute;
            right: 1rem;
            transition: transform 0.3s ease;
        }

        details[open] summary:after {
            transform: rotate(90deg);
            color: var(--neon-cyan);
        }

        summary:hover {
            color: var(--neon-cyan);
            background: linear-gradient(90deg,
                    rgba(0, 243, 255, 0.05),
                    transparent 50%);
        }

        details>div {
            padding: 1rem;
            border-top: var(--border-width) solid #2d3746;
            margin-top: 0.5rem;
        }

        #progress-bar {
            width: 100%;
            background: #2d3746;
            border-radius: var(--border-radius);
            overflow: hidden;
            margin-top: 1rem;
            display: none;
            /* 默认隐藏进度条 */
        }

        #progress {
            height: 4px;
            width: 0;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
            transition: width 0.3s ease;
        }

        #demod-info {
            font-family: monospace;
        }


        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }

            #constellation {
                width: 100%;
            }
        }
    </style>
</head>

<body>

    <h1 id='title'>音频Modem</h1>
    <div class="container">
        <div>
            <div class="title-text">发送</div>
            <textarea id="transmit" rows="25" cols="80" placeholder="待发送的内容"></textarea>
            <div class="btn-container">
                <button id="start-tx">发送</button>
                <button id="clearTx">清空</button>
                <button id="uploadText">上传</button>
                <input type="file" id="uploadTextFile" accept="text/*" hidden>
            </div>
            <details>
                <summary>图片发送</summary>
                <div>
                    <input type="file" accept="image/*" id="txImage">
                    <button id="txImageBtn">发送图片</button>
                    <canvas id="sourceCanvas"></canvas>
                </div>
            </details>
            <div id="bits"></div>
            <div id="progress-bar">
                <div id="progress"></div>
            </div>

        </div>
        <div>
            <div class="title-text">接收</div>
            <textarea id="received" rows="25" cols="80" disabled placeholder="接收到的内容"></textarea>

            <div class="btn-container">
                <button id='start'>接收</button>
                <button id="clearRx">清空</button>
                <button id="copyRx">复制</button>
            </div>
            <details id="imageRecvDiv">
                <summary>图片接收</summary>
                <div>
                    <canvas id="reconCanvas"></canvas>
                    <pre id="status"></pre>
                    <button id="downloadImg">下载图片</button>
                    <button id="cancelImage">取消图片</button>
                </div>
            </details>
            <!-- <button id="rxImageBtn">接收图片</button> -->
            <div id="audio-inputs">
                <label for="audio-input">音频输入：</label>
                <select id="audio-input"></select>
            </div>
        </div>
    </div>
    <hr>
    <div class="controls">
        <div class="params">
            <label>模式：</label>
            <select id="mode">
                <option value="gfsk">GFSK</option>
                <option value="fsk4">4FSK</option>
                <option value="bpsk" selected>BPSK</option>
                <option value="qpsk">QPSK</option>
                <option value="psk8">8PSK</option>
            </select>
            <label>选择频道：</label>
            <input type="number" id="channel" value="120" min="-16" max="180">
            <span id="freq"></span>
            <label>范围：1~21，120~180</label>
            <label>符号速率：</label>
            <select id="baudrateInput">
                <option value="2">2</option>
                <option value="8">8</option>
                <option value="32" selected>32</option>
                <option value="50">50</option>
                <option value="80">80</option>
                <option value="100">100</option>
                <option value="125">125</option>
                <option value="250">250</option>
                <option value="500">500</option>
                <option value="800">800</option>
                <option value="1000">1000</option>
                <option value="1200">1200</option>
            </select>
            <!-- <input type="number" id="baudrateInput" value="50" min="30" max="4800"> -->
        </div>
        <canvas id="constellation" width="500" height="500"></canvas>
        <div id="demod-info"></div>
    </div>
    <!-- <script src="//cdn.jsdelivr.net/npm/eruda"></script>
        <script>eruda.init();</script>
        -->
    <script>

        let baudRate = 32; // 波特率
        const sampleRate = 48000; // 采样率
        let carrierFreq = 16000; // 载波频率
        const freqMulti = 1; // 频率倍数
        let samplePerSymbol = sampleRate / baudRate; // 每个符号的采样点数
        let symbolTime = samplePerSymbol / sampleRate;
        let bandwidth = baudRate * freqMulti


        // 创建音频工作线程
        function createWorklets(baudRate, sampleRate) {
            class Complex {
                constructor(real, imag) {
                    this.real = real;
                    this.imag = imag;
                }

                add(other) {
                    return new Complex(this.real + other.real, this.imag + other.imag);
                }

                sub(other) {
                    return new Complex(this.real - other.real, this.imag - other.imag);
                }

                mul(other) {
                    return new Complex(this.real * other.real - this.imag * other.imag, this.real * other.imag + this.imag * other.real);
                }

                div(other) {
                    const den = other.real * other.real + other.imag * other.imag;
                    return new Complex((this.real * other.real + this.imag * other.imag) / den, (this.imag * other.real - this.real * other.imag) / den);
                }

                conj() {
                    return new Complex(this.real, -this.imag);
                }

                square() {
                    const real = this.real * this.real - this.imag * this.imag;
                    const imag = 2 * this.real * this.imag;
                    return new Complex(real, imag);
                }

                abs() {
                    return Math.sqrt(this.real * this.real + this.imag * this.imag); // 绝对值
                }

                toString() {
                    return `${this.real} + ${this.imag}i`;
                }
            }

            function getSample(array, index) {
                const windowSize = 5; // 可调整的窗口大小（左右各包含的样本数）
                const start = Math.max(0, Math.floor(index - windowSize));
                const end = Math.min(array.length - 1, Math.ceil(index + windowSize));
                let sum = 0;
                for (let i = start; i <= end; i++) {
                    const weight = sinc(index - i);
                    sum += array[i] * weight;
                }
                return sum;
            }

            function sinc(x) {
                if (x === 0) return 1;
                const piX = Math.PI * x;
                return Math.sin(piX) / piX;
            }

            function calculateAlpha(bd) {
                return Math.min(0.1, 16 / bd);
            }

            function calculateBeta(bd) {
                return Math.min(0.1, 12 / bd);
            }

            function clamp(v, min, max) {
                if (isNaN(v)) return min;
                else if (v > max) return max;
                else if (v < min) return min;
                else return v;
            }

            const mod = class extends AudioWorkletProcessor {
                constructor() {
                    super();
                    this.sampleRate = sampleRate;

                    this.symbols = [];       // 待发送的比特流
                    this.ptr = 0;         // 当前比特索引
                    this.samplesElapsed = 0; // 当前符号已生成的样本数
                    this.symbolMap = {
                        0: [-1, 0],
                        1: [1, 0]
                    }
                    this.started = false;

                    this.port.onmessage = (event) => {
                        switch (event.data.type) {
                            case "baudRate":
                                this.setBaudRate(event.data.baudRate);
                                break;
                            case "data":
                                this.setData(event.data.data);
                                break;
                            case "symbolMap":
                                this.symbolMap = event.data.symbolMap;
                        }
                    };
                }

                process(inputs, outputs) {
                    const output = outputs[0];
                    if (!output) return true;

                    if (this.ptr >= this.symbols.length && this.started) {
                        this.port.postMessage({ type: "stop" })
                        return false;
                    }

                    for (let i = 0; i < output[0].length; i++) {

                        // 符号周期结束，更新比特
                        if (this.samplesElapsed >= this.samplesPerSymbol) {
                            this.samplesElapsed = 0;
                            if (this.symbols.length > 0) {
                                const currentBit = this.symbols[this.ptr];
                                if (currentBit == null || this.symbolMap[currentBit] == null) {
                                    continue;
                                }
                                this.ptr++;
                                if (output[0]) output[0][i] = this.symbolMap[currentBit][0];
                                if (output[1]) output[1][i] = this.symbolMap[currentBit][1]
                            }
                        }

                        // 输出当前比特对应的电平（整个周期内持续）
                        this.samplesElapsed++;
                    }

                    return true;
                }

                setBaudRate(baudRate) {
                    this.baudRate = baudRate;
                    this.samplesPerSymbol = Math.round(this.sampleRate / baudRate);
                    this.samplesElapsed = 0; // 重置计数器
                }

                setData(data) {
                    this.symbols = data;
                    this.ptr = 0; // 重置指针
                    this.samplesElapsed = 0; // 开始新数据
                    this.started = true;
                }
            };

            const mixer = class extends AudioWorkletProcessor {
                static get parameterDescriptors() {
                    return [{
                        name: 'frequency',
                        defaultValue: 440,
                        minValue: 20,
                        maxValue: 20000,
                        automationRate: 'a-rate' // 关键：指定 automationRate 为 'a-rate'
                    }];
                }

                constructor() {
                    super();
                    this.phase = 0;
                    this.sampleRate = sampleRate;
                }

                process(inputs, outputs, parameters) {
                    // 确保有一个输入通道
                    const input = inputs[0];
                    const output = outputs[0];

                    // 确保是双声道输出
                    const leftChannel = output[0]; // 实部
                    const rightChannel = output[1]; // 虚部
                    const frequencies = parameters.frequency; // 获取频率数组，因为是 a-rate

                    for (let i = 0; i < leftChannel.length; i++) {
                        const frequency = frequencies[i] ?? frequencies[0]; // 获取当前帧的频率
                        const omega = 2 * Math.PI * frequency / this.sampleRate;

                        const real = Math.cos(this.phase);
                        const imag = Math.sin(this.phase);

                        // 处理左声道输入，如果未连接则乘以1
                        const leftInputValue = input && input[0] ? input[0][i] : 1;

                        // 处理右声道输入，如果未连接则乘以1
                        const rightInputValue = input && input[1] ? input[1][i] : 1;

                        leftChannel[i] = real * leftInputValue;
                        rightChannel[i] = imag * rightInputValue;

                        this.phase += omega;
                        //this.phase %= (2 * Math.PI); // 周期重置
                    }

                    return true;
                }
            }


            const demod = class extends AudioWorkletProcessor {
                constructor(options) {
                    super();
                    this.prev = [0, 0];
                    this.count = 0;
                    this.sampleRate = sampleRate;

                    this.port.onmessage = (event) => {
                        switch (event.data.type) {
                            case "baudRate":
                                this.setBaudRate(event.data.baudRate);
                                break;
                        }
                    };
                }

                setBaudRate(baudRate) {
                    this.baudRate = baudRate;
                    this.samplesPerSymbol = Math.round(this.sampleRate / baudRate);
                }

                process(inputs, outputs, parameters) {
                    // 获取输入信号和固定解调频率参数
                    const input = inputs[0];

                    const filteredI = input[0]
                    const filteredQ = input[1]

                    if (!filteredI || !filteredQ) return true;

                    // 相位差检测与符号同步处理
                    const phase = new Float32Array(filteredI.length);
                    for (let j = 0; j < filteredI.length - 1; ++j) {
                        // 计算相邻样本的共轭乘积（用于相位差检测）
                        const real1 = filteredI[j], imag1 = filteredQ[j];
                        const real2 = filteredI[j + 1], imag2 = filteredQ[j + 1];
                        const resultReal = real1 * real2 + imag1 * imag2;  // 实部
                        const resultImag = real1 * -imag2 + imag1 * real2;  // 虚部

                        // 计算瞬时相位差（arctan(虚部/实部））
                        phase[j] = Math.atan2(resultImag, resultReal);

                        // 符号边界检测（相位符号变化时触发）
                        if (j > 0 && Math.sign(phase[j]) != Math.sign(phase[j - 1])) {
                            // 重置计数器
                            this.count = 0;
                        }

                        // 符号周期计数
                        this.count = (this.count + 1) % this.samplesPerSymbol;
                        // 当达到采样时机时提交相位
                        if (this.count === this.samplesPerSymbol * 0.5) {
                            this.port.postMessage({ phase: phase[j] * this.samplesPerSymbol, bit: phase[j] > 0 ? 1 : 0 });
                        }
                    }

                    phase[phase.length - 1] = phase[phase.length - 2];  // 边界处理

                    // 将相位数据输出到指定端口
                    outputs[0][0].set(phase);
                    return true;
                }
            }

            const bpskDemod = class extends AudioWorkletProcessor {
                constructor(options) {
                    super();
                    this.sampleRate = sampleRate;
                    this.count = 0;

                    this.mu = 0;
                    this.out = [new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)];
                    this.outRail = [new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)];

                    this.alpha = 0.007
                    this.beta = 0.00005
                    this.gamma = 0.05
                    this.phase = 0;
                    this.freq = 0;

                    this.gain = 1;

                    this.port.onmessage = (event) => {
                        if (event.data.type === "baudRate") {
                            this.setBaudRate(event.data.baudRate);
                        }
                    };
                }

                setBaudRate(baudRate) {
                    this.baudRate = baudRate;
                    this.samplesPerSymbol = Math.round(this.sampleRate / baudRate);
                    this.alpha = calculateAlpha(baudRate)
                    this.beta = calculateBeta(baudRate)
                }

                process(inputs, outputs, parameters) {
                    const input = inputs[0];
                    const i = input[0];
                    const q = input[1];

                    if (!i || !q) return true;

                    let sum = 0;
                    for (let j = 0; j < i.length; ++j) {
                        sum += i[j] * i[j] + q[j] * q[j]
                    }
                    sum /= i.length;
                    const rms = Math.sqrt(sum)

                    let newGain = 1 / rms;
                    this.gain = clamp((this.gain*0.99 + newGain*0.01), 1, 1e6);

                    for (let j = 0; j < i.length; ++j) {
                        if (this.count >= 0) {
                            let currI = getSample(i, j + this.mu) * this.gain;
                            let currQ = getSample(q, j + this.mu) * this.gain

                            this.out[0] = new Complex(currI, currQ);
                            this.outRail[0] = new Complex(Number(this.out[0].real > 0), Number(this.out[0].imag > 0));

                            let x = this.outRail[0].sub(this.outRail[2]).mul(this.out[1].conj()).real;
                            let y = this.out[0].sub(this.out[2]).mul(this.outRail[1].conj()).real;
                            let mmVal = y - x;

                            this.mu += this.samplesPerSymbol + this.gamma * mmVal;
                            this.count -= Math.floor(this.mu);
                            this.mu -= Math.floor(this.mu);

                            // Shift history
                            this.out[2] = this.out[1];
                            this.out[1] = this.out[0];
                            this.outRail[2] = this.outRail[1];
                            this.outRail[1] = this.outRail[0];

                            // Costas Loop
                            let costas = new Complex(Math.cos(this.phase), -Math.sin(this.phase));
                            let out = this.out[0].mul(costas);
                            let error = out.real * out.imag;
                            this.freq += this.beta * error;

                            // Clamp freq
                            this.freq = clamp(this.freq, -Math.PI * 0.5, Math.PI * 0.5);

                            this.phase += this.freq + this.alpha * error;
                            if (this.phase > 2 * Math.PI) this.phase -= 2 * Math.PI;
                            if (this.phase < 0) this.phase += 2 * Math.PI;
                            this.port.postMessage({ i: out.real, q: out.imag, gain: this.gain, freq: this.freq });
                        }

                        this.count++;
                    }

                    return true;
                }
            };

            const qpskDemod = class extends AudioWorkletProcessor {
                constructor(options) {
                    super();
                    this.sampleRate = sampleRate;
                    this.count = 0;

                    this.mu = 0;
                    this.out = [new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)];
                    this.outRail = [new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)];

                    this.alpha = 0.003
                    this.beta = 0.00005
                    this.gamma = 0.1
                    this.phase = 0;
                    this.freq = 0;

                    this.gain = 1;

                    this.port.onmessage = (event) => {
                        if (event.data.type === "baudRate") {
                            this.setBaudRate(event.data.baudRate);
                        }
                    };
                }

                setBaudRate(baudRate) {
                    this.baudRate = baudRate;
                    this.samplesPerSymbol = Math.round(this.sampleRate / baudRate);
                    this.alpha = calculateAlpha(this.baudRate) / 2
                    this.beta = calculateBeta(this.baudRate) / 2
                }

                process(inputs, outputs, parameters) {
                    const input = inputs[0];
                    const i = input[0];
                    const q = input[1];

                    if (!i || !q) return true;

                    let sum = 0;
                    for (let j = 0; j < i.length; ++j) {
                        sum += i[j] * i[j] + q[j] * q[j]
                    }
                    sum /= i.length;
                    const rms = Math.sqrt(sum)


                    let newGain = 1 / rms;
                    this.gain = clamp((this.gain*0.99 + newGain*0.01), 1, 1e6);

                    for (let j = 0; j < i.length; ++j) {
                        if (this.count >= 0) {
                            let currI = getSample(i, j + this.mu) * this.gain;
                            let currQ = getSample(q, j + this.mu) * this.gain

                            this.out[0] = new Complex(currI, currQ);
                            this.outRail[0] = new Complex(Number(this.out[0].real > 0), Number(this.out[0].imag > 0));

                            let x = this.outRail[0].sub(this.outRail[2]).mul(this.out[1].conj()).real;
                            let y = this.out[0].sub(this.out[2]).mul(this.outRail[1].conj()).real;
                            let mmVal = y - x;

                            this.mu += this.samplesPerSymbol + this.gamma * mmVal;
                            this.count -= Math.floor(this.mu);
                            this.mu -= Math.floor(this.mu);

                            // Shift history
                            this.out[2] = this.out[1];
                            this.out[1] = this.out[0];
                            this.outRail[2] = this.outRail[1];
                            this.outRail[1] = this.outRail[0];

                            // Costas Loop
                            let costas = new Complex(Math.cos(this.phase), -Math.sin(this.phase));
                            let out = this.out[0].mul(costas);
                            let error = this.errorFunc(out); // errorFunc 需要根据实际情况进行修改
                            this.freq += this.beta * error;

                            this.freq = clamp(this.freq, -Math.PI * 0.25, Math.PI * 0.25);

                            this.phase += this.freq + this.alpha * error;
                            if (this.phase > 2 * Math.PI) this.phase -= 2 * Math.PI;
                            if (this.phase < 0) this.phase += 2 * Math.PI;
                            this.port.postMessage({ i: out.real, q: out.imag, gain: this.gain, freq: this.freq });
                        }

                        this.count++;
                    }

                    return true;
                }

                errorFunc(sample) {
                    let a, b;
                    if (sample.real > 0) a = 1;
                    else a = -1;
                    if (sample.imag > 0) b = 1;
                    else b = -1;
                    return a * sample.imag - b * sample.real;
                }
            };

            const psk8Demod = class extends AudioWorkletProcessor {
                constructor(options) {
                    super();
                    this.sampleRate = sampleRate;
                    this.count = 0;

                    this.mu = 0;
                    this.out = [new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)];
                    this.outRail = [new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)];

                    this.alpha = 0.007
                    this.beta = 0.001
                    this.gamma = 0.05
                    this.phase = 0;
                    this.freq = 0;

                    this.gain = 1;

                    this.phaseRef = Array.from({ length: 8 }, (_, k) => {
                        const angle = 2 * Math.PI * k / 8 + (Math.PI / 8);
                        return [Math.cos(angle), Math.sin(angle)];
                    });

                    this.port.onmessage = (event) => {
                        if (event.data.type === "baudRate") {
                            this.setBaudRate(event.data.baudRate);
                        }
                    };
                }

                setBaudRate(baudRate) {
                    this.baudRate = baudRate;
                    this.samplesPerSymbol = Math.round(this.sampleRate / baudRate);
                    this.alpha = calculateAlpha(baudRate) / 4
                    this.beta = calculateBeta(baudRate) / 4
                }

                nearest8psk(sample) {
                    return this.phaseRef.reduce((nearest, ref) => {
                        const distance = Math.sqrt(Math.pow(sample.real - ref.real, 2) + Math.pow(sample.imag - ref.imag, 2));
                        const nearestDistance = Math.sqrt(Math.pow(sample.real - nearest.real, 2) + Math.pow(sample.imag - nearest.imag, 2));
                        return distance < nearestDistance ? ref : nearest;
                    });
                }

                phaseDetector8(sample) {
                    const nearestSymbol = this.nearest8psk(sample);
                    const error = sample.real * nearestSymbol.imag - sample.imag * nearestSymbol.real;
                    return error;
                }

                process(inputs, outputs, parameters) {
                    const input = inputs[0];
                    const i = input[0];
                    const q = input[1];

                    if (!i || !q) return true;

                    let sum = 0;
                    for (let j = 0; j < i.length; ++j) {
                        sum += i[j] * i[j] + q[j] * q[j]
                    }
                    sum /= i.length;
                    const rms = Math.sqrt(sum)

                    let newGain = 1 / rms;
                    this.gain = clamp((this.gain*0.99 + newGain*0.01), 1, 1e6);

                    for (let j = 0; j < i.length; ++j) {
                        if (this.count >= 0) {
                            let currI = getSample(i, j + this.mu) * this.gain;
                            let currQ = getSample(q, j + this.mu) * this.gain

                            this.out[0] = new Complex(currI, currQ);
                            this.outRail[0] = this.nearest8psk(this.out[0]);

                            let x = this.outRail[0].sub(this.outRail[2]).mul(this.out[1].conj()).real;
                            let y = this.out[0].sub(this.out[2]).mul(this.outRail[1].conj()).real;
                            let mmVal = y - x;

                            this.mu += this.samplesPerSymbol + this.gamma * mmVal;
                            this.count -= Math.floor(this.mu);
                            this.mu -= Math.floor(this.mu);

                            // Shift history
                            this.out[2] = this.out[1];
                            this.out[1] = this.out[0];
                            this.outRail[2] = this.outRail[1];
                            this.outRail[1] = this.outRail[0];

                            // Costas Loop
                            let costas = new Complex(Math.cos(this.phase), -Math.sin(this.phase));
                            let out = this.out[0].mul(costas);
                            let error = this.phaseDetector8(out);
                            this.freq += this.beta * error;
                            this.freq = clamp(this.freq, -Math.PI * 0.125, Math.PI * 0.125);
                            this.phase += this.freq + this.alpha * error;
                            if (this.phase > 2 * Math.PI) this.phase -= 2 * Math.PI;
                            if (this.phase < 0) this.phase += 2 * Math.PI;
                            this.port.postMessage({ i: out.real, q: out.imag, gain: this.gain, freq: this.freq });
                        }

                        this.count++;
                    }

                    return true;
                }
            };

            registerProcessor('demod', demod);
            registerProcessor('mixer', mixer)
            registerProcessor('mod', mod);
            registerProcessor('bpsk-demod', bpskDemod)
            registerProcessor('qpsk-demod', qpskDemod)
            registerProcessor('8psk-demod', psk8Demod)
        }

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        const code = new TextEncoder().encode(`(${createWorklets.toString()})(${baudRate},${sampleRate});`);
        const workletData = 'data:application/javascript;base64,' + arrayBufferToBase64(code)

        // ============================ 以下为主要代码 ============================

        function setBaudRate(bd) {
            baudRate = bd;
            samplePerSymbol = sampleRate / baudRate;
            symbolTime = samplePerSymbol / sampleRate;
            bandwidth = baudRate * freqMulti
            constellation.maxLen = Math.max(1, bd / 8);
        }

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: sampleRate, latencyHint: "balanced" });


        const IMG_SIZE = 128;
        const BLOCK_SIZE_Y = 8;         // Y 通道块尺寸（8×8）
        const BLOCK_SIZE_CHROMA = BLOCK_SIZE_Y >> 1;      // 色度块尺寸（4×4）


        const fib = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578]; // 斐波那契数列
        const fibRev = [...fib].reverse()
        const VARICODE = [
            " ", "e",
            "o", "t",
            "a", "i", "n",
            "\n", "\r", "l", "r", "s",
            "-", "c", "d", "f", "h", "m", "p", "u",
            ",", ".", "=", "A", "E", "I", "S", "T", "b", "g", "v", "w", "y",
            "\t", "(", ")", "0", "1", "2", "3", ":", "B", "C", "D", "F", "G", "L", "M", "N",
            "O", "P", "R", "k", "x",
            "!", "\"", "#", "$", "'", "*", "+", "/", "4", "5", "6", "7", "8", "9", ";", "<",
            ">", "H", "J", "K", "Q", "U", "V", "W", "X", "Y", "[", "\\", "]", "_", "j", "q",
            "z", "|",
            "\x00", "\x01", "\x02", "\x03", "\x04", "\x05", "\x06", "\x07", "\x08", "\x0B", "\x0C", "\x0E", "\x0F", "\x10", "\x11", "\x12",
            "\x13", "\x14", "\x15", "\x16", "\x17", "\x18", "\x19", "\x1A", "\x1B", "\x1C", "\x1D", "\x1E", "\x1F",
            "%", "&", "?", "@", "Z", "^", "`", "{", "}", "~", "\x7F"
        ]



        function fibEncode(number) {
            let result = [];
            let i = 0;
            let started = false;

            // 查找 i，使得 fibRev[i] > number
            while (fibRev[i] > number) {
                i++;
            }

            // 斐波那契编码过程
            while (i < fibRev.length) {
                if (fibRev[i] <= number) {
                    number -= fibRev[i];
                    result.unshift(1);
                } else {
                    result.unshift(0);
                }
                i++;
            }

            // 结束符号 1
            result.push(1);

            return result;
        }

        function fibonacciEncoding(numbers) {
            let result = [];
            for (let num of numbers) {
                for (let bit of fibEncode(num)) {
                    result.push(bit)
                }
            }
            return result;
        }

        function differentialEncoding(bitArray) {
            let codedArray = [0];
            for (let i = 0; i < bitArray.length; i++) {
                codedArray.push(codedArray[i] ^ bitArray[i]);
            }
            return codedArray;
        }

        function stringToOrdArray(string) {
            let result = [];
            for (let i = 0; i < string.length; i++) {
                const ord = string.codePointAt(i);
                if (ord < 128) {
                    result.push(VARICODE.indexOf(string[i]) + 2)
                } else {
                    result.push(ord + 2);
                    if (ord > 0xffff) i++;
                }
            }
            return result;
        }

        function packBitArray(bitArray, length) {
            const result = [];
            let currentInt = 0;
            let bitCount = 0;

            for (let i = 0; i < bitArray.length; i++) {
                currentInt = (currentInt << 1) | bitArray[i];
                bitCount++;

                if (bitCount === length) {
                    result.push(currentInt);
                    currentInt = 0;
                    bitCount = 0;
                }
            }

            if (bitCount > 0) {
                while (bitCount < length) {
                    currentInt = currentInt << 1;
                    bitCount++;
                }
                result.push(currentInt);
            }

            return result;
        }

        function qpskEncode(bitArray) {
            let phase = 0;
            let symbols = [0];
            let packed = packBitArray(bitArray, 2)
            for (let e of packed) {
                phase = (phase + e) % 4
                symbols.push(phase)
            }
            return symbols
        }

        function psk8Encode(bitArray) {
            let phase = 0;
            let symbols = [0];
            let packed = packBitArray(bitArray, 3)
            for (let e of packed) {
                phase = (phase + e) % 8
                symbols.push(phase)
            }
            return symbols
        }

        function formatSigned(v, significant) {
            return v < 0 ? v.toFixed(significant) : "+" + v.toFixed(significant);
        }


        function encodeWithParity(n) {
            if (!Number.isInteger(n) || n < 0) return -1; // 确保输入为非负整数
            let ones = 0;
            let temp = n;
            while (temp) {
                ones += temp & 1;
                temp >>>= 1;
            }
            const parity = ones % 2 === 0 ? 0 : 1; // 偶校验规则
            return (n << 1) | parity; // 左移后设置最低位为校验位
        }

        function decodeAndVerify(m) {
            if (!Number.isInteger(m) || m < 0) return -1; // 确保输入为非负整数
            const nCandidate = m >>> 1; // 无符号右移获取原始左移后的值
            const receivedParity = m & 1; // 提取接收到的校验位
            // 计算原始值的奇偶性
            let ones = 0;
            let temp = nCandidate;
            while (temp) {
                ones += temp & 1;
                temp >>>= 1;
            }
            const expectedParity = ones % 2 === 0 ? 0 : 1;
            return expectedParity === receivedParity ? nCandidate : -1;
        }

        function secondsToHms(seconds) {
            if (typeof seconds !== 'number' || seconds < 0) {
                return "00:00:00"; // 或者抛出错误，取决于你的需求
            }

            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const remainingSeconds = Math.floor(seconds % 60);

            const formattedHours = String(hours).padStart(2, '0');
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(remainingSeconds).padStart(2, '0');

            return `${formattedHours}:${formattedMinutes}:${formattedSeconds}`;
        }

        function clamp(value, min, max) {
            // 确保 min <= max
            if (min > max) {
                [min, max] = [max, min]; // 交换 min 和 max 的值
            }

            // 如果 value 小于 min，则返回 min
            if (value < min) {
                return min;
            }

            // 如果 value 大于 max，则返回 max
            if (value > max) {
                return max;
            }

            // 否则，value 在 min 和 max 之间，直接返回 value
            return value;
        }

        class FibonacciDecoder {
            constructor(callback) {
                this.fibonacciSequence = fib;
                this.bitBuffer = [];
                this.callback = callback;
            }

            feed(bit) {
                this.bitBuffer.push(bit);

                // 检测结束标志
                if (this.bitBuffer.length >= 2 && this.bitBuffer[this.bitBuffer.length - 1] === 1 && this.bitBuffer[this.bitBuffer.length - 2] === 1) {
                    try {
                        this._decode();
                    } catch (IndexError) {
                        // 忽略 IndexError 异常
                    }
                    this.bitBuffer = []; // 清空 bitBuffer
                }

                if (this.bitBuffer.length > 32) {
                    this.bitBuffer = []; // 清空 bitBuffer
                }
            }

            _decode() {
                let total = 0;
                for (let i = 0; i < this.bitBuffer.length - 1; i++) {
                    total += this.fibonacciSequence[i] * this.bitBuffer[i];
                }

                this.callback(total);
            }
        }

        // ========== 1. 1D DCT 与 IDCT ==========
        function dct1d(vector) {
            const N = vector.length;
            let result = new Array(N).fill(0);
            for (let k = 0; k < N; k++) {
                let sum = 0;
                for (let n = 0; n < N; n++) {
                    sum += vector[n] * Math.cos(Math.PI * (n + 0.5) * k / N);
                }
                let alpha = k === 0 ? Math.sqrt(1 / N) : Math.sqrt(2 / N);
                result[k] = alpha * sum;
            }
            return result;
        }

        function idct1d(vector) {
            const N = vector.length;
            let result = new Array(N).fill(0);
            for (let n = 0; n < N; n++) {
                let sum = 0;
                for (let k = 0; k < N; k++) {
                    let alpha = k === 0 ? Math.sqrt(1 / N) : Math.sqrt(2 / N);
                    sum += alpha * vector[k] * Math.cos(Math.PI * (n + 0.5) * k / N);
                }
                result[n] = sum;
            }
            return result;
        }

        // ========== 2. 2D DCT/IDCT（针对 8×8 块，Y 通道） ==========
        function dct2dBlock(block) {
            const N = BLOCK_SIZE_Y;
            let temp = [];
            for (let i = 0; i < N; i++) {
                temp[i] = dct1d(block[i]);
            }
            let result = [];
            for (let j = 0; j < N; j++) {
                let col = [];
                for (let i = 0; i < N; i++) {
                    col.push(temp[i][j]);
                }
                let dctCol = dct1d(col);
                for (let i = 0; i < N; i++) {
                    if (!result[i]) result[i] = new Array(N);
                    result[i][j] = dctCol[i];
                }
            }
            return result;
        }

        function idct2dBlock(block) {
            const N = BLOCK_SIZE_Y;
            let temp = [];
            for (let j = 0; j < N; j++) {
                let col = [];
                for (let i = 0; i < N; i++) {
                    col.push(block[i][j]);
                }
                let idctCol = idct1d(col);
                for (let i = 0; i < N; i++) {
                    if (!temp[i]) temp[i] = new Array(N);
                    temp[i][j] = idctCol[i];
                }
            }
            let result = [];
            for (let i = 0; i < N; i++) {
                result[i] = idct1d(temp[i]);
            }
            return result;
        }

        // ========== 3. 2D DCT/IDCT（针对 4×4 块，色度通道） ==========
        function dct2dBlock4(block) {
            const N = BLOCK_SIZE_CHROMA;
            let temp = [];
            for (let i = 0; i < N; i++) {
                temp[i] = dct1d(block[i]);
            }
            let result = [];
            for (let j = 0; j < N; j++) {
                let col = [];
                for (let i = 0; i < N; i++) {
                    col.push(temp[i][j]);
                }
                let dctCol = dct1d(col);
                for (let i = 0; i < N; i++) {
                    if (!result[i]) result[i] = new Array(N);
                    result[i][j] = dctCol[i];
                }
            }
            return result;
        }

        function idct2dBlock4(block) {
            const N = BLOCK_SIZE_CHROMA;
            let temp = [];
            for (let j = 0; j < N; j++) {
                let col = [];
                for (let i = 0; i < N; i++) {
                    col.push(block[i][j]);
                }
                let idctCol = idct1d(col);
                for (let i = 0; i < N; i++) {
                    if (!temp[i]) temp[i] = new Array(N);
                    temp[i][j] = idctCol[i];
                }
            }
            let result = [];
            for (let i = 0; i < N; i++) {
                result[i] = idct1d(temp[i]);
            }
            return result;
        }

        // ========== 4. 上采样 4×4 到 8×8（最近邻复制） ==========
        function upsample4to8(block4) {
            const N = BLOCK_SIZE_CHROMA;
            const result = [];
            for (let i = 0; i < N * 2; i++) {
                result[i] = new Array(N * 2);
                for (let j = 0; j < N * 2; j++) {
                    result[i][j] = block4[Math.floor(i / 2)][Math.floor(j / 2)];
                }
            }
            return result;
        }

        // ========== 5. YCbCr 转 RGB ==========
        function convertYCbCrToRGB(Y, Cb, Cr) {
            // BT.601 标准转换
            let R = Y + 1.402 * (Cr - 128);
            let G = Y - 0.344136 * (Cb - 128) - 0.714136 * (Cr - 128);
            let B = Y + 1.772 * (Cb - 128);
            R = Math.round(Math.max(0, Math.min(255, R)));
            G = Math.round(Math.max(0, Math.min(255, G)));
            B = Math.round(Math.max(0, Math.min(255, B)));
            return [R, G, B];
        }

        // ========== 6. 下采样色度通道 ==========
        // 将 IMG_SIZE×IMG_SIZE 色度通道下采样为 (IMG_SIZE/2)×(IMG_SIZE/2)
        function downsampleChroma(channel) {
            const result = [];
            for (let i = 0; i < IMG_SIZE; i += 2) {
                let row = [];
                for (let j = 0; j < IMG_SIZE; j += 2) {
                    let sum = channel[i][j] + channel[i][j + 1] + channel[i + 1][j] + channel[i + 1][j + 1];
                    row.push(sum / 4);
                }
                result.push(row);
            }
            return result;
        }

        // ========== 7. 图片上传与预处理 ==========

        const sourceCanvas = document.getElementById('sourceCanvas');
        sourceCanvas.width = IMG_SIZE;
        sourceCanvas.height = IMG_SIZE;
        const reconCanvas = document.getElementById('reconCanvas');
        reconCanvas.width = IMG_SIZE;
        reconCanvas.height = IMG_SIZE;
        const sourceCtx = sourceCanvas.getContext('2d');
        const reconCtx = reconCanvas.getContext('2d');
        reconCtx.imageSmoothingEnabled = false;
        const statusDiv = document.getElementById('status');

        class DCTGenerator {
            static generate(img) {
                const cropSize = Math.min(img.width, img.height);
                const offsetX = (img.width - cropSize) / 2;
                const offsetY = (img.height - cropSize) / 2;
                sourceCtx.drawImage(img, offsetX, offsetY, cropSize, cropSize, 0, 0, IMG_SIZE, IMG_SIZE);
                const imgData = sourceCtx.getImageData(0, 0, IMG_SIZE, IMG_SIZE);
                let YMatrix = [], CbMatrix = [], CrMatrix = [];
                for (let i = 0; i < IMG_SIZE; i++) {
                    let rowY = [], rowCb = [], rowCr = [];
                    for (let j = 0; j < IMG_SIZE; j++) {
                        const idx = (i * IMG_SIZE + j) * 4;
                        const R = imgData.data[idx];
                        const G = imgData.data[idx + 1];
                        const B = imgData.data[idx + 2];
                        const Y = 0.299 * R + 0.587 * G + 0.114 * B;
                        const Cb = 128 - 0.168736 * R - 0.331264 * G + 0.5 * B;
                        const Cr = 128 + 0.5 * R - 0.418688 * G - 0.081312 * B;
                        rowY.push(Y);
                        rowCb.push(Cb);
                        rowCr.push(Cr);
                    }
                    YMatrix.push(rowY);
                    CbMatrix.push(rowCb);
                    CrMatrix.push(rowCr);
                }
                const CbDown = downsampleChroma(CbMatrix);
                const CrDown = downsampleChroma(CrMatrix);
                const blocksPerRow = IMG_SIZE / BLOCK_SIZE_Y;
                const blocksPerCol = IMG_SIZE / BLOCK_SIZE_Y;
                let quadrupleList = [];
                for (let by = 0; by < blocksPerCol; by++) {
                    for (let bx = 0; bx < blocksPerRow; bx++) {
                        let blockY = [];
                        for (let i = 0; i < BLOCK_SIZE_Y; i++) {
                            let row = [];
                            for (let j = 0; j < BLOCK_SIZE_Y; j++) {
                                row.push(YMatrix[by * BLOCK_SIZE_Y + i][bx * BLOCK_SIZE_Y + j]);
                            }
                            blockY.push(row);
                        }
                        const dctY = dct2dBlock(blockY);
                        for (let i = 0; i < BLOCK_SIZE_Y; i++) {
                            for (let j = 0; j < BLOCK_SIZE_Y; j++) {
                                quadrupleList.push({
                                    type: "Y",
                                    blockX: bx,
                                    blockY: by,
                                    idx: i * BLOCK_SIZE_Y + j,
                                    value: dctY[i][j]
                                });
                            }
                        }
                        let blockCb = [], blockCr = [];
                        for (let i = 0; i < BLOCK_SIZE_CHROMA; i++) {
                            let rowCb = [], rowCr = [];
                            for (let j = 0; j < BLOCK_SIZE_CHROMA; j++) {
                                rowCb.push(CbDown[by * BLOCK_SIZE_CHROMA + i][bx * BLOCK_SIZE_CHROMA + j]);
                                rowCr.push(CrDown[by * BLOCK_SIZE_CHROMA + i][bx * BLOCK_SIZE_CHROMA + j]);
                            }
                            blockCb.push(rowCb);
                            blockCr.push(rowCr);
                        }
                        const dctCb = dct2dBlock4(blockCb);
                        const dctCr = dct2dBlock4(blockCr);
                        for (let i = 0; i < BLOCK_SIZE_CHROMA; i++) {
                            for (let j = 0; j < BLOCK_SIZE_CHROMA; j++) {
                                quadrupleList.push({
                                    type: "Cb",
                                    blockX: bx,
                                    blockY: by,
                                    idx: i * BLOCK_SIZE_CHROMA + j,
                                    value: dctCb[i][j]
                                });
                                quadrupleList.push({
                                    type: "Cr",
                                    blockX: bx,
                                    blockY: by,
                                    idx: i * BLOCK_SIZE_CHROMA + j,
                                    value: dctCr[i][j]
                                });
                            }
                        }
                    }
                }
                function getValue(a) {
                    if (a.idx === 0) {
                        return a.type === 'Y' ? Math.abs(a.value - 128 * BLOCK_SIZE_Y) :
                            Math.abs(a.value - 128 * BLOCK_SIZE_CHROMA) * 2;
                    } else return Math.abs(a.value);
                }
                quadrupleList.sort((a, b) => getValue(b) - getValue(a)).forEach(sample => {
                    if (sample.idx === 0) {
                        if (sample.type === 'Y') sample.value -= 128 * BLOCK_SIZE_Y;
                        else sample.value -= 128 * BLOCK_SIZE_CHROMA;
                    }
                });
                return quadrupleList;
            }
        }

        // ========== 8. 封装重构器对象：ColorDCTReconstructor ==========
        class ColorDCTReconstructor {
            /**
             * @param {HTMLCanvasElement} canvas 用于显示重构结果的 canvas 元素
             * 默认图像大小 IMG_SIZE×IMG_SIZE, Y 块为 BLOCK_SIZE_Y×BLOCK_SIZE_Y, 色度块为 BLOCK_SIZE_CHROMA×BLOCK_SIZE_CHROMA
             */
            constructor(canvas, imageWidth = IMG_SIZE, imageHeight = IMG_SIZE, blockSizeY = BLOCK_SIZE_Y, blockSizeChroma = BLOCK_SIZE_CHROMA) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.imageWidth = imageWidth;
                this.imageHeight = imageHeight;
                this.blockSizeY = blockSizeY;
                this.blockSizeChroma = blockSizeChroma;
                this.blocksPerRow = imageWidth / blockSizeY;
                this.blocksPerCol = imageHeight / blockSizeY;

                // 初始化 DCT 系数矩阵（仅 DC 分量设为灰度值，AC 为 0）
                this.YBlocks = this._initBlocks(blockSizeY, 128 * blockSizeY);
                this.CbBlocks = this._initBlocks(blockSizeChroma, 128 * blockSizeChroma);
                this.CrBlocks = this._initBlocks(blockSizeChroma, 128 * blockSizeChroma);
                this.samples = 0;

                this.ctx.fillStyle = 'gray'
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }


            /**
             * 初始化指定大小的块矩阵，DC 分量设为给定值，其余为 0
             * @param {number} blockSize 块大小
             * @param {number} dcValue DC 分量初始值
             */
            _initBlocks(blockSize, dcValue) {
                const blocks = [];
                const blocksPerRow = this.imageWidth / blockSize;
                const blocksPerCol = this.imageHeight / blockSize;

                for (let by = 0; by < blocksPerCol; by++) {
                    blocks[by] = [];
                    for (let bx = 0; bx < blocksPerRow; bx++) {
                        const block = [];
                        for (let i = 0; i < blockSize; i++) {
                            const row = new Array(blockSize).fill(0);
                            if (i === 0) row[0] = dcValue; // 仅设置 DC 分量
                            block.push(row);
                        }
                        blocks[by][bx] = block;
                    }
                }
                return blocks;
            }

            /**
             * 添加一个 DCT 四元组样本，更新对应块的系数，进行 IDCT 重构后转换为 RGB 更新到 canvas
             * @param {Object} sample 四元组数据，字段包括 type, blockX, blockY, idx, value
             */
            addSample(sample) {
                if (!isValidSample(sample)) return; // invaild
                const bx = sample.blockX;
                const by = sample.blockY;
                if (sample.type === "Y") {
                    const row = Math.floor(sample.idx / this.blockSizeY);
                    const col = sample.idx % this.blockSizeY;
                    this.YBlocks[by][bx][row][col] = sample.value;
                } else if (sample.type === "Cb") {
                    const row = Math.floor(sample.idx / this.blockSizeChroma);
                    const col = sample.idx % this.blockSizeChroma;
                    this.CbBlocks[by][bx][row][col] = sample.value;
                } else if (sample.type === "Cr") {
                    const row = Math.floor(sample.idx / this.blockSizeChroma);
                    const col = sample.idx % this.blockSizeChroma;
                    this.CrBlocks[by][bx][row][col] = sample.value;
                } else return;
                // 对该块进行重构：Y 块直接 8×8 IDCT, 色度块 4×4 IDCT 后上采样到 8×8
                const spatialY = idct2dBlock(this.YBlocks[by][bx]);
                const spatialCb4 = idct2dBlock4(this.CbBlocks[by][bx]);
                const spatialCr4 = idct2dBlock4(this.CrBlocks[by][bx]);
                const spatialCb = upsample4to8(spatialCb4);
                const spatialCr = upsample4to8(spatialCr4);

                // 将该块（8×8）逐像素转换 YCbCr → RGB
                const blockImageData = this.ctx.createImageData(this.blockSizeY, this.blockSizeY);
                for (let i = 0; i < this.blockSizeY; i++) {
                    for (let j = 0; j < this.blockSizeY; j++) {
                        let Y = spatialY[i][j];
                        let Cb = spatialCb[i][j];
                        let Cr = spatialCr[i][j];
                        const [R, G, B] = convertYCbCrToRGB(Y, Cb, Cr);
                        const index = (i * this.blockSizeY + j) * 4;
                        blockImageData.data[index] = R;
                        blockImageData.data[index + 1] = G;
                        blockImageData.data[index + 2] = B;
                        blockImageData.data[index + 3] = 255;
                    }
                }
                this.ctx.putImageData(blockImageData, bx * this.blockSizeY, by * this.blockSizeY);
                this.samples++;
            }
        }


        class ImgSampleParser {
            constructor() {
                this.meta = {}
                this.onSample = null;
                this.state = 0;
            }

            feed(symbol) {
                switch (symbol & 1) {
                    case 1:
                        this.meta = symbolToSampleMeta(symbol)
                        this.state = 1
                        break;

                    case 0:
                        if (this.state == 1) {
                            let value = symbolToSample(symbol, this.meta)
                            this.onSample({
                                ...this.meta,
                                value: value
                            })
                            this.state = 0;
                        }

                    default:
                        break;
                }
            }
        }

        class ConstellationRecorder {
            constructor(maxLen) {
                this.maxLen = Math.max(1, maxLen);
                this.samples = [];
            }

            addSample(i, q) {
                this.samples.push([i, q])
                while (this.samples.length > this.maxLen) this.samples.shift()
            }

            getSamples() {
                return this.samples
            }

            clear() {
                this.samples = []
            }
        }

        class Modulator {
            constructor() {
                this.baudRate = 50;
                this.carrierFreq = 16000;
                this.onStop = null;
                this.bits = 0
            }

            setOnStop(onStop) {
                this.onStop = onStop;
            }

            setBaudRate() { this.baudRate = baudRate; }
            setCarrierFreq() { this.carrierFreq = carrierFreq; }
            getBitrate() {
                return this.baudRate;
            }
            transmit(audioCtx, bitArray) {

            }

            stop() {
                if (this.onStop) this.onStop();
            }

            get bitsPerSymbol() {
                return 1;
            }

            get totalBits() {
                return this.bits;
            }
        }

        class GFSKModulator extends Modulator {
            constructor() {
                super();
            }

            transmit(audioCtx, bitArray) {
                const mod = new AudioWorkletNode(audioCtx, 'mod')
                mod.port.postMessage({ type: "baudRate", baudRate: this.baudRate })
                mod.port.postMessage({ type: "data", data: bitArray })
                this.bits = bitArray.length

                const convolver = audioCtx.createConvolver();
                const filter = createGFSKFilter(this.baudRate);
                convolver.buffer = filter;

                const freqDeviation = audioCtx.createGain();
                freqDeviation.gain.value = 170.778026716646371 * this.baudRate * 0.25;
                const oscillator = audioCtx.createOscillator();
                oscillator.frequency.value = this.carrierFreq;
                const gainNode = audioCtx.createGain();
                gainNode.gain.value = 0.5;

                mod.connect(convolver)
                convolver.connect(freqDeviation);
                freqDeviation.connect(oscillator.frequency);
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination, 0, 0);
                oscillator.start();

                let symbolTime = 1 / this.baudRate;

                oscillator.stop(audioCtx.currentTime + symbolTime * bitArray.length);

                oscillator.onended = () => {
                    if (this.onStop) this.onStop();
                }

                this.oscillator = oscillator;
                return oscillator;
            }

            stop() {
                super.stop();
                if (this.oscillator) this.oscillator.stop();
            }
        }

        class MFSKModulator extends Modulator {
            constructor(order) {
                super();
                this.order = order;
                this.bitsPer = Math.log2(order)
            }

            transmit(audioCtx, bitArray) {
                let packed = packBitArray(bitArray, this.bitsPer)

                const mod = new AudioWorkletNode(audioCtx, 'mod')
                mod.port.postMessage({ type: "baudRate", baudRate: this.baudRate })
                mod.port.postMessage({ type: "data", data: packed })
                mod.port.postMessage({
                    type: "symbolMap", symbolMap: this.distributePoints(this.order, -1, 1)
                })
                this.bits = bitArray.length

                const convolver = audioCtx.createConvolver();
                const filter = createGFSKFilter(this.baudRate);
                convolver.buffer = filter;

                const freqDeviation = audioCtx.createGain();
                freqDeviation.gain.value = 170.778026716646371 * this.baudRate * 0.25;
                const oscillator = audioCtx.createOscillator();
                oscillator.frequency.value = this.carrierFreq;
                const gainNode = audioCtx.createGain();
                gainNode.gain.value = 0.5;

                mod.connect(convolver)
                convolver.connect(freqDeviation);
                freqDeviation.connect(oscillator.frequency);
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination, 0, 0);
                oscillator.start();

                let symbolTime = 1 / this.baudRate;

                oscillator.stop(audioCtx.currentTime + symbolTime * packed.length);

                oscillator.onended = () => {
                    if (this.onStop) this.onStop();
                }

                this.oscillator = oscillator;
                return oscillator;
            }

            stop() {
                super.stop();
                if (this.oscillator) this.oscillator.stop();
            }

            get bitsPerSymbol() {
                return this.bitsPer;
            }

            distributePoints(numPoints, start, end) {
                // 如果点的数量小于2，直接返回空数组
                if (numPoints < 2) {
                    return {};
                }

                // 如果点的数量为2，直接返回起始点和结束点
                if (numPoints === 2) {
                    return { 0: [-1, 0], 1: [1, 0] };
                }

                // 计算每个区间的长度
                const intervalLength = (end - start) / (numPoints - 1);

                // 创建一个数组来存储分割点
                const points = { 0: [start, 0] }; // 第一个点是起始点

                // 计算中间的分割点
                for (let i = 1; i < numPoints - 1; i++) {
                    const point = start + intervalLength * i;
                    points[i] = [point, 0];
                }

                // 最后一个点是结束点
                points[numPoints - 1] = [end, 0];

                return points;
            }

        }

        class FSK4Modulator extends MFSKModulator {
            constructor() {
                super(4);
            }
        }

        class BPSKModulator extends Modulator {
            transmit(audioCtx, bitArray) {
                // differential coding
                let codedArray = differentialEncoding(bitArray)
                console.log(codedArray)

                let startSync = []
                for (let i = 0; i < this.baudRate * 0.5; i++) {
                    startSync.push(...[1, 0])
                }


                codedArray = startSync.concat(codedArray)
                this.bits = codedArray.length

                const mod = new AudioWorkletNode(audioCtx, 'mod')
                mod.port.postMessage({ type: "baudRate", baudRate: this.baudRate })
                mod.port.postMessage({ type: "data", data: codedArray })

                const convolver = audioCtx.createConvolver();
                const filter = new Float32Array(rrcosFilter(sampleRate, this.baudRate, 0.5)[0]);
                const buffer = audioCtx.createBuffer(1, filter.length, sampleRate);
                buffer.copyToChannel(filter, 0);
                convolver.buffer = buffer;

                this.mixer = audioCtx.createOscillator();
                this.mixer.frequency.value = this.carrierFreq;

                const gainNode = audioCtx.createGain();
                gainNode.gain.value = 100;

                const multiplier = audioCtx.createGain();
                multiplier.gain.value = 0;

                mod.connect(convolver)
                convolver.connect(gainNode);
                this.mixer.connect(multiplier.gain);
                gainNode.connect(multiplier);
                multiplier.connect(audioCtx.destination, 0, 0);

                this.mixer.start();
                this.mixer.stop(audioCtx.currentTime + symbolTime * codedArray.length);


                this.mixer.onended = () => {
                    if (this.onStop) this.onStop();
                }

                return this.mixer;
            }

            stop() {
                super.stop();
                if (this.mixer) this.mixer.stop();
            }
        }

        class QPSKModulator extends Modulator {
            transmit(audioCtx, bitArray) {
                // differential coding
                let codedArray = qpskEncode(bitArray)
                console.log(codedArray)

                let startSync = []
                for (let i = 0; i < this.baudRate * 0.5; i++) {
                    startSync.push(...[0, 2])
                }


                codedArray = startSync.concat(codedArray)
                this.bits = codedArray.length * this.bitsPerSymbol


                const mod = new AudioWorkletNode(audioCtx, 'mod', { outputChannelCount: [2] })
                mod.port.postMessage({ type: "baudRate", baudRate: this.baudRate })
                mod.port.postMessage({ type: "data", data: codedArray })
                mod.port.postMessage({
                    type: "symbolMap", symbolMap: {
                        0: [1, 1],
                        1: [-1, 1],
                        2: [-1, -1],
                        3: [1, -1]
                    }
                })
                mod.port.onmessage = evt => {
                    if (evt.data.type === "stop") {
                        this.stop();
                    }
                }
                console.log(codedArray)


                const convolver = audioCtx.createConvolver();
                const filter = new Float32Array(rrcosFilter(sampleRate, this.baudRate, 0.5)[0]);
                const buffer = audioCtx.createBuffer(1, filter.length, sampleRate);
                buffer.copyToChannel(filter, 0);
                convolver.buffer = buffer;

                this.mixer = new AudioWorkletNode(audioCtx, 'mixer', { inputChannelCount: [2], outputChannelCount: [2] });
                this.mixer.parameters.get('frequency').value = this.carrierFreq;


                const gainNode = audioCtx.createGain();
                gainNode.gain.value = 100;

                const merger = audioCtx.createChannelMerger(2)

                mod.connect(convolver)
                convolver.connect(gainNode);
                gainNode.connect(this.mixer);
                merger.connect(audioCtx.destination, 0, 0)
                this.mixer.connect(merger, 0, 0)
                this.mixer.connect(merger, 0, 1)

                this.mixer.onprocessorerror = e => { console.log(e) }

                return this.mixer;
            }

            stop() {
                super.stop();
                if (this.mixer) this.mixer.disconnect();
            }

            get bitsPerSymbol() {
                return 2;
            }
        }


        class PSK8Modulator extends Modulator {
            transmit(audioCtx, bitArray) {
                // differential coding
                let codedArray = psk8Encode(bitArray)
                console.log(codedArray)

                let startSync = []
                for (let i = 0; i < this.baudRate * 0.5; i++) {
                    startSync.push(...[0, 4])
                }

                codedArray = startSync.concat(codedArray)
                this.bits = codedArray.length * this.bitsPerSymbol

                const mod = new AudioWorkletNode(audioCtx, 'mod', { outputChannelCount: [2] })
                mod.port.postMessage({ type: "baudRate", baudRate: this.baudRate })
                mod.port.postMessage({ type: "data", data: codedArray })
                mod.port.postMessage({
                    type: "symbolMap", symbolMap: {
                        0: [1, 0],
                        1: [0.7071, 0.7071],
                        2: [0, 1],
                        3: [-0.7071, 0.7071],
                        4: [-1, 0],
                        5: [-0.7071, - 0.7071],
                        6: [0, - 1],
                        7: [0.7071, - 0.7071]
                    }
                })
                mod.port.onmessage = evt => {
                    console.log(evt.data)
                    if (evt.data.type === "stop") {
                        this.stop();
                    }
                }
                console.log(codedArray)


                const convolver = audioCtx.createConvolver();
                const filter = new Float32Array(rrcosFilter(sampleRate, this.baudRate, 0.5)[0]);
                const buffer = audioCtx.createBuffer(1, filter.length, sampleRate);
                buffer.copyToChannel(filter, 0);
                convolver.buffer = buffer;

                this.mixer = new AudioWorkletNode(audioCtx, 'mixer', { inputChannelCount: [2], outputChannelCount: [2] });
                this.mixer.parameters.get('frequency').value = this.carrierFreq;


                const gainNode = audioCtx.createGain();
                gainNode.gain.value = 100;

                const merger = audioCtx.createChannelMerger(2)

                mod.connect(convolver)
                convolver.connect(gainNode);
                gainNode.connect(this.mixer);
                merger.connect(audioCtx.destination, 0, 0)
                this.mixer.connect(merger, 0, 0)
                this.mixer.connect(merger, 0, 1)

                this.mixer.onprocessorerror = e => { console.log(e) }

                return this.mixer;
            }

            stop() {
                super.stop();
                if (this.mixer) this.mixer.disconnect();
            }

            get bitsPerSymbol() {
                return 3;
            }
        }

        // Demodulators
        const demodInfo = document.getElementById("demod-info");

        class Demodulator {
            constructor() {
                this.baudRate = 50;
                this.onSample = null;
                this.source = null
            }

            setBaudRate(baudRate) { this.baudRate = baudRate; }
            setCarrierFreq(carrierFreq) { this.carrierFreq = carrierFreq; }
            setOnSample(onSample) {
                this.onSample = onSample;
            }
            receive(source) {
                this.source = source;
            }

            stop() {
                if (this.source) this.source.mediaStream.getTracks().forEach(track => track.stop());
                if (this.onSample) this.onSample = null;
            }

            get decidePoints() {
                return []
            }
        }

        class GFSKDemodulator extends Demodulator {
            setBaudRate(baudRate) {
                this.baudRate = baudRate;
                const filter = createGFSKFilter(this.baudRate)
                if (this.convolver) this.convolver.buffer = filter;
                if (this.demod) this.demod.port.postMessage({ type: "baudRate", baudRate: baudRate })
            }
            setCarrierFreq(carrierFreq) {
                this.carrierFreq = carrierFreq;
                if (this.mixer) this.mixer.parameters.get('frequency').value = carrierFreq;
            }
            receive(source) {
                super.receive(source)
                this.mixer = new AudioWorkletNode(audioCtx, 'mixer', { outputChannelCount: [2] });
                this.convolver = audioCtx.createConvolver()
                this.demod = new AudioWorkletNode(audioCtx, 'demod')
                this.setBaudRate(this.baudRate)
                this.setCarrierFreq(this.carrierFreq)

                source.connect(this.mixer, 0)
                this.mixer.connect(this.convolver);
                this.convolver.connect(this.demod)

                this.demod.port.onmessage = (event) => {
                    if (this.onSample) this.onSample({
                        sample: [event.data.phase, 0],
                        bits: [event.data.bit]
                    })
                }
            }

            stop() {
                super.stop();
                if (this.mixer) this.mixer.disconnect();
                if (this.convolver) this.convolver.disconnect();
                if (this.demod) this.demod.disconnect();
            }

            get decidePoints() {
                return [
                    {
                        i: 1, q: 0, label: "1"
                    },
                    {
                        i: -1, q: 0, label: "0"
                    }]
            }
        }

        class FSK4Demodulator extends Demodulator {
            setBaudRate(baudRate) {
                this.baudRate = baudRate;
                const filter = createGFSKFilter(this.baudRate)
                if (this.convolver) this.convolver.buffer = filter;
                if (this.demod) this.demod.port.postMessage({ type: "baudRate", baudRate: baudRate })
            }
            setCarrierFreq(carrierFreq) {
                this.carrierFreq = carrierFreq;
                if (this.mixer) this.mixer.parameters.get('frequency').value = carrierFreq;
            }
            receive(source) {
                super.receive(source)
                this.mixer = new AudioWorkletNode(audioCtx, 'mixer', { outputChannelCount: [2] });
                this.convolver = audioCtx.createConvolver()
                this.demod = new AudioWorkletNode(audioCtx, 'demod')
                this.setBaudRate(this.baudRate)
                this.setCarrierFreq(this.carrierFreq)

                source.connect(this.mixer, 0)
                this.mixer.connect(this.convolver);
                this.convolver.connect(this.demod)

                this.demod.port.onmessage = (event) => {
                    let phase = event.data.phase;
                    let bit1, bit2
                    if (phase < -0.5) {
                        bit1 = bit2 = 0;
                    } else if (phase < 0) {
                        bit1 = 0;
                        bit2 = 1;
                    } else if (phase < 0.5) {
                        bit1 = 1
                        bit2 = 0
                    } else {
                        bit1 = bit2 = 1
                    }

                    if (this.onSample) this.onSample({
                        sample: [phase, 0],
                        bits: [bit1, bit2]
                    })
                }
            }

            stop() {
                super.stop();
                if (this.mixer) this.mixer.disconnect();
                if (this.convolver) this.convolver.disconnect();
                if (this.demod) this.demod.disconnect();
            }

            get decidePoints() {
                return [
                    {
                        i: -1, q: 0, label: "00"
                    },
                    {
                        i: -0.333, q: 0, label: "01"
                    },
                    {
                        i: 0.333, q: 0, label: "10"
                    },
                    {
                        i: 1, q: 0, label: "11"
                    }]
            }
        }


        class BPSKDemodulator extends Demodulator {
            constructor() {
                super()
                this.lastBit = 0;
                this.debug = []
            }
            setBaudRate(baudRate) {
                this.baudRate = baudRate;
                const filter = new Float32Array(rrcosFilter(sampleRate, this.baudRate, 0.5)[0]);
                const buffer = audioCtx.createBuffer(1, filter.length, sampleRate);
                buffer.copyToChannel(filter, 0);
                if (this.convolver) this.convolver.buffer = buffer;
                if (this.demod) this.demod.port.postMessage({ type: "baudRate", baudRate: baudRate })
            }
            setCarrierFreq(carrierFreq) {
                this.carrierFreq = carrierFreq;
                if (this.mixer) this.mixer.parameters.get('frequency').value = carrierFreq;
            }
            receive(source) {
                super.receive(source)
                this.mixer = new AudioWorkletNode(audioCtx, 'mixer', { outputChannelCount: [2] });
                this.convolver = audioCtx.createConvolver()
                this.demod = new AudioWorkletNode(audioCtx, 'bpsk-demod')
                this.setBaudRate(this.baudRate)
                this.setCarrierFreq(this.carrierFreq)

                source.connect(this.mixer, 0)
                this.mixer.connect(this.convolver);
                this.convolver.connect(this.demod)

                this.demod.port.onmessage = (event) => {
                    let current = event.data.i > 0 ? 1 : 0;
                    this.debug.push(current)
                    if (this.debug.length >= 18) {
                        //console.log([...this.debug])
                        this.debug = []
                    }
                    if (this.onSample) this.onSample({
                        sample: [event.data.i, event.data.q],
                        bits: [current ^ this.lastBit]
                    })
                    this.lastBit = current;
                    demodInfo.innerText = `Gain: ${(Math.log10(event.data.gain)*20).toFixed(0)} dB | Freq: ${formatSigned(-event.data.freq/Math.PI*baudRate/2, 4)} Hz`
                }
            }

            stop() {
                super.stop();
                if (this.mixer) this.mixer.disconnect();
                if (this.convolver) this.convolver.disconnect();
                if (this.demod) this.demod.disconnect();
            }

            get decidePoints() {
                return [
                    {
                        i: 1, q: 0, label: "1"
                    },
                    {
                        i: -1, q: 0, label: "0"
                    }]
            }
        }

        class QPSKDemodulator extends Demodulator {
            constructor() {
                super()
                this.lastPhase = 0;
                this.debug = []
            }
            setBaudRate(baudRate) {
                this.baudRate = baudRate;
                const filter = new Float32Array(rrcosFilter(sampleRate, this.baudRate, 0.5)[0]);
                const buffer = audioCtx.createBuffer(1, filter.length, sampleRate);
                buffer.copyToChannel(filter, 0);
                if (this.convolver) this.convolver.buffer = buffer;
                if (this.demod) this.demod.port.postMessage({ type: "baudRate", baudRate: baudRate })
            }
            setCarrierFreq(carrierFreq) {
                this.carrierFreq = carrierFreq;
                if (this.mixer) this.mixer.parameters.get('frequency').value = carrierFreq;
            }
            receive(source) {
                super.receive(source)
                this.mixer = new AudioWorkletNode(audioCtx, 'mixer', { outputChannelCount: [2] });
                this.convolver = audioCtx.createConvolver()
                this.demod = new AudioWorkletNode(audioCtx, 'qpsk-demod')
                this.setBaudRate(this.baudRate)
                this.setCarrierFreq(this.carrierFreq)

                source.connect(this.mixer, 0)
                this.mixer.connect(this.convolver);
                this.convolver.connect(this.demod)

                this.demod.port.onmessage = (event) => {
                    let phase;
                    let i = event.data.i;
                    let q = event.data.q;
                    if (i > 0 && q > 0) { phase = 0; }
                    else if (i < 0 && q > 0) { phase = 1; }
                    else if (i < 0 && q < 0) { phase = 2; }
                    else if (i > 0 && q < 0) { phase = 3; }
                    let phaseDiff = phase - this.lastPhase;
                    if (phaseDiff < 0) phaseDiff += 4;


                    let bit2 = phaseDiff & 1
                    let bit1 = (phaseDiff >> 1) & 1
                    if (this.onSample) this.onSample({
                        sample: [event.data.i, event.data.q],
                        bits: [bit1, bit2]
                    })
                    this.lastPhase = phase;
                    demodInfo.innerText = `Gain: ${(Math.log10(event.data.gain)*20).toFixed(0)} dB | Freq: ${formatSigned(-event.data.freq/Math.PI*baudRate/2, 4)} Hz`
                
                }
            }

            stop() {
                super.stop();
                if (this.mixer) this.mixer.disconnect();
                if (this.convolver) this.convolver.disconnect();
                if (this.demod) this.demod.disconnect();
            }

            get decidePoints() {
                return [
                    {
                        i: 0.7071, q: 0.7071, label: "00"
                    },
                    {
                        i: -0.7071, q: 0.7071, label: "01"
                    },
                    {
                        i: -0.7071, q: -0.7071, label: "10"
                    },
                    {
                        i: 0.7071, q: -0.7071, label: "11"
                    }]
            }
        }

        class PSK8Demodulator extends Demodulator {
            constructor() {
                super()
                this.lastPhase = 0;
                this.debug = []
            }
            setBaudRate(baudRate) {
                this.baudRate = baudRate;
                const filter = new Float32Array(rrcosFilter(sampleRate, this.baudRate, 0.5)[0]);
                const buffer = audioCtx.createBuffer(1, filter.length, sampleRate);
                buffer.copyToChannel(filter, 0);
                if (this.convolver) this.convolver.buffer = buffer;
                if (this.demod) this.demod.port.postMessage({ type: "baudRate", baudRate: baudRate })
            }
            setCarrierFreq(carrierFreq) {
                this.carrierFreq = carrierFreq;
                if (this.mixer) this.mixer.parameters.get('frequency').value = carrierFreq;
            }
            receive(source) {
                super.receive(source)
                this.mixer = new AudioWorkletNode(audioCtx, 'mixer', { outputChannelCount: [2] });
                this.convolver = audioCtx.createConvolver()
                this.demod = new AudioWorkletNode(audioCtx, 'qpsk-demod')
                this.setBaudRate(this.baudRate)
                this.setCarrierFreq(this.carrierFreq)

                source.connect(this.mixer, 0)
                this.mixer.connect(this.convolver);
                this.convolver.connect(this.demod)

                this.demod.port.onmessage = (event) => {
                    let i = event.data.i;
                    let q = event.data.q;
                    let phase = this.getPhase(i, q)
                    let phaseDiff = phase - this.lastPhase;
                    if (phaseDiff < 0) phaseDiff += 8;


                    let bit1 = (phaseDiff >> 2) & 1
                    let bit2 = (phaseDiff >> 1) & 1
                    let bit3 = phaseDiff & 1
                    if (this.onSample) this.onSample({
                        sample: [event.data.i, event.data.q],
                        bits: [bit1, bit2, bit3]
                    })
                    this.lastPhase = phase;
                    demodInfo.innerText = `Gain: ${(Math.log10(event.data.gain)*20).toFixed(0)} dB | Freq: ${formatSigned(-event.data.freq/Math.PI*baudRate/2, 4)} Hz`
                
                }
            }

            getPhase(i, q) {
                // 计算相位角度（以弧度为单位）
                let angle = Math.atan2(q, i);
                // 转换为 0 - 360° 范围（以度数计算）
                angle = (angle * 180 / Math.PI + 360) % 360;
                // 平移 22.5° 以匹配 8PSK 的中心
                angle = (angle + 22.5) % 360;
                // 通过角度计算 8PSK 相位索引
                return Math.round(angle / 45) % 8; // 将角度转换为 0-7 之间的索引
            }

            stop() {
                super.stop();
                if (this.mixer) this.mixer.disconnect();
                if (this.convolver) this.convolver.disconnect();
                if (this.demod) this.demod.disconnect();
            }

            get decidePoints() {
                return [
                    { "i": 0.9239, "q": 0.3827, "label": "001" },
                    { "i": 0.3827, "q": 0.9239, "label": "010" },
                    { "i": -0.3827, "q": 0.9239, "label": "011" },
                    { "i": -0.9239, "q": 0.3827, "label": "100" },
                    { "i": -0.9239, "q": -0.3827, "label": "101" },
                    { "i": -0.3827, "q": -0.9239, "label": "110" },
                    { "i": 0.3827, "q": -0.9239, "label": "111" },
                    { "i": 0.9239, "q": -0.3827, "label": "000" }
                ]
            }
        }

        function isValidSample(sample) {
            if (sample.idx === 0) {
                if (sample.type === 'Y') {
                    return sample.value >= 0 && sample.value <= 2048;
                } else {
                    return sample.value >= 0 && sample.value <= 1024;
                }
            } else {
                return sample.value >= -512 && sample.value <= 512;
            }
        }


        function createHannWindow(length) {
            return [...Array(length)].map((v, i) => {
                return 0.5 * (1 - Math.cos((2 * Math.PI * i) / (length - 1)));
            });
        }

        function createGFSKFilter(baudRate, centerFreq, bt = 0.5) {
            /* 
            高斯频移键控滤波器生成函数
            参数：
            - audioCtx: Web Audio API上下文
            - sampleRate: 采样率 (Hz)
            - baudRate: 符号率 (Baud)
            - centerFreq: 中心频率 (Hz)
            - bt: 带宽时间积 (默认0.5)
            */

            // 符号周期计算
            const T = 1 / baudRate;

            // 确定滤波器持续时间（±3个符号周期）
            const numSymbols = 6;
            const totalDuration = 2 * numSymbols * T;
            const taps = Math.round(totalDuration * audioCtx.sampleRate);

            // 生成对称时间轴（精确到采样点）
            const tValues = Array.from({ length: taps }, (_, i) => {
                return (i - taps / 2 + 0.5) / audioCtx.sampleRate; // 采样点中心对齐
            });

            // 高斯脉冲参数计算
            const B = bt / T; // 3dB带宽
            const alpha = Math.sqrt(Math.LN2 / 2) / B;

            // 生成基带高斯脉冲
            const baseband = tValues.map(t => {
                return Math.exp(-Math.pow(Math.PI * t / alpha, 2));
            });

            // 创建音频缓冲区
            const buffer = audioCtx.createBuffer(1, taps, audioCtx.sampleRate);
            buffer.getChannelData(0).set(baseband);

            return buffer;
        }

        function rrcosFilter(sr, symRate, alpha = 0.25, span = 6) {
            /**
             * 生成根升余弦滤波器的冲激响应
             *
             * 参数：
             *   sr       : 采样率（samples per second）
             *   symRate : 符号率（symbols per second）
             *   alpha    : 滚降系数（默认0.25）
             *   span     : 滤波器覆盖的符号数（默认6，即滤波器长度为6个符号）
             *
             * 返回：
             *   h        : RRC滤波器冲激响应（已归一化能量）
             *   t        : 对应的时间向量
             */

            // 每个符号对应的采样点数
            const sps = Math.floor(sr / symRate);
            const Ts = 1 / symRate; // 符号间隔

            // 构造对称的时间向量，从 -span*Ts/2 到 span*Ts/2，共 span*sps+1 个点
            const t = Array.from({ length: span * sps + 1 }, (_, i) => -span * Ts / 2 + i * (span * Ts) / (span * sps));
            const h = new Array(t.length).fill(0);

            for (let i = 0; i < t.length; i++) {
                const ti = t[i];

                // 当 t=0 时，直接计算极限值
                if (Math.abs(ti) < 1e-8) {
                    h[i] = (1 - alpha) + 4 * alpha / Math.PI;
                }
                // 当 |t| 接近 Ts/(4*alpha) 时，采用特殊处理（避免除零问题）
                else if (Math.abs(Math.abs(ti) - Ts / (4 * alpha)) < 1e-8) {
                    h[i] = (alpha / Math.sqrt(2)) * (
                        (1 + 2 / Math.PI) * Math.sin(Math.PI / (4 * alpha)) +
                        (1 - 2 / Math.PI) * Math.cos(Math.PI / (4 * alpha))
                    );
                } else {
                    const numerator = Math.sin(Math.PI * ti * (1 - alpha) / Ts) + 4 * alpha * (ti / Ts) * Math.cos(Math.PI * ti * (1 + alpha) / Ts);
                    const denominator = Math.PI * ti * (1 - (4 * alpha * ti / Ts) ** 2) / Ts;
                    h[i] = numerator / denominator;
                }
            }

            return [h, t];
        }

        function toSI(n, bin = false) {
            if (n == null) return "Unknown "
            let suffix = ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];
            let base = bin ? 1024 : 1000;
            if (n < base) return parseInt(n) + " ";
            for (let i in suffix) {
                if (n < base) {
                    return bin ? n.toFixed(2) + " " + suffix[i] : n.toFixed(2) + " " + suffix[i];
                }
                n /= base;
            }
            return (n * base).toLocaleString() + " " + suffix[suffix.length - 1];
        }

        const audioInput = document.getElementById('audio-input');
        const received = document.getElementById('received');

        const bitDisplay = document.getElementById('bits');
        const progressBar = document.getElementById('progress-bar');
        const progressDiv = document.getElementById('progress');

        navigator.mediaDevices?.enumerateDevices().then(devices => {
            devices.filter(device => device.kind === 'audioinput').forEach(device => {
                const option = document.createElement('option');
                option.value = device.deviceId;
                option.innerText = device.label || `设备 ${audioInput.options.length + 1}`;
                audioInput.appendChild(option);
            })
        })

        let txBtn = document.getElementById('start-tx')
        let txUpdate = null
        let txStart = false;

        let rxBtn = document.getElementById('start')
        let imageRecvDiv = document.getElementById('imageRecvDiv')
        let isRxImage = false;
        let imgParser = null;
        let rxImage = null;
        let rxStart = false;

        let modulator = null;
        let demodulator = null;

        let drawHandle = null;

        const MODES = {
            gfsk: {
                name: 'GFSK',
                modulate: GFSKModulator,
                demodulate: GFSKDemodulator
            },
            fsk4: {
                name: '4FSK',
                modulate: FSK4Modulator,
                demodulate: FSK4Demodulator
            },
            bpsk: {
                name: 'BPSK',
                modulate: BPSKModulator,
                demodulate: BPSKDemodulator
            },
            qpsk: {
                name: 'QPSK',
                modulate: QPSKModulator,
                demodulate: QPSKDemodulator
            },
            psk8: {
                name: '8PSK',
                modulate: PSK8Modulator,
                demodulate: PSK8Demodulator
            }
        }
        let selectedMode = MODES['bpsk'];

        const constellation = new ConstellationRecorder(baudRate / 8);


        function startRxImage() {
            isRxImage = true;
            rxImage = new ColorDCTReconstructor(reconCanvas)
            imgParser = new ImgSampleParser()
            imgParser.onSample = sample => {
                // console.log(sample)
                dequantizeDCT(sample)
                if (sample.idx === 0) {
                    if (sample.type === 'Y') sample.value += 128 * BLOCK_SIZE_Y;
                    else sample.value += 128 * BLOCK_SIZE_CHROMA;
                }
                rxImage.addSample(sample)
                statusDiv.textContent = `样本 ${rxImage.samples}: \n类型: ${sample.type} \n块: (${sample.blockX},${sample.blockY}) \n索引: ${sample.idx} \n系数: ${sample.value.toFixed(0)}`;
            }
            imageRecvDiv.open = true;
        }

        function cancelRxImage() {
            isRxImage = false;
            imageRecvDiv.open = false;
        }

        async function startRx() {
            rxBtn.textContent = '停止';
            audioCtx.resume()


            let stream = await navigator.mediaDevices.getUserMedia(
                {
                    audio: {
                        sampleRate: audioCtx.sampleRate,
                        deviceId: audioInput.value,
                        echoCancellation: false,
                        noiseSuppression: false
                    },
                    video: false
                }
            )

            const decoder = new FibonacciDecoder(result => {
                const dec = baudRate >= 200 ? decodeAndVerify(result) : result;//decodeAndVerify(result)
                // console.log("解码结果:", dec);
                if (dec > 0) {
                    if (isRxImage) {
                        if (dec < 0) imgParser.state = 0;
                        else if (dec === 2000001) {
                            isRxImage = false;
                        } else {
                            if (dec >= 2000002) dec -= 2;
                            imgParser.feed(dec)
                        }
                    } else {
                        if (dec == 2000000) {
                            startRxImage()
                        } else {
                            if (dec >= 2 && dec <= 129) {
                                received.appendChild(document.createTextNode(VARICODE[dec - 2]))
                            } else {
                                received.appendChild(document.createTextNode(String.fromCodePoint(dec - 2)))
                            }
                            if (Math.abs(received.scrollHeight - received.clientHeight - received.scrollTop) < 48) {
                                received.scrollTo(0, received.scrollHeight)
                            }
                        }
                    }
                }
            })


            const source = audioCtx.createMediaStreamSource(stream)
            demodulator = new selectedMode.demodulate();
            demodulator.setBaudRate(baudRate);
            demodulator.setCarrierFreq(carrierFreq);
            demodulator.setOnSample(data => {
                // console.log(data)
                constellation.addSample(data.sample[0], data.sample[1]);
                for (let bit of data.bits)
                    decoder.feed(bit)
            })
            demodulator.receive(source)

            const canvas = document.getElementById('constellation')
            const ctx = canvas.getContext('2d')
            ctx.lineWidth = 1
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 绘制参考轴线
                ctx.strokeStyle = 'red';
                ctx.beginPath();
                ctx.moveTo(0, canvas.height / 2);
                ctx.lineTo(canvas.width, canvas.height / 2);
                ctx.stroke();

                ctx.strokeStyle = 'green';
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2, 0);
                ctx.lineTo(canvas.width / 2, canvas.height);
                ctx.stroke();


                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const plotSize = Math.min(canvas.width, canvas.height) * 0.3; // 使用画布短边的40%作为绘图区域

                // 绘制判定点
                ctx.fillStyle = 'gray';
                for (let point of demodulator.decidePoints) {
                    const x = centerX + point.i * plotSize;
                    const y = centerY - point.q * plotSize;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillText(point.label, x + 8, y - 8);
                }


                // 绘制星座点

                ctx.strokeStyle = "gray"
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height / 2, plotSize, 0, Math.PI * 2);
                ctx.stroke();

                ctx.fillStyle = 'white';

                for (let sample of constellation.getSamples()) {
                    // 将I/Q信号映射到绘图区域
                    const x = clamp(centerX + sample[0] * plotSize, 0, canvas.width);
                    const y = clamp(centerY - sample[1] * plotSize, 0, canvas.height);

                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2); // 使用准确的角度值
                    ctx.fill();
                }

                drawHandle = requestAnimationFrame(draw);
            }
            drawHandle = requestAnimationFrame(draw);
        }

        function stopRx() {
            if (drawHandle) cancelAnimationFrame(drawHandle);
            if (demodulator) demodulator.stop();
            rxBtn.textContent = '开始';
            constellation.clear();
        }

        audioCtx.audioWorklet.addModule(workletData).then(() => {
            let oscillator;

            function transmitOrdArray(ordArray, delay = 1) {
                audioCtx.resume();
                const mod = new AudioWorkletNode(audioCtx, 'mod')
                const preparedArray = baudRate >= 200 ? ordArray.map(e => encodeWithParity(e)) : ordArray;
                const sync = [2, 2, 2, 2, 2, 2, 2, 2];

                preparedArray.unshift(...sync);
                preparedArray.push(...sync);

                const bits = fibonacciEncoding(preparedArray);
                const baudRateFinal = baudRate;

                modulator = new selectedMode.modulate();
                modulator.setBaudRate(baudRate);
                modulator.setCarrierFreq(carrierFreq);
                modulator.setOnStop(() => {
                    console.log(modulator, "stopped")
                    txImageBtn.disabled = false;
                    clearInterval(interval);
                    bitDisplay.textContent = '';
                    txBtn.textContent = '发送';
                    txStart = false;
                    progressBar.style.display = 'none';
                    progressDiv.style.width = '0%';
                })
                modulator.transmit(audioCtx, bits);

                const currentTime = audioCtx.currentTime;
                const interval = setInterval(() => {
                    const sent = (audioCtx.currentTime - currentTime) * baudRateFinal * modulator.bitsPerSymbol;
                    const remainingSeconds = (modulator.totalBits - sent) / (baudRateFinal * modulator.bitsPerSymbol);
                    bitDisplay.textContent = `发送进度: ${toSI(sent / 8, true)}B / ${toSI(modulator.totalBits / 8, true)}B (剩余 ${secondsToHms(remainingSeconds)})`;
                    progressDiv.style.width = `${Math.min(100, (sent / modulator.totalBits) * 100)}%`;
                }, 100);


                txStart = true;
                txImageBtn.disabled = true;
                txBtn.textContent = '中止';
                progressBar.style.display = 'block';
            }

            txBtn.addEventListener('click', () => {
                if (!txStart) {
                    const string = document.getElementById('transmit').value;
                    transmitOrdArray(stringToOrdArray(string));
                } else {
                    modulator.stop();
                }
            });

            rxBtn.addEventListener('click', () => {
                if (!rxStart) {
                    startRx();
                } else {
                    stopRx();
                }
                rxStart = !rxStart;
            })

            document.getElementById('cancelImage').addEventListener('click', () => {
                cancelRxImage();
            })

            document.getElementById('clearTx').addEventListener('click', () => {
                document.getElementById('transmit').value = ''
            })

            document.getElementById('clearRx').addEventListener('click', () => {
                received.innerHTML = ''
            })

            document.getElementById('copyRx').addEventListener('click', () => {
                const text = received.value;
                navigator.clipboard.writeText(text);
            })

            document.getElementById('mode').addEventListener('change', () => {
                selectedMode = MODES[document.getElementById('mode').value];

                if (rxStart) {
                    stopRx();
                    startRx();
                }
            })


            const baudrateInput = document.getElementById('baudrateInput');

            baudrateInput.addEventListener('change', () => {
                let bd = parseInt(baudrateInput.value);
                setBaudRate(bd);
                constellation.maxLen = Math.max(1, bd / 8);
                if (demodulator) {
                    demodulator.setBaudRate(bd)
                }
            });

            // image transmit
            const txImageInput = document.getElementById('txImage');
            const txImageBtn = document.getElementById('txImageBtn');
            txImageBtn.addEventListener('click', () => {
                const file = txImageInput.files[0];
                if (!file) return;
                const img = new Image();
                const reader = new FileReader();
                reader.onload = function (e) {
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
                img.onload = function () {
                    let quadrupleList = DCTGenerator.generate(img);
                    console.log("四元组总数:", quadrupleList.length);

                    let ordArray = listToSymbols(quadrupleList);

                    transmitOrdArray(ordArray, 5)
                };
            })
        })


        function acquireWakelock() {
            if ('wakeLock' in navigator) {
                try {
                    navigator.wakeLock.request('screen').then(lock => {
                        lock.addEventListener('release', e => {
                            console.log("wakelock released");
                        })
                    });
                } catch (error) {
                    console.error(error);
                }
            }
        }

        document.addEventListener("visibilitychange", function () {
            if (document.visibilityState === 'visible') {
                acquireWakelock();
            }
        });
        acquireWakelock();

        const channelInput = document.getElementById('channel')
        channelInput.addEventListener('change', () => {
            let channel = parseInt(channelInput.value)

            // check channel range
            if (channel < -16 || channel == 0) {
                channel = 1
                channelInput.value = 1
            } else if (channel > 180) {
                channel = 180
                channelInput.value = 180
            } else if (channel > 21 && channel < 120) {
                channel = 120
                channelInput.value = 120
            }

            if (channel >= 1 && channel <= 21) {
                carrierFreq = 500 + 100 * (channel - 1)
            } else if (channel >= 120 && channel <= 180) {
                carrierFreq = 16000 + 100 * (channel - 120)
            } else if (channel < 0) {
                carrierFreq = 100 + 5 * channel
            }

            document.getElementById('freq').textContent = carrierFreq + ' Hz'

            // disable > 2baud if channel < 0
            if (channel < 0) {
                document.getElementById('baudrateInput').querySelectorAll('option').forEach(e => {
                    if (parseInt(e.value) > 2) e.disabled = true
                    document.getElementById('baudrateInput').value = 2
                    setBaudRate(2)
                })
            } else {
                document.getElementById('baudrateInput').querySelectorAll('option').forEach(e => {
                    e.disabled = false
                })
            }

            // if (txUpdate) {
            //     txUpdate()
            // }
            if (demodulator) {
                demodulator.setCarrierFreq(carrierFreq)
            }
        })

        function isPlainText(text) {
            // 简单判断是否为纯文本 (例如检查是否存在二进制数据)
            // 可以根据实际情况进行更复杂的判断
            for (let i = 0; i < text.length; i++) {
                const charCode = text.charCodeAt(i);
                if (charCode < 32 && charCode !== 10 && charCode !== 13 && charCode !== 9) {
                    return false; // 包含控制字符，不是纯文本
                }
            }
            return true;
        }

        const uploadTextFile = document.getElementById('uploadTextFile')

        uploadTextFile.addEventListener("input", e => {
            const file = uploadTextFile.files[0];

            if (!file) {
                alert('请选择文件');
                return;
            }

            // 检查文件大小
            const maxSize = 256 * 1024; // 256KB
            if (file.size > maxSize) {
                alert('文件大小不能超过 256KB');
                uploadTextFile.value = ''; // 清空文件选择
                return;
            }

            // 检查文件类型（读取文件内容并判断）
            const reader = new FileReader();
            reader.onload = function (event) {
                const text = event.target.result;
                // 简单判断是否为纯文本 (例如检查是否存在二进制数据)
                if (!isPlainText(text)) {
                    alert('请选择纯文本文件');
                    uploadTextFile.value = ''; // 清空文件选择
                    return;
                }

                // 文件验证通过，可以进行后续操作
                document.getElementById('transmit').value = text
            };
            reader.onerror = function () {
                alert('读取文件失败');
                uploadTextFile.value = '';
            }
            reader.readAsText(file);
        })

        document.getElementById('uploadText').addEventListener("click", e => {
            uploadTextFile.click();
        })

        // 下载图片
        document.getElementById('downloadImg').addEventListener('click', () => {
            const a = document.createElement('a');
            a.href = reconCanvas.toDataURL('image/png');
            a.download = `fsk-recv-samp${rxImage.samples}-${new Date().toISOString()}.png`;
            a.click();
        })

        function listToSymbols(quadrupleList) {
            const symbolList = [2000000, 2000000, 2000000, 2000000];
            for (let sample of quadrupleList) {
                quantizeDCT(sample)

                if (sample.value != 0) {
                    let meta = sampleMetaToSymbol(sample);
                    if (meta >= 2000000) meta += 2;
                    symbolList.push(meta)

                    let sampSymbol = sampleToSymbol(sample);
                    if (sampSymbol >= 2000000) sampSymbol += 2;
                    symbolList.push(sampSymbol)
                }
            }
            symbolList.push(...[2000001, 2000001, 2000001, 2000001])
            return symbolList
        }

        const LUMINANCE_QUANT_TABLE = [
            [16, 1, 1, 2, 2, 4, 5, 6],
            [1, 1, 1, 2, 3, 5, 6, 6],
            [1, 1, 2, 2, 4, 6, 7, 6],
            [2, 2, 2, 3, 5, 8, 8, 6],
            [2, 2, 3, 4, 6, 10, 10, 7],
            [2, 3, 4, 5, 8, 10, 11, 9],
            [4, 5, 6, 7, 10, 12, 12, 10],
            [7, 9, 9, 10, 11, 10, 10, 10]
        ];

        const CHROMINANCE_QUANT_TABLE = [
            [8, 1, 2, 3, 6, 6, 6, 6],
            [1, 2, 2, 4, 6, 6, 6, 6],
            [2, 2, 3, 6, 6, 6, 6, 6],
            [3, 4, 6, 6, 6, 6, 6, 6],
            [6, 6, 6, 6, 6, 6, 6, 6],
            [6, 6, 6, 6, 6, 6, 6, 6],
            [6, 6, 6, 6, 6, 6, 6, 6],
            [6, 6, 6, 6, 6, 6, 6, 6]
        ];

        function quantizeDCT(sample) {
            let qTable;
            if (sample.type === "Y") {
                qTable = LUMINANCE_QUANT_TABLE;
            } else {
                qTable = CHROMINANCE_QUANT_TABLE;
            }
            const qFactor = qTable[sample.idx >> 3][sample.idx & 7]; // 获取量化系数
            sample.value = Math.round(sample.value / qFactor);
        }

        function dequantizeDCT(sample) {
            let qTable;
            if (sample.type === "Y") {
                qTable = LUMINANCE_QUANT_TABLE;
            } else {
                qTable = CHROMINANCE_QUANT_TABLE;
            }
            const qFactor = qTable[sample.idx >> 3][sample.idx & 7];
            sample.value = Math.round(sample.value * qFactor);
        }
        function sampleMetaToSymbol(sample) {
            let symbol = 0;

            // Write idx (6 bits)
            symbol |= sample.idx;

            // Write type (2 bits)
            symbol <<= 2;
            switch (sample.type) {
                case "Y":
                    break;
                case "Cb":
                    symbol |= 1;
                    break;
                case "Cr":
                    symbol |= 2;
                    break;
                default:
                    symbol |= 3;
                    break;
            }

            // Write blockX (4 bits)
            symbol <<= 4;
            symbol |= sample.blockX;

            // Write blockY (4 bits)
            symbol <<= 4;
            symbol |= sample.blockY;

            // Write sync bit (1 bit)
            symbol <<= 1;
            symbol |= 1;

            return symbol;
        }

        function symbolToSampleMeta(symbol) {
            let meta = {
                type: "",
                blockX: 0,
                blockY: 0,
                idx: 0
            };

            // Remove sync bit (1 bit)
            symbol >>= 1;

            // Read blockY (4 bits)
            meta.blockY = symbol & 0b1111;
            symbol >>= 4;

            // Read blockX (4 bits)
            meta.blockX = symbol & 0b1111;
            symbol >>= 4;

            // Read type (2 bits)
            switch (symbol & 0b11) {
                case 0:
                    meta.type = "Y";
                    break;
                case 1:
                    meta.type = "Cb";
                    break;
                case 2:
                    meta.type = "Cr";
                    break;
                default:
                    meta.type = "Unknown";
                    break;
            }
            symbol >>= 2;

            // Read idx (6 bits)
            meta.idx = symbol & 0b111111;
            symbol >>= 6;

            return meta;
        }


        function sampleToSymbol(sample) {//return sample.value << 1;

            let symbol = Math.abs(sample.value)

            // Write sign bit
            symbol <<= 1;
            symbol |= Math.sign(sample.value) > 0 ? 0 : 1;

            // Write sync bit
            symbol <<= 1;
            return symbol
        }

        function symbolToSample(symbol, sample) {
            // 去掉同步位
            symbol >>= 1;

            // 提取符号位
            const signBit = symbol & 1;

            // 去掉符号位
            symbol >>= 1;

            // 还原数值
            let value = symbol;

            // 应用符号
            if (signBit === 1) {
                value = -value;
            }

            return value;
        }
    </script>
</body>

</html>