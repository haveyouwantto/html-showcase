<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å®çŸ³ä¸‰æ¶ˆ</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Arial Rounded MT Bold', 'Arial', sans-serif;
            background-color: #0a0e17;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
            touch-action: manipulation;
        }

        h1 {
            color: #ffd700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
            font-size: 2.2rem;
        }

        .game-container {
            position: relative;
            width: 100%;
            max-width: 400px;
            background-color: #121a2a;
            border-radius: 16px;
            padding: 15px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            border: 2px solid #1e2a4a;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
            width: 100%;
            aspect-ratio: 1/1;
            margin-bottom: 20px;
        }

        .tile {
            position: relative;
            background-color: #1a233a;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            cursor: pointer;
            transition: transform 0.1s, background-color 0.2s;
            box-shadow: inset 0 -4px 0 rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .tile:active {
            transform: scale(0.95);
        }

        .tile.selected {
            background-color: #3a4a7a;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
            z-index: 10;
        }

        .tile.swapping {
            z-index: 20;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .tile.matched {
            background-color: rgb(59, 227, 163);
            animation: matched 0.5s forwards;
            z-index: 30;
        }

        .tile.falling {
            z-index: 5;
            transition: transform 0.4s cubic-bezier(0.55, 0.085, 0.68, 0.53);
        }

        @keyframes matched {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.2);
                opacity: 0.8;
            }

            100% {
                transform: scale(0);
                opacity: 0;
            }
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .info-box {
            background-color: #1a233a;
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
        }

        .info-box span {
            color: #ffd700;
            margin-left: 5px;
        }

        .timer {
            color: #ff6b6b;
        }

        .controls {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }

        button {
            background: linear-gradient(to bottom, #3a4a7a, #1a233a);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 14px;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .game-over.active {
            opacity: 1;
            pointer-events: all;
        }

        .game-over h2 {
            color: #ffd700;
            font-size: 2rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .game-over p {
            font-size: 1.5rem;
            margin-bottom: 30px;
        }

        @media (max-width: 480px) {
            .tile {
                font-size: 24px;
            }

            h1 {
                font-size: 1.8rem;
            }

            .info-box {
                font-size: 1rem;
                padding: 8px 12px;
            }
        }
    </style>
</head>

<body>
    <h1>å®çŸ³ä¸‰æ¶ˆ</h1>

    <div class="game-container">
        <div class="game-info">
            <div class="info-box">åˆ†æ•°: <span id="score">0</span></div>
            <div class="info-box timer">æ—¶é—´: <span id="time">60</span>ç§’</div>
        </div>

        <div class="game-board" id="gameBoard"></div>

        <div class="controls">
            <button id="restartBtn">é‡æ–°å¼€å§‹</button>
        </div>

        <div class="game-over" id="gameOver">
            <h2>æ¸¸æˆç»“æŸ!</h2>
            <p>æœ€ç»ˆåˆ†æ•°: <span id="finalScore">0</span></p>
            <button id="playAgainBtn">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>

    <script>
        // æ¸¸æˆé…ç½®
        const config = {
            rows: 8,
            cols: 8,
            emojis: ['ğŸ’', 'ğŸ”®', 'ğŸ’', 'ğŸ‘‘', 'ğŸ’°', 'ğŸ”±', 'ğŸ’ ', 'ğŸª™'],
            gameTime: 60,
            swipeThreshold: 30 // æ»‘åŠ¨é˜ˆå€¼(åƒç´ )
        };

        // æ¸¸æˆçŠ¶æ€
        let state = {
            board: [],
            score: 0,
            timeLeft: config.gameTime,
            gameOver: false,
            timer: null,
            isAnimating: false,
            touchStart: null
        };

        // DOMå…ƒç´ 
        const gameBoard = document.getElementById('gameBoard');
        const scoreElement = document.getElementById('score');
        const timeElement = document.getElementById('time');
        const restartBtn = document.getElementById('restartBtn');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const gameOverElement = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
            if (state.timer) {
                clearInterval(state.timer);
            }

            // é‡ç½®çŠ¶æ€
            state = {
                board: [],
                score: 0,
                timeLeft: config.gameTime,
                gameOver: false,
                timer: null,
                isAnimating: false,
                touchStart: null
            };

            // æ›´æ–°UI
            scoreElement.textContent = state.score;
            timeElement.textContent = state.timeLeft;
            gameOverElement.classList.remove('active');

            // åˆ›å»ºæ¸¸æˆæ¿
            createBoard();

            // å¼€å§‹è®¡æ—¶å™¨
            state.timer = setInterval(updateTimer, 1000);
        }

        // åˆ›å»ºæ¸¸æˆæ¿
        function createBoard() {
            gameBoard.innerHTML = '';
            state.board = [];

            // è®¾ç½®ç½‘æ ¼å¸ƒå±€
            gameBoard.style.gridTemplateRows = `repeat(${config.rows}, 1fr)`;
            gameBoard.style.gridTemplateColumns = `repeat(${config.cols}, 1fr)`;

            // åˆ›å»ºæ ¼å­
            for (let row = 0; row < config.rows; row++) {
                state.board[row] = [];
                for (let col = 0; col < config.cols; col++) {
                    state.board[row][col] = getRandomEmoji();

                    const tile = createTile(row, col);
                    gameBoard.appendChild(tile);
                }
            }

            // ç¡®ä¿åˆå§‹æ¿æ²¡æœ‰åŒ¹é…é¡¹
            while (findMatches().length > 0) {
                for (let match of findMatches()) {
                    for (let cell of match) {
                        state.board[cell.row][cell.col] = getRandomEmoji();
                        updateTile(cell.row, cell.col);
                    }
                }
            }
        }

        // åˆ›å»ºå•ä¸ªæ ¼å­
        function createTile(row, col) {
            const tile = document.createElement('div');
            tile.className = 'tile';
            tile.dataset.row = row;
            tile.dataset.col = col;
            tile.textContent = state.board[row][col];

            // æ·»åŠ è§¦æ‘¸/é¼ æ ‡äº‹ä»¶
            tile.addEventListener('touchstart', handleTouchStart, { passive: false });
            tile.addEventListener('touchmove', handleTouchMove, { passive: false });
            tile.addEventListener('touchend', handleTouchEnd);
            tile.addEventListener('mousedown', handleMouseDown);

            return tile;
        }

        // æ›´æ–°æ ¼å­æ˜¾ç¤º
        function updateTile(row, col) {
            const tile = document.querySelector(`.tile[data-row="${row}"][data-col="${col}"]`);
            if (tile) {
                tile.textContent = state.board[row][col];
            }
        }

        // è·å–éšæœºemoji
        function getRandomEmoji() {
            const randomIndex = Math.floor(Math.random() * config.emojis.length);
            return config.emojis[randomIndex];
        }

        // è§¦æ‘¸å¼€å§‹
        function handleTouchStart(e) {
            if (state.gameOver || state.isAnimating) return;

            e.preventDefault();
            const tile = e.currentTarget;
            state.touchStart = {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY,
                tile: tile,
                row: parseInt(tile.dataset.row),
                col: parseInt(tile.dataset.col)
            };
        }

        // è§¦æ‘¸ç§»åŠ¨
        function handleTouchMove(e) {
            if (!state.touchStart || state.gameOver || state.isAnimating) return;
            e.preventDefault();
        }

        // è§¦æ‘¸ç»“æŸ
        function handleTouchEnd(e) {
            if (!state.touchStart || state.gameOver || state.isAnimating) return;

            const touch = e.changedTouches[0];
            const dx = touch.clientX - state.touchStart.x;
            const dy = touch.clientY - state.touchStart.y;

            // æ£€æŸ¥æ»‘åŠ¨è·ç¦»æ˜¯å¦è¶…è¿‡é˜ˆå€¼
            if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > config.swipeThreshold) {
                // æ°´å¹³æ»‘åŠ¨
                const direction = dx > 0 ? 'right' : 'left';
                handleSwipe(state.touchStart.row, state.touchStart.col, direction);
            } else if (Math.abs(dy) > config.swipeThreshold) {
                // å‚ç›´æ»‘åŠ¨
                const direction = dy > 0 ? 'down' : 'up';
                handleSwipe(state.touchStart.row, state.touchStart.col, direction);
            }

            state.touchStart = null;
        }

        // é¼ æ ‡æŒ‰ä¸‹
        function handleMouseDown(e) {
            if (state.gameOver || state.isAnimating) return;

            const tile = e.currentTarget;
            const row = parseInt(tile.dataset.row);
            const col = parseInt(tile.dataset.col);

            state.touchStart = {
                x: e.clientX,
                y: e.clientY,
                tile: tile,
                row: row,
                col: col
            };

            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }

        // é¼ æ ‡ç§»åŠ¨
        function handleMouseMove(e) {
            if (!state.touchStart || state.gameOver || state.isAnimating) return;

            const dx = e.clientX - state.touchStart.x;
            const dy = e.clientY - state.touchStart.y;

            // æ£€æŸ¥æ»‘åŠ¨è·ç¦»æ˜¯å¦è¶…è¿‡é˜ˆå€¼
            if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > config.swipeThreshold) {
                // æ°´å¹³æ»‘åŠ¨
                const direction = dx > 0 ? 'right' : 'left';
                handleSwipe(state.touchStart.row, state.touchStart.col, direction);
                cleanupMouseEvents();
            } else if (Math.abs(dy) > config.swipeThreshold) {
                // å‚ç›´æ»‘åŠ¨
                const direction = dy > 0 ? 'down' : 'up';
                handleSwipe(state.touchStart.row, state.touchStart.col, direction);
                cleanupMouseEvents();
            }
        }

        // é¼ æ ‡æŠ¬èµ·
        function handleMouseUp() {
            cleanupMouseEvents();
            state.touchStart = null;
        }

        // æ¸…ç†é¼ æ ‡äº‹ä»¶
        function cleanupMouseEvents() {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        }

        // å¤„ç†æ»‘åŠ¨
        function handleSwipe(row, col, direction) {
            let targetRow = row;
            let targetCol = col;

            switch (direction) {
                case 'up': targetRow--; break;
                case 'down': targetRow++; break;
                case 'left': targetCol--; break;
                case 'right': targetCol++; break;
            }

            // æ£€æŸ¥ç›®æ ‡ä½ç½®æ˜¯å¦æœ‰æ•ˆ
            if (targetRow >= 0 && targetRow < config.rows && targetCol >= 0 && targetCol < config.cols) {
                swapTiles(row, col, targetRow, targetCol);
            }
        }

        // äº¤æ¢ä¸¤ä¸ªæ ¼å­
        function swapTiles(row1, col1, row2, col2) {
            state.isAnimating = true;

            const tile1 = document.querySelector(`.tile[data-row="${row1}"][data-col="${col1}"]`);
            const tile2 = document.querySelector(`.tile[data-row="${row2}"][data-col="${col2}"]`);

            // æ·»åŠ äº¤æ¢åŠ¨ç”»ç±»
            tile1.classList.add('swapping');
            tile2.classList.add('swapping');

            // ä¸´æ—¶äº¤æ¢UIä½ç½®
            tile1.style.transform = `translate(${(col2 - col1) * 100}%, ${(row2 - row1) * 100}%)`;
            tile2.style.transform = `translate(${(col1 - col2) * 100}%, ${(row1 - row2) * 100}%)`;

            // åŠ¨ç”»ç»“æŸåæ›´æ–°æ•°æ®
            setTimeout(() => {
                // äº¤æ¢æ•°æ®
                const temp = state.board[row1][col1];
                state.board[row1][col1] = state.board[row2][col2];
                state.board[row2][col2] = temp;

                // æ›´æ–°UI
                tile1.textContent = state.board[row1][col1];
                tile2.textContent = state.board[row2][col2];

                // é‡ç½®transform
                tile1.style.transform = '';
                tile2.style.transform = '';

                // ç§»é™¤åŠ¨ç”»ç±»
                tile1.classList.remove('swapping');
                tile2.classList.remove('swapping');

                // æ£€æŸ¥æ˜¯å¦æœ‰åŒ¹é…
                const matches = findMatches();
                if (matches.length > 0) {
                    // æœ‰åŒ¹é…ï¼Œå¤„ç†åŒ¹é…
                    processMatches(matches);
                } else {
                    // æ²¡æœ‰åŒ¹é…ï¼Œäº¤æ¢å›æ¥
                    setTimeout(() => {
                        tile1.classList.add('swapping');
                        tile2.classList.add('swapping');

                        tile1.style.transform = `translate(${(col2 - col1) * 100}%, ${(row2 - row1) * 100}%)`;
                        tile2.style.transform = `translate(${(col1 - col2) * 100}%, ${(row1 - row2) * 100}%)`;

                        setTimeout(() => {
                            // äº¤æ¢å›æ•°æ®
                            const temp = state.board[row1][col1];
                            state.board[row1][col1] = state.board[row2][col2];
                            state.board[row2][col2] = temp;

                            // æ›´æ–°UI
                            tile1.textContent = state.board[row1][col1];
                            tile2.textContent = state.board[row2][col2];

                            // é‡ç½®transform
                            tile1.style.transform = '';
                            tile2.style.transform = '';

                            // ç§»é™¤åŠ¨ç”»ç±»
                            tile1.classList.remove('swapping');
                            tile2.classList.remove('swapping');

                            state.isAnimating = false;
                        }, 300);
                    }, 100);
                }
            }, 300);
        }

        // æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…é¡¹
        function findMatches() {
            const matches = [];
            const matchedCells = new Set();

            // æ£€æŸ¥æ°´å¹³åŒ¹é…
            for (let row = 0; row < config.rows; row++) {
                for (let col = 0; col < config.cols - 2; col++) {
                    const emoji = state.board[row][col];
                    if (emoji === state.board[row][col + 1] && emoji === state.board[row][col + 2]) {
                        const match = [{ row, col }, { row, col: col + 1 }, { row, col: col + 2 }];

                        // æ£€æŸ¥æ˜¯å¦æœ‰æ›´é•¿çš„åŒ¹é…
                        let extendCol = col + 3;
                        while (extendCol < config.cols && state.board[row][extendCol] === emoji) {
                            match.push({ row, col: extendCol });
                            extendCol++;
                        }

                        // æ·»åŠ åˆ°åŒ¹é…åˆ—è¡¨
                        matches.push(match);
                        match.forEach(cell => matchedCells.add(`${cell.row},${cell.col}`));
                        col = extendCol - 1; // è·³è¿‡å·²åŒ¹é…çš„éƒ¨åˆ†
                    }
                }
            }

            // æ£€æŸ¥å‚ç›´åŒ¹é…
            for (let col = 0; col < config.cols; col++) {
                for (let row = 0; row < config.rows - 2; row++) {
                    const emoji = state.board[row][col];
                    if (emoji === state.board[row + 1][col] && emoji === state.board[row + 2][col]) {
                        const match = [{ row, col }, { row: row + 1, col }, { row: row + 2, col }];

                        // æ£€æŸ¥æ˜¯å¦æœ‰æ›´é•¿çš„åŒ¹é…
                        let extendRow = row + 3;
                        while (extendRow < config.rows && state.board[extendRow][col] === emoji) {
                            match.push({ row: extendRow, col });
                            extendRow++;
                        }

                        // åªæ·»åŠ æœªè¢«æ°´å¹³åŒ¹é…åŒ…å«çš„å•å…ƒæ ¼
                        const newCells = match.filter(cell => !matchedCells.has(`${cell.row},${cell.col}`));
                        if (newCells.length >= 3) {
                            matches.push(newCells);
                        }

                        row = extendRow - 1; // è·³è¿‡å·²åŒ¹é…çš„éƒ¨åˆ†
                    }
                }
            }

            return matches;
        }

        // å¤„ç†åŒ¹é…é¡¹
        function processMatches(matches) {
            // è®¡ç®—åˆ†æ•°
            let score = 0
            for (const match of matches) {
                switch (match.length) {
                    case 3:
                        score += 30;
                        break
                    case 4:
                        score += 60;
                        break
                    case 5:
                        score += 120;
                        break
                    default:
                        score += match.length * 10;
                }
            }
            if (matches.length > 1) score += matches.length * 10; // æ¯ä¸ªåŒ¹é…é¢å¤–åŠ 10åˆ†
            // æ›´æ–°åˆ†æ•°
            state.score += score;
            scoreElement.textContent = state.score;

            // æ ‡è®°åŒ¹é…çš„æ ¼å­
            const matchedTiles = [];
            for (const match of matches) {
                for (const cell of match) {
                    const tile = document.querySelector(`.tile[data-row="${cell.row}"][data-col="${cell.col}"]`);
                    if (tile) {
                        tile.classList.add('matched');
                        matchedTiles.push(tile);
                    }
                }
            }

            // åŠ¨ç”»ç»“æŸåç§»é™¤åŒ¹é…çš„æ ¼å­
            setTimeout(() => {
                // æ¸…é™¤åŒ¹é…çš„æ ¼å­
                for (const tile of matchedTiles) {
                    tile.classList.remove('matched');
                    tile.textContent = '';
                }

                // ä¸‹è½æ ¼å­å¡«å……ç©ºç™½
                dropTiles();
            }, 500);
        }

        // æ ¼å­ä¸‹è½å¡«å……ç©ºç™½
        function dropTiles() {
            const fallingTiles = [];

            // ä»ä¸‹å¾€ä¸Šå¤„ç†æ¯ä¸€åˆ—
            for (let col = 0; col < config.cols; col++) {
                let emptySpaces = 0;

                for (let row = config.rows - 1; row >= 0; row--) {
                    const tile = document.querySelector(`.tile[data-row="${row}"][data-col="${col}"]`);

                    if (tile.textContent === '') {
                        emptySpaces++;
                    } else if (emptySpaces > 0) {
                        // éœ€è¦ä¸‹è½çš„æ ¼å­
                        const targetRow = row + emptySpaces;
                        state.board[targetRow][col] = state.board[row][col];
                        state.board[row][col] = '';

                        tile.dataset.row = targetRow;
                        tile.classList.add('falling');
                        tile.style.transform = `translateY(${emptySpaces * 100}%)`;

                        fallingTiles.push({
                            tile: tile,
                            targetRow: targetRow,
                            col: col
                        });
                    }
                }

                // åœ¨é¡¶éƒ¨åˆ›å»ºæ–°çš„æ ¼å­
                for (let i = 0; i < emptySpaces; i++) {
                    const row = i;
                    state.board[row][col] = getRandomEmoji();

                    const tile = document.querySelector(`.tile[data-row="${row}"][data-col="${col}"]`);
                    if (tile) {
                        tile.textContent = state.board[row][col];
                        tile.classList.add('falling');
                        tile.style.transform = `translateY(-${(emptySpaces - i) * 100}%)`;

                        fallingTiles.push({
                            tile: tile,
                            targetRow: row,
                            col: col
                        });
                    }
                }
            }

            // ä¸‹è½åŠ¨ç”»ç»“æŸå
            setTimeout(() => {
                // æ¸…é™¤æ‰€æœ‰ç°æœ‰tile
                gameBoard.innerHTML = '';

                // ä»state.boardé‡æ–°ç”Ÿæˆæ‰€æœ‰tile
                for (let row = 0; row < config.rows; row++) {
                    for (let col = 0; col < config.cols; col++) {
                        const tile = createTile(row, col);
                        gameBoard.appendChild(tile);
                    }
                }

                // æ£€æŸ¥æ˜¯å¦æœ‰æ–°çš„åŒ¹é…
                const newMatches = findMatches();
                if (newMatches.length > 0) {
                    // é€’å½’å¤„ç†è¿é”ååº”
                    setTimeout(() => {
                        processMatches(newMatches);
                    }, 100);
                } else {
                    // æ£€æŸ¥æ˜¯å¦æœ‰å¯äº¤æ¢çš„ç»„åˆ
                    if (!hasPossibleMoves()) {
                        // å¦‚æœæ²¡æœ‰å¯äº¤æ¢çš„ç»„åˆï¼Œé‡æ–°ç”Ÿæˆæ•´ä¸ªæ¸¸æˆæ¿
                        reshuffleBoard();
                    } else {
                        state.isAnimating = false;
                    }
                }
            }, 400);
        }

        // æ£€æŸ¥æ˜¯å¦æœ‰å¯äº¤æ¢çš„ç»„åˆ
        function hasPossibleMoves() {
            // æ£€æŸ¥æ°´å¹³æ–¹å‘å¯èƒ½çš„äº¤æ¢
            for (let row = 0; row < config.rows; row++) {
                for (let col = 0; col < config.cols - 1; col++) {
                    // å°è¯•äº¤æ¢ç›¸é‚»çš„ä¸¤ä¸ªemoji
                    [state.board[row][col], state.board[row][col + 1]] =
                        [state.board[row][col + 1], state.board[row][col]];

                    // æ£€æŸ¥æ˜¯å¦ä¼šäº§ç”ŸåŒ¹é…
                    const matches = findMatches();

                    // äº¤æ¢å›æ¥
                    [state.board[row][col], state.board[row][col + 1]] =
                        [state.board[row][col + 1], state.board[row][col]];

                    if (matches.length > 0) {
                        return true;
                    }
                }
            }

            // æ£€æŸ¥å‚ç›´æ–¹å‘å¯èƒ½çš„äº¤æ¢
            for (let col = 0; col < config.cols; col++) {
                for (let row = 0; row < config.rows - 1; row++) {
                    // å°è¯•äº¤æ¢ç›¸é‚»çš„ä¸¤ä¸ªemoji
                    [state.board[row][col], state.board[row + 1][col]] =
                        [state.board[row + 1][col], state.board[row][col]];

                    // æ£€æŸ¥æ˜¯å¦ä¼šäº§ç”ŸåŒ¹é…
                    const matches = findMatches();

                    // äº¤æ¢å›æ¥
                    [state.board[row][col], state.board[row + 1][col]] =
                        [state.board[row + 1][col], state.board[row][col]];

                    if (matches.length > 0) {
                        return true;
                    }
                }
            }

            return false;
        }

        // é‡æ–°ç”Ÿæˆæ¸¸æˆæ¿
        function reshuffleBoard() {
            // æ·»åŠ é‡æ’åŠ¨ç”»
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                tile.classList.add('falling');
                tile.style.transform = 'scale(0)';
                tile.style.opacity = '0';
            });

            setTimeout(() => {
                // æ¸…é™¤æ‰€æœ‰ç°æœ‰tile
                gameBoard.innerHTML = '';

                // é‡æ–°ç”Ÿæˆæ¸¸æˆæ¿æ•°æ®
                for (let row = 0; row < config.rows; row++) {
                    for (let col = 0; col < config.cols; col++) {
                        state.board[row][col] = getRandomEmoji();
                    }
                }

                // ç¡®ä¿æ²¡æœ‰åˆå§‹åŒ¹é…
                while (findMatches().length > 0) {
                    for (let match of findMatches()) {
                        for (let cell of match) {
                            state.board[cell.row][cell.col] = getRandomEmoji();
                        }
                    }
                }

                // ç¡®ä¿æœ‰å¯äº¤æ¢çš„ç»„åˆ
                if (!hasPossibleMoves()) {
                    // å¦‚æœæ²¡æœ‰å¯äº¤æ¢çš„ç»„åˆï¼Œé€’å½’è°ƒç”¨è‡ªèº«
                    setTimeout(reshuffleBoard, 100);
                    return;
                }

                // é‡æ–°ç”Ÿæˆæ‰€æœ‰tile
                for (let row = 0; row < config.rows; row++) {
                    for (let col = 0; col < config.cols; col++) {
                        const tile = createTile(row, col);
                        gameBoard.appendChild(tile);
                    }
                }

                state.isAnimating = false;
            }, 400);
        }

        // æ›´æ–°è®¡æ—¶å™¨
        function updateTimer() {
            state.timeLeft--;
            timeElement.textContent = state.timeLeft;

            if (state.timeLeft <= 0) {
                endGame();
            }
        }

        // ç»“æŸæ¸¸æˆ
        function endGame() {
            state.gameOver = true;
            clearInterval(state.timer);

            finalScoreElement.textContent = state.score;
            gameOverElement.classList.add('active');
        }

        // äº‹ä»¶ç›‘å¬
        restartBtn.addEventListener('click', initGame);
        playAgainBtn.addEventListener('click', initGame);

        // å¼€å§‹æ¸¸æˆ
        initGame();
    </script>
</body>

</html>