<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QFP 音频压缩实验</title>
    <style>
        body {
            background-color: #121212;
            /* Dark background */
            color: #ffffff;
            /* White text */
            font-family: Arial, sans-serif;
            margin: auto;
            width: 50%;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .status {
            display: flex;
            align-items: center;
            margin-top: 16px;
            width: 100%;
            justify-content: center;
        }

        #progress {
            height: 10px;
            width: 100%;
            background-color: #333;
            margin-right: 16px;
        }

        #progress-inner {
            background-color: #8e4bec;
            width: 0;
            height: 100%;
        }

        #time {
            min-width: fit-content;
        }

        h1 {
            margin-bottom: 20px;
        }

        #fileInput {
            margin-bottom: 20px;
        }

        canvas {
            width: 100%;
            height: 150px;
            background-color: #1e1e1e;
            /* Dark canvas */
            border: 1px solid #333;
            margin-top: 16px;
        }

        button,
        input::file-selector-button {
            background-color: #8e4bec;
            /* Purple button */
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s;
            margin-left: 8px;
        }

        button:hover,
        input::file-selector-button:hover {
            background-color: #6400ea;
            /* Darker purple on hover */
        }

        button:disabled {
            background-color: #444;
            cursor: default;
        }

        .btn {
            display: flex;
        }

        .gray {
            color: gray;
            font-size: smaller;
            width: 75%;
        }

        hr {
            width: 100%;
            margin: 10px;
            border: 2px solid #444;
        }

        input[type="number"] {
            background-color: transparent;
            padding: 4px;
            border: 1px solid gray;
            color: white;
        }

        @media only screen and (max-width:600px) {
            body {
                width: 95%;
            }

            .gray {
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>QFP 音频压缩实验</h1>
        <input type="file" id="fileInput" accept=".qfp" />
        <div class="btn">
            <button id="pause">播放</button>
            <button id="replay">重播</button>
        </div>
        <div class="status">
            <div id="progress">
                <div id="progress-inner"></div>
            </div>
            <div id="time">00:00 / 00:00</div>
        </div>
        <canvas id="visualizer"></canvas>

        <h2>编码器</h2>
        <input type="file" id="audioInput" accept="audio/*" />
        <div>
            QP: <input type="number" id="qp" min="0" max="63" value="32">
            <button id="encode">编码</button>
        </div>
        <hr>
        <div class="gray">
            <p>最近我突发奇想想做一个音频压缩算法。起初，我尝试将采样精度压缩到8位，但发现这样直接降低采样精度会带来明显的量化噪声。于是，我考虑保存音频的频域数据，做法是将音频转换为FFT频域表示，并将相位和幅值分别量化到8位，幅值还经过了对数处理。这样处理后，效果确实比直接在时域中压缩到8位好很多，文件大小也从原来的wav文件的38MB减半到19MB，符合预期结果。
            </p>

            <p>但相位数据的处理较为复杂。因此，我在网上搜索了一下，找了一种叫DCT的算法，便将处理流程从FFT转为DCT，结果效果差别不大，文件大小仍保持在原来的一半。于是，我开始尝试去除部分不重要的DCT系数，我设置了一个阈值，将低于此阈值的系数设为0。通过调整不同的阈值，我找到了一个在音质和压缩率之间相对平衡的数值。然而，文件大小仍没有减少，因为这些零值依然占用相同的存储空间。
            </p>

            <p>于是，我打开文件用十六进制编辑器查看，发现这些零值呈连续分布。所以，我决定采用游程编码来压缩零值序列，最后再套一层gzip以进一步压缩。效果非常显著，文件大小再次减半至9MB。之后，我注意到中频部分的音频信息被过度丢弃，因此我建立了一个表格，对不同频段设置不同的阈值，以尽量保留人耳更敏感的频段信息，这样文件最终压缩到7MB。
            </p>

            <p>最后，我想到了之前玩FM立体声发射时的思路：FM立体声通过L+R和L-R信号传输，L-R信号含有的信息相对较少。因此，我改为分别处理L+R和L-R信号，并对L-R信号设置更高的阈值。最终，文件大小压缩到6MB。到此，我发现自己无意中发现了音频压缩的经典思想。
            </p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/1.0.11/pako.min.js"></script>
    <script>

        const dpr = window.devicePixelRatio;
        const visualizerCanvas = document.getElementById('visualizer');
        visualizerCanvas.width = visualizerCanvas.clientWidth * dpr;
        visualizerCanvas.height = visualizerCanvas.clientHeight * dpr;
        const visualizerCtx = visualizerCanvas.getContext('2d');
        const canvasBuffer = document.createElement('canvas');
        canvasBuffer.width = visualizerCanvas.clientWidth * dpr;
        canvasBuffer.height = visualizerCanvas.clientHeight * dpr;
        const bufferCtx = canvasBuffer.getContext('2d');

        const ctx = new AudioContext({ latencyHint: "balanced" });

        const analyser = ctx.createAnalyser();
        analyser.smoothingTimeConstant = 0;
        analyser.fftSize = 2048; // Size of the FFT

        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);

        const timeDisplay = document.getElementById("time")
        const progressDisplay = document.getElementById("progress-inner")

        const SUB_BANDS = [
            [0, 1000, 46],
            [1000, 4000, 49],
            [4000, 8000, 52],
            [8000, 12000, 55],
            [12000, 15000, 57],
            [15000, 20000, 60],
            [20000, 192000, 999],
        ]

        function padding(num) {
            if (isNaN(num) || !isFinite(num)) {
                return '**';
            }
            if (num < 10) {
                return '0' + num;
            }
            else {
                return num;
            }
        }

        function formatTime(seconds) {
            if (isNaN(seconds) || !isFinite(seconds)) return "**:**";

            let sec = parseInt(seconds % 60);
            let minutes = seconds / 60;
            let min = parseInt(minutes % 60);
            if (minutes < 60) {
                return padding(min) + ':' + padding(sec);
            } else {
                let hours = minutes / 60;
                return padding(parseInt(hours)) + ':' + padding(min) + ':' + padding(sec);
            }
        }

        function replaceFileExtension(fileName, newExtension) {
            // Ensure the new extension starts with a dot
            if (newExtension.charAt(0) !== '.') {
                newExtension = '.' + newExtension;
            }

            // Find the last dot in the file name
            const lastDotIndex = fileName.lastIndexOf('.');

            // If there is a dot, replace the extension; otherwise, just append the new extension
            if (lastDotIndex !== -1) {
                return fileName.slice(0, lastDotIndex) + newExtension;
            } else {
                return fileName + newExtension;
            }
        }



        function add(v1, v2) {
            return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]];
        }

        function sub(v1, v2) {
            return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
        }

        function mul(v1, mul) {
            return [v1[0] * mul, v1[1] * mul, v1[2] * mul];
        }

        function colorTrans(pal, prog) {
            if (prog < 0) return formatColor(pal[0]);
            else if (prog >= 1) return formatColor(pal[pal.length - 1]);
            let i = parseInt(prog * (pal.length - 1));
            let v1 = pal[i];
            let v2 = pal[i + 1];

            try {
                let delta = sub(v2, v1);
                let percent = (prog / (1 / (pal.length - 1)));
                let int = parseInt(percent);
                percent -= int;
                let adv = mul(delta, percent);
                let result = add(v1, adv);
                return formatColor(result);
            } catch (error) {
                // console.log(i, v1, v2);
                // console.error(error);
            }
        }

        function formatColor(v) {
            return `rgb(${v[0]},${v[1]},${v[2]})`;
        }

        /**
         * Canvas
        */
        let palette = [
            [30, 30, 30],
            [142, 75, 236],
            [0xff, 0x63, 0x61],
            [0xff, 0xd3, 0x80]
        ];

        function drawFFT() {
            // visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height); // Clear canvas

            if (analyser && dataArray) {
                bufferCtx.drawImage(visualizerCanvas, 0, 0, visualizerCanvas.width, visualizerCanvas.height);

                analyser.getByteFrequencyData(dataArray); // Get frequency data
                const bufferLength = analyser.frequencyBinCount;

                const barWidth = (visualizerCanvas.width / bufferLength); // Width of each bar
                let barHeight;

                for (let i = 0; i < visualizerCanvas.width; i++) {
                    let index = Math.floor(i / visualizerCanvas.width * dataArray.length)

                    visualizerCtx.fillStyle = colorTrans(palette, dataArray[index] / 255)
                    visualizerCtx.fillRect(i, 0, 1, 1);
                }
                visualizerCtx.drawImage(canvasBuffer, 0, 1, visualizerCanvas.width, visualizerCanvas.height);
            }
            requestAnimationFrame(drawFFT); // Loop the draw function
        }
        requestAnimationFrame(drawFFT)

        // Function to perform a mini Fast Fourier Transform (FFT)
        function miniFFT(re, im) {
            var N = re.length;
            for (var i = 0; i < N; i++) {
                for (var j = 0, h = i, k = N; k >>= 1; h >>= 1)
                    j = (j << 1) | (h & 1);
                if (j > i) {
                    re[j] = [re[i], re[i] = re[j]][0]
                    im[j] = [im[i], im[i] = im[j]][0]
                }
            }
            for (var hN = 1; hN * 2 <= N; hN *= 2)
                for (var i = 0; i < N; i += hN * 2)
                    for (var j = i; j < i + hN; j++) {
                        var cos = Math.cos(Math.PI * (j - i) / hN),
                            sin = Math.sin(Math.PI * (j - i) / hN)
                        var tre = re[j + hN] * cos + im[j + hN] * sin,
                            tim = -re[j + hN] * sin + im[j + hN] * cos;
                        re[j + hN] = re[j] - tre; im[j + hN] = im[j] - tim;
                        re[j] += tre; im[j] += tim;
                    }
        }

        function miniDCT(s) {
            var N = s.length,
                K = -Math.PI / (2 * N),
                re = new Float64Array(N),
                im = new Float64Array(N);
            for (var i = 0, j = N; j > i; i++) {
                re[i] = s[i * 2]
                re[--j] = s[i * 2 + 1]
            }
            miniFFT(re, im)

            const mul = Math.sqrt(2 / N);

            for (var i = 0; i < N; i++) {
                s[i] = (re[i] * Math.cos(K * i) - im[i] * Math.sin(K * i)) * mul;
            }
            s[0] *= Math.SQRT1_2;
        }

        // Function to perform the inverse discrete cosine transform (IDCT)
        function miniIDCT(s) {
            var N = s.length,
                K = Math.PI / (2 * N),
                im = new Float64Array(N),
                re = new Float64Array(N),
                scale = Math.sqrt(2 / N);

            // Scale first coefficient differently for orthogonal normalization
            re[0] = s[0] / Math.sqrt(N);

            for (var i = 1; i < N; i++) {
                var im2 = Math.sin(i * K),
                    re2 = Math.cos(i * K);

                // Apply scaling and normalization for orthogonal IDCT
                re[i] = (s[N - i] * im2 + s[i] * re2) * scale / 2;
                im[i] = (im2 * s[i] - s[N - i] * re2) * scale / 2;
            }

            miniFFT(im, re);

            for (var i = 0; i < N / 2; i++) {
                s[2 * i] = re[i];
                s[2 * i + 1] = re[N - i - 1];
            }
        }


        function rleCompress(data) {
            const compressed = [];
            let count = 0;

            data.forEach(byte => {
                if (byte === 0) {
                    count += 1;
                } else {
                    if (count > 0) {
                        if (count >= 3) {
                            compressed.push(...this.encodeZeroRun(count)); // Encode if more than 3 zeros
                        } else {
                            compressed.push(...Array(count).fill(0)); // Write zeros as is if count <= 3
                        }
                        count = 0;
                    }
                    compressed.push(byte);
                }
            });

            // Handle trailing zeros
            if (count > 0) {
                if (count >= 3) {
                    compressed.push(...this.encodeZeroRun(count)); // Encode if more than 3 zeros
                } else {
                    compressed.push(...Array(count).fill(0)); // Write zeros as is if count <= 3
                }
            }

            return Int8Array.from(compressed);
        }

        function encodeZeroRun(count) {
            const encoded = [-128];
            count -= 2;

            while (count > 0) {
                if (count > 0xFF) {
                    encoded.push(0xFF);
                    count -= 0xFF;
                } else {
                    encoded.push(count - 1);
                    count = 0;
                }
            }
            return encoded;
        }

        // Function to decompress run-length encoded data
        function rleDecompress(data) {
            const decompressed = []; // Array to hold decompressed data
            let i = 0;

            while (i < data.length) {
                const byte = data[i];

                if (byte === -128) {
                    i += 1;
                    let zeroCount = 0;

                    // Count the number of zeros
                    while (i < data.length && (data[i] & 0xFF) === 0xFF) {
                        zeroCount += 0xFF;
                        i += 1;
                    }

                    if (i < data.length) {
                        zeroCount += (data[i] & 0xFF) + 1;
                        i += 1;
                    }

                    // Push zeros to the decompressed array
                    decompressed.push(...Array(zeroCount + 2).fill(0));
                } else {
                    decompressed.push(byte); // Add byte to decompressed array
                    i += 1;
                }
            }

            return new Int8Array(decompressed); // Return as Int8Array
        }

        function trimZeros(array) {
            // Removes trailing zeros
            let i = array.length - 1;
            while (i >= 0 && array[i] === 0) {
                i--;
            }
            return array.slice(0, i + 1);
        }

        // Function to pad an array to a target length
        function padArray(arr, targetLength) {
            const paddedArray = new Int8Array(targetLength); // Create a new Int8Array

            // Copy the original array into the new array
            const lengthToCopy = Math.min(arr.length, targetLength);
            paddedArray.set(arr.subarray(0, lengthToCopy));

            return paddedArray; // Return padded array
        }

        function quantizeAmp(amp) {
            // Quantize amplitude using log10 scaling to int8 equivalent in JavaScript
            return amp.map(value => {
                if (value === 0) {
                    return 0;
                }
                const ampQ = Math.min(127, Math.max(0, 127 + 20 * Math.log10(Math.abs(value))));
                return value < 0 ? -Math.round(ampQ) : Math.round(ampQ);
            });
        }

        // Function to dequantize amplitudes
        function dequantizeAmp(ampQ) {
            const amp = new Float32Array(ampQ.length); // Create a Float32Array

            for (let i = 0; i < ampQ.length; i++) {
                // Dequantize the amplitudes
                const amplitude = Math.pow(10, (Math.abs(ampQ[i]) - 127) / 20);
                amp[i] = ampQ[i] < 0 ? -amplitude : amplitude; // Store signed amplitude
            }

            return amp; // Return dequantized amplitudes
        }

        function roundDownToPowerOfTwo(number) {
            if (number <= 0) {
                return 0;
            }
            const power = Math.floor(Math.log2(number)) - 1;
            return Math.min(2 ** power, 65536);
        }

        function getFrameNum(sec, sampleRate, samplesPerFrame) {
            return Math.ceil((sec * sampleRate) / samplesPerFrame);
        }


        class QFPEncoder {
            constructor(audioBuffer, qp) {
                this.buffer = audioBuffer;
                this.i = 0;
                this.l = audioBuffer.getChannelData(0);
                this.r = audioBuffer.getChannelData(1);
                this.qp = qp;
            }

            encodeHeader() {
                const buffer = new ArrayBuffer(17);
                this.sampleRate = this.buffer.sampleRate;
                this.winSize = roundDownToPowerOfTwo(this.sampleRate / 16);
                this.numWins = parseInt(this.buffer.length / this.winSize);

                const diff = 63 - this.qp;

                this.subBands = [[], []];
                for (const b of SUB_BANDS) {
                    this.subBands[0].push([
                        Math.min(Math.max(b[0] / this.sampleRate * 2, 0), 1),
                        Math.min(Math.max(b[1] / this.sampleRate * 2, 0), 1),
                        Math.min(Math.max(b[2] - diff - Math.log10(this.winSize / 1024) * 10, 0), 127),
                    ]);
                    this.subBands[1].push([
                        Math.min(Math.max(b[0] / this.sampleRate * 2, 0), 1),
                        Math.min(Math.max(b[1] / this.sampleRate * 2, 0), 1),
                        Math.min(Math.max(b[2] - diff + 10 - Math.log10(this.winSize / 1024) * 10, 0), 127),
                    ]);
                }

                console.log(this.subBands);

                const view = new DataView(buffer);
                view.setUint32(0, 1095779921, true); //magic
                view.setUint8(4, 1) //version
                view.setUint32(5, this.sampleRate, true);
                view.setUint32(9, this.winSize, true);
                view.setUint32(13, this.numWins, true);
                return buffer;
            }

            encodeFrame() {
                // Process both L+R and L-R channels
                const L = this.l.slice(this.i * this.winSize, (this.i + 1) * this.winSize);
                const R = this.r.slice(this.i * this.winSize, (this.i + 1) * this.winSize);

                const winDataLPlusR = L.map((val, idx) => val + R[idx]);
                const winDataLMinusR = L.map((val, idx) => val - R[idx]);

                const encodedFrames = []

                for (let ch = 0; ch < 2; ch++) {
                    const winData = ch === 0 ? winDataLPlusR : winDataLMinusR;

                    miniDCT(winData);  // Define applyDCT with orthogonal normalization

                    // Normalize and quantize the amplitude
                    let amp = winData.map(value => value / this.winSize);
                    let ampQ = quantizeAmp(amp);  // Define quantizeAmp function based on _quantize_amp()

                    // Process sub-bands
                    for (const subBand of this.subBands[ch]) {
                        const bandStart = Math.floor(this.winSize * subBand[0]);
                        const bandEnd = Math.floor(this.winSize * subBand[1]);
                        // console.log(bandStart,bandEnd)
                        const band = ampQ.slice(bandStart, bandEnd).map(value => Math.abs(value) < subBand[2] ? 0 : value);
                        band.forEach((v, i) => ampQ[bandStart + i] = v)
                    }

                    // Trim trailing zeros
                    ampQ = trimZeros(ampQ);

                    // Limit length to 65535
                    if (ampQ.length > 65535) {
                        ampQ = ampQ.slice(0, 65535);
                    }

                    // RLE compression
                    const compressedData = rleCompress(ampQ);  // Define rleCompress function

                    // Pack length and compressed data
                    const lenArray = new ArrayBuffer(2);
                    new DataView(lenArray).setUint16(0, compressedData.byteLength, true);

                    encodedFrames.push(lenArray)
                    encodedFrames.push(compressedData.buffer);
                }
                this.i++;
                return encodedFrames;
            }

            available() {
                return this.i < this.numWins;
            }
        }

        // Class to decode QFP files
        class QFPDecoder {
            constructor(arrayBuffer) {
                // Decompress the gzipped data
                const decompressedData = pako.inflate(new Uint8Array(arrayBuffer));

                this.buffer = decompressedData.buffer; // Use the decompressed data
                this.view = new DataView(this.buffer);
                this.ptr = 0;
                this.read = 0;
                this.readHeader();
                this.generatePos();
            }

            readHeader() {
                let magic = new TextDecoder('utf-8').decode(this.buffer.slice(0, 4)); // Read magic number
                console.log("magic: " + magic);
                if (magic !== 'QFPA') throw new Error("magic not match"); // Check magic number

                this.ptr += 4; // Move pointer

                // Read version, sample rate, and window size
                this.version = this.view.getUint8(this.ptr++, true);
                this.sampleRate = this.view.getUint32(this.ptr, true);
                this.ptr += 4;
                this.winSize = this.view.getUint32(this.ptr, true);
                this.ptr += 4;
                this.numWindows = this.view.getUint32(this.ptr, true);
                this.ptr += 4;

                console.log("version: " + this.version);
                console.log("sample rate: " + this.sampleRate);
                console.log("win size:" + this.winSize);
                console.log("num win:" + this.numWindows);

                this.duration = this.numWindows * (this.winSize / this.sampleRate)
            }

            readFrame() {
                if (this.read >= this.numWindows) throw new Error("No more frames to read");

                const lr = []; // Array to hold left and right channel data
                for (let ch = 0; ch < 2; ch++) {
                    const length = this.view.getUint16(this.ptr, true); // Read length of the frame
                    this.ptr += 2; // Move pointer

                    let ampQ = new Int8Array(this.buffer.slice(this.ptr, this.ptr + length)); // Read amplitude data
                    this.ptr += length; // Move pointer

                    ampQ = rleDecompress(ampQ); // Decompress amplitude data
                    ampQ = padArray(ampQ, this.winSize); // Pad the array

                    let amp = dequantizeAmp(ampQ).map(e => e * this.winSize); // Dequantize amplitudes

                    miniIDCT(amp); // Apply IDCT

                    lr[ch] = amp; // Store channel data
                }

                const l = new Float32Array(this.winSize), r = new Float32Array(this.winSize); // Create arrays for left and right channels

                // Calculate left and right channels
                for (let i = 0; i < this.winSize; i++) {
                    l[i] = (lr[0][i] + lr[1][i]) / 2; // Left channel
                    r[i] = (lr[0][i] - lr[1][i]) / 2; // Right channel
                }

                this.read++;
                return [l, r]; // Return left and right channels
            }

            generatePos() {
                this.lookUp = [];
                for (let i = 0; i < this.numWindows; i++) {
                    this.lookUp.push(this.ptr);
                    for (let ch = 0; ch < 2; ch++) {
                        const length = this.view.getUint16(this.ptr, true); // Read length of the frame
                        this.ptr += 2 + length; // Move pointer
                    }
                }
                this.reset();
            }

            seek(frame) {
                this.ptr = 17 + this.lookUp[frame];
            }

            reset() {
                this.ptr = 17;
                this.read = 0;
            }
        }

        class QFPPlayer {
            constructor(qfp) {
                this.qfp = qfp;
                this.t = 0;
                this.started = false;
                this.nodeList = [];
                this.stopped = false;
            }

            start() {
                if (this.started) throw new Error("QFPPlayer can only be started once.");
                this.startTime = ctx.currentTime;
                this.updateProgress();

                let preloadFrames = Math.max(Math.floor(5 / (this.qfp.winSize / this.qfp.sampleRate)), 2); // Preload 5 sec
                for (let i = 0; i < preloadFrames; i++) {
                    this.playFrame();
                }
            }

            setPaused(b) {
                if (b) {
                    ctx.suspend();
                } else {
                    ctx.resume();
                }
            }

            updateProgress() {
                let currentTime = Math.min(ctx.currentTime - this.startTime, this.qfp.duration)
                let prog = currentTime / this.qfp.duration;
                timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(this.qfp.duration)}`
                progressDisplay.style.width = (prog * 100) + "%"
            }

            playFrame() {
                if (!this.stopped) {
                    const frame = this.qfp.readFrame();

                    const buffer = ctx.createBuffer(2, this.qfp.winSize, this.qfp.sampleRate)
                    const l = buffer.getChannelData(0)
                    const r = buffer.getChannelData(1)
                    l.set(frame[0])
                    r.set(frame[1])

                    const node = ctx.createBufferSource();
                    node.buffer = buffer;
                    node.onended = () => {
                        node.disconnect();
                        this.nodeList.shift();

                        if (!this.stopped) {
                            this.updateProgress();
                            this.playFrame();
                        }
                    };
                    node.connect(analyser).connect(ctx.destination)
                    node.start(this.startTime + this.t);
                    this.nodeList.push(node);
                    this.t += (1 / this.qfp.sampleRate * this.qfp.winSize)
                }
            }

            stop() {
                if (this.stopped) throw new Error("QFPPlayer already stopped.");
                for (const node of this.nodeList) {
                    node.disconnect();
                }
                this.stopped = true;
            }

            replay() {
                this.stop();
                this.t = 0;
                this.stopped = false;
                this.started = false;
                this.qfp.reset();
                this.start();
            }
        }

        let paused = true;
        let player;

        document.getElementById('fileInput').addEventListener('change', e => {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a file.'); // Alert if no file is selected
                return;
            }

            const reader = new FileReader(); // Create a FileReader

            // Read the file as an ArrayBuffer
            reader.readAsArrayBuffer(file);

            reader.onload = function (event) {
                try {
                    const arrayBuffer = event.target.result; // Get the result from the reader

                    let qfp = new QFPDecoder(arrayBuffer); // Create a new QFPDecoder
                    if (player) player.stop();
                    player = new QFPPlayer(qfp);
                    player.start();

                    // Start the audio processing
                    if (paused) pauseBtn.click();// Resume audio if paused
                } catch (error) {
                    alert("Error decoding QFP:", error);
                    throw error;
                }
            };

            reader.onerror = function (event) {
                console.error('Error reading file:', event); // Log error
                alert('Error reading file.'); // Alert on error
            };
        })

        let pauseBtn = document.getElementById('pause');   // Pause button
        pauseBtn.addEventListener('click', function () {
            paused = !paused;  // Toggle pause state

            if (paused) {
                ctx.suspend();
                pauseBtn.innerHTML = '播放';  // Set pause button text to Play
            } else {
                ctx.resume();
                pauseBtn.innerHTML = '暂停';    // Set pause button text to Pause
            }
        });

        document.getElementById('replay').addEventListener('click', e => {
            player.replay();
        })

        const encodeBtn = document.getElementById('encode')

        encodeBtn.addEventListener('click', e => {
            const fileInput = document.getElementById('audioInput');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a file.'); // Alert if no file is selected
                return;
            }
            encodeBtn.disabled = true;

            const promise = new Promise((resolve, reject) => {
                const reader = new FileReader(); // Create a FileReader

                // Read the file as an ArrayBuffer
                reader.readAsArrayBuffer(file);

                reader.onload = function (event) {
                    const arrayBuffer = event.target.result; // Get the result from the reader
                    ctx.decodeAudioData(arrayBuffer).then(data => {
                        const encoder = new QFPEncoder(data, parseInt(document.getElementById('qp').value));
                        const chunks = [];

                        // Write header
                        chunks.push(encoder.encodeHeader());

                        // Write frames
                        while (encoder.available()) {
                            for (const frame of encoder.encodeFrame()) {
                                chunks.push(frame);
                                // chunks.push(frame[1])
                            }
                        }

                        // Concatenate chunks into a single Uint8Array
                        const combinedChunks = new Uint8Array(chunks.reduce((acc, chunk) => acc + chunk.byteLength, 0));
                        let offset = 0;
                        for (const chunk of chunks) {
                            combinedChunks.set(new Uint8Array(chunk), offset);
                            offset += chunk.byteLength;
                        }

                        // Compress the combined data using pako
                        const compressedData = pako.gzip(combinedChunks);

                        // Create a Blob from the compressed data and download it as a file
                        const blob = new Blob([compressedData], { type: "application/octet-stream" });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement("a");
                        a.href = url;
                        a.download = replaceFileExtension(file.name, "qfp"); // Name of the file to download
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url); // Clean up the URL
                    }).catch(e => {
                        reject("Error decoding audio: " + e)
                    });
                };

                reader.onerror = function (event) {
                    reject('Error reading file:' + event);
                };
            })

            promise.catch(e => alert(e)).finally(() => encodeBtn.disabled = false);
        })
    </script>
</body>

</html>