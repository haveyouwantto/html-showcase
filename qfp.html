<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QFP 音频压缩实验</title>
    <style>
        body {
            background-color: #121212;
            /* Dark background */
            color: #ffffff;
            /* White text */
            font-family: Arial, sans-serif;
            margin: auto;
            width: 50%;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .status {
            display: flex;
            align-items: center;
            margin-top: 8px;
            width: 100%;
            justify-content: center;
        }

        .progress {
            height: 10px;
            width: 100%;
            background-color: #333;
            margin-right: 16px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        .progress-inner {
            background-color: #8e4bec;
            width: 0;
            height: 100%;
        }

        .encoder-container {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .time {
            min-width: fit-content;
        }

        h1 {
            margin-bottom: 20px;
        }

        #fileInput {
            margin-bottom: 20px;
        }

        #visualizer,
        #spectrum {
            width: 100%;
            height: 150px;
            background-color: #000;
            border: 1px solid #333;
            display: block;
        }

        #spectrum {
            margin-top: 16px;
            border-bottom: none;
        }

        #visualizer {
            margin-top: 0;
        }

        button,
        input::file-selector-button {
            background-color: #8e4bec;
            /* Purple button */
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s;
            margin-left: 8px;
        }

        #info {
            margin-top: 8px;
        }

        button:hover,
        input::file-selector-button:hover {
            background-color: #6400ea;
            /* Darker purple on hover */
        }

        button:disabled {
            background-color: #444;
            cursor: default;
        }

        .btn {
            display: flex;
        }

        .gray {
            color: gray;
            font-size: smaller;
            width: 75%;
        }

        hr {
            width: 100%;
            margin: 10px;
            border: 2px solid #444;
        }

        input[type="number"] {
            background-color: transparent;
            padding: 4px;
            border: 1px solid gray;
            color: white;
        }

        input[type="radio"] {
            margin: 4px;
            accent-color: #8e4bec;
            /* Purple accent for radio buttons */

            width: 16px;
            height: 16px;
        }

        input[type="checkbox"] {
            accent-color: #8e4bec;
        }

        #fileinfo {
            margin-top: 8px;
            font-size: 0.8rem;
        }

        details {
            margin-top: 16px;
            width: 100%;
            background-color: #222;
            padding: 16px;
            border-radius: 5px;
        }

        details summary {
            cursor: pointer;
            color: #8e4bec;
            /* Purple summary */
        }

        details:hover {
            outline: #8e4bec solid 1px;
        }

        .player-opt {
            display: none;
        }

        @media only screen and (max-width:600px) {
            body {
                width: 95%;
            }

            .gray {
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>QFP 音频压缩实验</h1>
        <input type="file" id="fileInput" accept=".qfp" />
        <div class="btn">
            <button id="pause">播放</button>
            <button id="replay">重播</button>
        </div>
        <div>
            <div class="player-opt" id="settings-v1">
            </div>
            <div class="player-opt" id="settings-v2">
                噪声填充：<input type="checkbox" class="player-opt-item" data-key="noise-filling" checked>
            </div>
            <div class="player-opt" id="settings-v3">
                噪声填充：<input type="checkbox" class="player-opt-item" data-key="noise-filling" checked>
            </div>
        </div>
        <div id="fileinfo"></div>
        <div id="info"></div>
        <div class="status">
            <div id="progress" class="progress">
                <div id="progress-inner" class="progress-inner"></div>
            </div>
            <div id="time" class="time">00:00 / 00:00</div>
        </div>
        <canvas id="spectrum"></canvas>
        <canvas id="visualizer"></canvas>

        <h2>编码器</h2>
        <input type="file" id="audioInput" accept="audio/*" />
        <div class="encoder-container">
            <div id="version-select">
                <input type="radio" name="version" id="v1" value="v1"> V1
                <input type="radio" name="version" id="v2" value="v2"> V2
                <input type="radio" name="version" id="v3" value="v3" checked> V3
            </div>
            <span>
                QP: <input type="number" id="qp" min="0" max="80" value="32">
            </span>
            <button id="encode">编码</button>
            <div class="status">
                <div id="encode-progress" class="progress">
                    <div id="encode-progress-inner" class="progress-inner"></div>
                </div>
                <div id="encode-time" class="time">00:00 / 00:00</div>
            </div>
        </div>
        <hr>
        <details>
            <summary>V1心得</summary>
            <div class="gray">
                <p>最近我突发奇想想做一个音频压缩算法。起初，我尝试将采样精度压缩到8位，但发现这样直接降低采样精度会带来明显的量化噪声。于是，我考虑保存音频的频域数据，做法是将音频转换为FFT频域表示，并将相位和幅值分别量化到8位，幅值还经过了对数处理。这样处理后，效果确实比直接在时域中压缩到8位好很多，文件大小也从原来的wav文件的38MB减半到19MB，符合预期结果。
                </p>

                <p>但相位数据的处理较为复杂。因此，我在网上搜索了一下，找了一种叫DCT的算法，便将处理流程从FFT转为DCT，结果效果差别不大，文件大小仍保持在原来的一半。于是，我开始尝试去除部分不重要的DCT系数，我设置了一个阈值，将低于此阈值的系数设为0。通过调整不同的阈值，我找到了一个在音质和压缩率之间相对平衡的数值。然而，文件大小仍没有减少，因为这些零值依然占用相同的存储空间。
                </p>

                <p>于是，我打开文件用十六进制编辑器查看，发现这些零值呈连续分布。所以，我决定采用游程编码来压缩零值序列，最后再套一层gzip以进一步压缩。效果非常显著，文件大小再次减半至9MB。之后，我注意到中频部分的音频信息被过度丢弃，因此我建立了一个表格，对不同频段设置不同的阈值，以尽量保留人耳更敏感的频段信息，这样文件最终压缩到7MB。
                </p>

                <p>最后，我想到了之前玩FM立体声发射时的思路：FM立体声通过L+R和L-R信号传输，L-R信号含有的信息相对较少。因此，我改为分别处理L+R和L-R信号，并对L-R信号设置更高的阈值。最终，文件大小压缩到6MB。到此，我发现自己无意中发现了音频压缩的经典思想。
                </p>
            </div>
        </details>
        <details>
            <summary>V2心得</summary>
            <div class="gray">
                <p>自从上次我鼓捣出一个音频压缩格式，命名为 <strong>QFP</strong>（Quantized Frequency
                    Packing？其实就是随手取的）之后，心里总感觉不太踏实。虽然能压缩，虽然能放出来，但……说实话，那声音一听就知道有事。</p>
                <p>首先，QFP 是基于 DCT 的，而DCT
                    的边缘效应让我听得头皮发麻：音频块和音频块之间的切口感太强，就像是剪辑没对齐的拼接视频，一听就出戏。整段音乐听起来像在翻页播放，咔哒咔哒的。其次，压缩效率也不尽如人意，就像一个节俭却舍不得扔瓶瓶罐罐的打包方式，空间没省多少，音质还受了伤。
                </p>
                <p>于是我决定来个 QFP v2 大改造计划。</p>
                <hr>
                <h3 id="-">第一刀：边缘效应，退下！</h3>
                <p>这次我换了一个更“滑”的编码方式 —— MDCT（修正型离散余弦变换）。这东西和 DCT 是远房亲戚，但最大优势是可以“块块重叠”，再配合我选用的 Vorbis 风窗函数，能把各块拼接得天衣无缝。
                </p>
                <p>原来的 DCT 压缩听起来像马赛克音频，现在的 MDCT 则像用面粉和水揉了又揉的面团，压出来的面条——丝滑流畅，再无硬边。</p>
                <hr>
                <h3 id="-">第二刀：高频像丢了魂？那就给它“塞点噪声”</h3>
                <p>不过，压缩高频的时候问题又来了。声音变得“空洞”了，像是空气被抽走了一样，塑料感特别强，听起来就像有人在水下讲电话，还拿个塑料袋套着话筒。</p>
                <p>我思来想去，决定玩个“障眼法”：噪声填充。你说高频细节被压掉了，那我干脆自己造点细节出来！</p>
                <p>具体做法也不复杂，我每隔一段（比如每64个 MDCT
                    系数）就记一下它们的强度，像在压缩包里夹一张“噪声强度说明书”。然后在解压时，把这些“指导手册”读出来，用它们生成差不多强度的高斯白噪声，再撒回原位。</p>
                <p>结果效果还不错！不过一开始频谱图看着就像方块积木搭出来的，生硬得一批，听起来也有种“马赛克味儿”的奇怪感。于是我又整了个线性插值，把噪声分布“磨皮”一下，视觉上自然了，听感上也没那么刺耳。</p>
                <hr>
                <h3 id="-">成果展示</h3>
                <p>现在这个 QFPv2，大概用 12kbps 左右就能比较准确地还原人声。为啥呢？因为人说话主要就在 0～4kHz
                    这段来回折腾，高频辅音（比如“s”“f”“sh”这些带刺儿的）本身就像沙子一样，用白噪声一糊，反而还原得更自然，听起来不但没毛病，反而比原声还“圆润”了一点。</p>
                <p>当然，要是你拿来压音乐，白噪声多、打击乐重的曲子表现还可以，用 64～80kbps 就基本能搞定。但像钢琴、小提琴这类“谐波灵魂”型乐器就吃亏了，得提高到 120~160kbps 才不失真。</p>
                <p>当然，QFPv2
                    目前还是个“科研玩具”级别的作品。没做心理声学建模，没有掩蔽效应那一套（也就是“大音量附近的我就懒得存”策略），量化也很原始——谁小就砍谁，完全不考虑比特预算。更糟的是，一旦少读一个字节，整个解码就崩，像走钢丝一样脆弱。不像
                    MP3 那种“久经沙场”的格式，有同步头、容错机制、纠错码，全都安排得明明白白。</p>
                <hr>
                <h3 id="-">总结一下？</h3>
                <p>这趟旅程让我有种“在车库里造压缩算法”的快乐感。虽然离真正能用还有很长的距离，但能在一次次“听感灾难”中总结经验，逐渐把水下说话调教回“人话”，也是挺有成就感的一件事！</p>
            </div>
        </details>
    </div>

    <script src="lib/pako.1.0.11.js"></script>
    <script>

        const dpr = window.devicePixelRatio || 1;
        const visualizerCanvas = document.getElementById('visualizer');
        const visualizerCtx = visualizerCanvas.getContext('2d');
        const spectrumCanvas = document.getElementById('spectrum');
        const spectrumCtx = spectrumCanvas.getContext('2d');

        function initCanvas() {
            [visualizerCanvas, spectrumCanvas].forEach(canvas => {
                canvas.width = canvas.clientWidth * dpr;
                canvas.height = canvas.clientHeight * dpr;
            });
        }
        initCanvas();
        window.addEventListener('resize', initCanvas);

        const ctx = new AudioContext({ latencyHint: "balanced" });

        const analyser = ctx.createAnalyser();
        analyser.smoothingTimeConstant = 0;
        analyser.fftSize = 2048; // Size of the FFT

        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Float32Array(bufferLength);
        const byteDataArray = new Uint8Array(bufferLength);

        // 用于平滑显示的 dB 范围
        let smoothedMinDb = -100;
        let smoothedMaxDb = -30;

        const fileInfo = document.getElementById("fileinfo");
        const timeDisplay = document.getElementById("time")
        const progressBar = document.getElementById("progress")
        const progressDisplay = document.getElementById("progress-inner")
        const encodeTimeDisplay = document.getElementById("encode-time")
        const encodeProgressDisplay = document.getElementById("encode-progress-inner")
        const info = document.getElementById("info")

        progressBar.addEventListener('click', e => {
            const progress = e.offsetX / progressBar.offsetWidth;
            if (player) player.seekProgress(progress)
        })

        const SUB_BANDS = [
            [0, 1000, 46],
            [1000, 4000, 50],
            [4000, 8000, 54],
            [8000, 12000, 59],
            [12000, 15000, 64],
            [15000, 20000, 67],
            [20000, 192000, 999],
        ]

        function padding(num) {
            if (isNaN(num) || !isFinite(num)) {
                return '**';
            }
            if (num < 10) {
                return '0' + num;
            }
            else {
                return num;
            }
        }

        function formatTime(seconds) {
            if (isNaN(seconds) || !isFinite(seconds)) return "**:**";

            let sec = parseInt(seconds % 60);
            let minutes = seconds / 60;
            let min = parseInt(minutes % 60);
            if (minutes < 60) {
                return padding(min) + ':' + padding(sec);
            } else {
                let hours = minutes / 60;
                return padding(parseInt(hours)) + ':' + padding(min) + ':' + padding(sec);
            }
        }

        function replaceFileExtension(fileName, newExtension) {
            // Ensure the new extension starts with a dot
            if (newExtension.charAt(0) !== '.') {
                newExtension = '.' + newExtension;
            }

            // Find the last dot in the file name
            const lastDotIndex = fileName.lastIndexOf('.');

            // If there is a dot, replace the extension; otherwise, just append the new extension
            if (lastDotIndex !== -1) {
                return fileName.slice(0, lastDotIndex) + newExtension;
            } else {
                return fileName + newExtension;
            }
        }

        function clamp(val, min, max) {
            return Math.max(min, Math.min(max, val));
        }

        function add(v1, v2) {
            return [v1[0] + v2[0], v1[1] + v2[1], v1[2] + v2[2]];
        }

        function sub(v1, v2) {
            return [v1[0] - v2[0], v1[1] - v2[1], v1[2] - v2[2]];
        }

        function mul(v1, mul) {
            return [v1[0] * mul, v1[1] * mul, v1[2] * mul];
        }

        function colorTrans(pal, prog) {
            if (prog < 0) return formatColor(pal[0]);
            else if (prog >= 1) return formatColor(pal[pal.length - 1]);
            let i = parseInt(prog * (pal.length - 1));
            let v1 = pal[i];
            let v2 = pal[i + 1];

            try {
                let delta = sub(v2, v1);
                let percent = (prog / (1 / (pal.length - 1)));
                let int = parseInt(percent);
                percent -= int;
                let adv = mul(delta, percent);
                let result = add(v1, adv);
                return formatColor(result);
            } catch (error) {
                // console.log(i, v1, v2);
                // console.error(error);
            }
        }

        function formatColor(v) {
            return `rgb(${v[0]},${v[1]},${v[2]})`;
        }

        const gaussianPool = new Float32Array(1048576);

        // Fill gaussianPool with gaussian values
        for (let i = 0; i < gaussianPool.length; i++) {
            let u = 0, v = 0;
            while (u === 0) u = Math.random(); //Converting [0,1) to (0,1)
            while (v === 0) v = Math.random();
            let num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            gaussianPool[i] = num;
        }
        let gaussianIndex = 0;

        function gaussianRandom() {
            if (gaussianIndex >= gaussianPool.length) gaussianIndex = 0;
            return gaussianPool[gaussianIndex++];
        }

        function percentile(data, p) {
            if (data.length === 0) return 0;
            if (p <= 0) return Math.min(...data);
            if (p >= 1) return Math.max(...data);

            // 1. 必须先进行升序排序
            // 注意：JS 默认 sort 是按字符串排的，必须传入 (a, b) => a - b
            const sorted = [...data].sort((a, b) => a - b);

            // 2. 计算索引位置
            const index = (sorted.length - 1) * p;
            const lower = Math.floor(index);
            const upper = lower + 1;
            const weight = index - lower;

            // 3. 如果索引正好是整数，直接返回；否则进行线性插值
            if (upper >= sorted.length) return sorted[lower];
            return sorted[lower] * (1 - weight) + sorted[upper] * weight;
        }

        /**
         * Canvas
        */
        let palette = [
            [0, 0, 0],
            [142, 75, 236],
            [0xff, 0x63, 0x61],
            [0xff, 0xd3, 0x80]
        ];

        let lastTimestamp = 0;
        function drawFFT(timestamp) {
            if (!lastTimestamp) lastTimestamp = timestamp;
            const dt = (timestamp - lastTimestamp) / 1000;
            lastTimestamp = timestamp;

            // 频谱图清除
            spectrumCtx.clearRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);

            // 将当前瀑布图画布内容向上移动一行
            visualizerCtx.drawImage(visualizerCanvas, 0, 1, visualizerCanvas.width, visualizerCanvas.height);

            if (analyser && dataArray) {
                // 使用 Float32Array 获取精确的 dB 数据
                analyser.getFloatFrequencyData(dataArray);
                // 使用 Uint8Array 获取用于瀑布图的字节数据（性能更好且足够）
                analyser.getByteFrequencyData(byteDataArray);

                const bufferLength = dataArray.length;
                const sw = spectrumCanvas.width;
                const sh = spectrumCanvas.height;

                // --- 0. 计算自适应 dB 范围 (平滑处理) ---
                let currentMax = -Infinity;
                let currentMin = Infinity;

                // 采样主要信号范围来决定缩放 (忽略极低频和极高频可能更稳定，或者全采样)
                // 这里我们全采样以获取真实动态范围
                for (let i = 0; i < bufferLength; i++) {
                    const val = dataArray[i];
                    if (val === -Infinity) continue;
                    if (val > currentMax) currentMax = val;
                    if (val < currentMin) currentMin = val;
                }

                // 如果没有有效数据，回退到默认
                if (currentMax === -Infinity) {
                    currentMax = -30;
                    currentMin = -100;
                }

                // 添加一些边距
                const targetMax = currentMax + 10;
                const targetMin = Math.max(-120, Math.min(targetMax - 40, currentMin - 10)); // 至少保持 40dB 动态范围，且不低于 -120dB

                // 帧率无关平滑：alpha = 1 - e^(-dt * speed)
                const lerpAlpha = 1 - Math.exp(-dt * 1);
                smoothedMaxDb += (targetMax - smoothedMaxDb) * lerpAlpha;
                smoothedMinDb += (targetMin - smoothedMinDb) * lerpAlpha;

                const minDb = smoothedMinDb;
                const maxDb = smoothedMaxDb;

                // --- 1. 绘制频谱曲线 (Spectrum Canvas) ---
                spectrumCtx.beginPath();
                spectrumCtx.strokeStyle = '#8e4bec';
                spectrumCtx.lineWidth = 1.5 * dpr;
                spectrumCtx.lineJoin = 'round';

                for (let i = 0; i < sw; i++) {
                    const dataIdx = Math.floor(i / sw * bufferLength);
                    const dbVal = dataArray[dataIdx];
                    // 裁剪 dB 值到当前显示范围内
                    const clippedDb = Math.max(minDb, Math.min(maxDb, dbVal));
                    const y = sh - ((clippedDb - minDb) / (maxDb - minDb)) * sh;
                    if (i === 0) spectrumCtx.moveTo(i, y);
                    else spectrumCtx.lineTo(i, y);
                }
                spectrumCtx.stroke();

                // --- 2. 绘制网格/Legend (Spectrum Canvas, 在曲线上方) ---
                spectrumCtx.strokeStyle = '#ffffff22';
                spectrumCtx.fillStyle = '#cccccc';
                spectrumCtx.font = (11 * dpr) + 'px sans-serif';
                spectrumCtx.lineWidth = 1;

                // 频率刻度 (X轴) - 4k
                const sampleRate = ctx.sampleRate;
                const maxFreq = sampleRate / 2;
                const freqInterval = 4000;
                for (let f = freqInterval; f < maxFreq; f += freqInterval) {
                    const x = (f / maxFreq) * sw;
                    spectrumCtx.beginPath();
                    spectrumCtx.moveTo(x, 0);
                    spectrumCtx.lineTo(x, sh);
                    spectrumCtx.stroke();
                    spectrumCtx.fillText((f / 1000) + 'k', x + 2, sh - 5);
                }

                // 动态 dB 刻度 (Y轴)
                // 每 20dB 画一条线
                const step = 20;
                const startDb = Math.ceil(minDb / step) * step;
                for (let db = startDb; db <= maxDb; db += step) {
                    const y = sh - ((db - minDb) / (maxDb - minDb)) * sh;
                    if (y < 0 || y > sh) continue;
                    spectrumCtx.beginPath();
                    spectrumCtx.moveTo(0, y);
                    spectrumCtx.lineTo(sw, y);
                    spectrumCtx.stroke();
                    spectrumCtx.fillText(db + ' dB', 5, y - 5);
                }


                // --- 3. 绘制瀑布图新行 (Visualizer Canvas) ---
                for (let i = 0; i < visualizerCanvas.width; i++) {
                    let index = Math.floor(i / visualizerCanvas.width * bufferLength);
                    visualizerCtx.fillStyle = colorTrans(palette, byteDataArray[index] / 255);
                    visualizerCtx.fillRect(i, 0, 1, 1);
                }

                // 绘制分频带指示线 (Visualizer)
                visualizerCtx.fillStyle = '#ffffff40';
                SUB_BANDS.slice(1).forEach(e => {
                    const x = e[0] / maxFreq * visualizerCanvas.width;
                    visualizerCtx.fillRect(x, 0, 1, 1);
                });
            }

            requestAnimationFrame(drawFFT);
        }


        // 启动绘制循环
        requestAnimationFrame(drawFFT);


        // Function to perform a mini Fast Fourier Transform (FFT)
        function miniFFT(re, im) {
            var N = re.length;
            for (var i = 0; i < N; i++) {
                for (var j = 0, h = i, k = N; k >>= 1; h >>= 1)
                    j = (j << 1) | (h & 1);
                if (j > i) {
                    re[j] = [re[i], re[i] = re[j]][0]
                    im[j] = [im[i], im[i] = im[j]][0]
                }
            }
            for (var hN = 1; hN * 2 <= N; hN *= 2)
                for (var i = 0; i < N; i += hN * 2)
                    for (var j = i; j < i + hN; j++) {
                        var cos = Math.cos(Math.PI * (j - i) / hN),
                            sin = Math.sin(Math.PI * (j - i) / hN)
                        var tre = re[j + hN] * cos + im[j + hN] * sin,
                            tim = -re[j + hN] * sin + im[j + hN] * cos;
                        re[j + hN] = re[j] - tre; im[j + hN] = im[j] - tim;
                        re[j] += tre; im[j] += tim;
                    }
        }

        function miniDCT(s) {
            var N = s.length,
                K = -Math.PI / (2 * N),
                re = new Float64Array(N),
                im = new Float64Array(N);
            for (var i = 0, j = N; j > i; i++) {
                re[i] = s[i * 2]
                re[--j] = s[i * 2 + 1]
            }
            miniFFT(re, im)

            const mul = Math.sqrt(2 / N);

            for (var i = 0; i < N; i++) {
                s[i] = (re[i] * Math.cos(K * i) - im[i] * Math.sin(K * i)) * mul;
            }
            s[0] *= Math.SQRT1_2;
        }

        // Function to perform the inverse discrete cosine transform (IDCT)
        function miniIDCT(s) {
            var N = s.length,
                K = Math.PI / (2 * N),
                im = new Float64Array(N),
                re = new Float64Array(N),
                scale = Math.sqrt(2 / N);

            // Scale first coefficient differently for orthogonal normalization
            re[0] = s[0] / Math.sqrt(N);

            for (var i = 1; i < N; i++) {
                var im2 = Math.sin(i * K),
                    re2 = Math.cos(i * K);

                // Apply scaling and normalization for orthogonal IDCT
                re[i] = (s[N - i] * im2 + s[i] * re2) * scale / 2;
                im[i] = (im2 * s[i] - s[N - i] * re2) * scale / 2;
            }

            miniFFT(im, re);

            for (var i = 0; i < N / 2; i++) {
                s[2 * i] = re[i];
                s[2 * i + 1] = re[N - i - 1];
            }
        }


        function rleCompress(data) {
            const compressed = [];
            let count = 0;

            data.forEach(byte => {
                if (byte === 0) {
                    count += 1;
                } else {
                    if (count > 0) {
                        if (count >= 3) {
                            compressed.push(...this.encodeZeroRun(count)); // Encode if more than 3 zeros
                        } else {
                            compressed.push(...Array(count).fill(0)); // Write zeros as is if count <= 3
                        }
                        count = 0;
                    }
                    compressed.push(byte);
                }
            });

            // Handle trailing zeros
            if (count > 0) {
                if (count >= 3) {
                    compressed.push(...this.encodeZeroRun(count)); // Encode if more than 3 zeros
                } else {
                    compressed.push(...Array(count).fill(0)); // Write zeros as is if count <= 3
                }
            }

            return Int8Array.from(compressed);
        }

        function encodeZeroRun(count) {
            const encoded = [-128];
            count -= 2;

            while (count > 0) {
                if (count > 0xFF) {
                    encoded.push(0xFF);
                    count -= 0xFF;
                } else {
                    encoded.push(count - 1);
                    count = 0;
                }
            }
            return encoded;
        }

        // Function to decompress run-length encoded data
        function rleDecompress(data) {
            const decompressed = []; // Array to hold decompressed data
            let i = 0;

            while (i < data.length) {
                const byte = data[i];

                if (byte === -128) {
                    i += 1;
                    let zeroCount = 0;

                    // Count the number of zeros
                    while (i < data.length && (data[i] & 0xFF) === 0xFF) {
                        zeroCount += 0xFF;
                        i += 1;
                    }

                    if (i < data.length) {
                        zeroCount += (data[i] & 0xFF) + 1;
                        i += 1;
                    }

                    // Push zeros to the decompressed array
                    decompressed.push(...Array(zeroCount + 2).fill(0));
                } else {
                    decompressed.push(byte); // Add byte to decompressed array
                    i += 1;
                }
            }

            return new Int8Array(decompressed); // Return as Int8Array
        }

        function trimZeros(array) {
            // Removes trailing zeros
            let i = array.length - 1;
            while (i >= 0 && array[i] === 0) {
                i--;
            }
            return array.slice(0, i + 1);
        }

        // Function to pad an array to a target length
        function padArray(arr, targetLength) {
            const paddedArray = new Int8Array(targetLength); // Create a new Int8Array

            // Copy the original array into the new array
            const lengthToCopy = Math.min(arr.length, targetLength);
            paddedArray.set(arr.subarray(0, lengthToCopy));

            return paddedArray; // Return padded array
        }

        function quantizeAmp(amp) {
            // Quantize amplitude using log10 scaling to int8 equivalent in JavaScript
            return amp.map(value => {
                if (value === 0) {
                    return 0;
                }
                const ampQ = Math.min(127, Math.max(0, 127 + 20 * Math.log10(Math.abs(value))));
                return value < 0 ? -Math.round(ampQ) : Math.round(ampQ);
            });
        }

        // Function to dequantize amplitudes
        function dequantizeAmp(ampQ) {
            const amp = new Float32Array(ampQ.length); // Create a Float32Array

            for (let i = 0; i < ampQ.length; i++) {
                // Dequantize the amplitudes
                const amplitude = Math.pow(10, (Math.abs(ampQ[i]) - 127) / 20);
                amp[i] = ampQ[i] < 0 ? -amplitude : amplitude; // Store signed amplitude
            }

            return amp; // Return dequantized amplitudes
        }

        function roundDownToPowerOfTwo(number) {
            if (number <= 0) {
                return 0;
            }
            const power = Math.floor(Math.log2(number)) - 1;
            return Math.min(2 ** power, 65536);
        }

        function getFrameNum(sec, sampleRate, samplesPerFrame) {
            return Math.ceil((sec * sampleRate) / samplesPerFrame);
        }


        /* QFP2 Helper function */
        function createMDCTWindow(N) {
            /**
             * 创建满足 Princen-Bradley 条件的窗函数（Vorbis 窗）
             * 满足条件：w[n]^2 + w[n + N/2]^2 = 1
             * 这对于 MDCT 的完美重构至关重要。
             */
            const window = new Float32Array(N);
            const pi = Math.PI;

            for (let n = 0; n < N; n++) {
                // 计算 sin(π * n / N)
                const sinTerm = Math.sin(pi * n / N);

                // 计算 (sin(π * n / N))^2
                const sinSquared = sinTerm * sinTerm;

                // 计算 (π/2) * sinSquared
                const inner = pi / 2 * sinSquared;

                // 计算最终窗值
                window[n] = Math.sin(inner);
            }

            return window;
        }

        function mdct(x) {
            const N = x.length;
            if (N % 4 !== 0) throw new Error("MDCT4 only defined for vectors of length multiple of four.");
            const M = N / 2;
            const N4 = N / 4;

            // Create rotated copy: roll(x, N4) and negate first N4 elements
            const rot = new Array(N);
            for (let i = 0; i < N4; i++) rot[i] = -x[N - N4 + i];
            for (let i = N4; i < N; i++) rot[i] = x[i - N4];

            // Precompute complex exponential w
            const w_re = new Array(N4);
            const w_im = new Array(N4);
            for (let t = 0; t < N4; t++) {
                const angle = -2 * Math.PI * (t + 1 / 8) / N;
                w_re[t] = Math.cos(angle);
                w_im[t] = Math.sin(angle);
            }

            // Build complex signal c
            const c_re = new Array(N4).fill(0);
            const c_im = new Array(N4).fill(0);
            for (let t = 0; t < N4; t++) {
                c_re[t] = 0.5 * (rot[2 * t] - rot[N - 2 * t - 1]);
                c_im[t] = 0.5 * (-rot[M + 2 * t] + rot[M - 2 * t - 1]);
            }

            // Multiply by w: c = 0.5 * c * w
            for (let t = 0; t < N4; t++) {
                const re = c_re[t] * w_re[t] - c_im[t] * w_im[t];
                const im = c_re[t] * w_im[t] + c_im[t] * w_re[t];
                c_re[t] = re;
                c_im[t] = im;
            }

            // Perform FFT
            miniFFT(c_re, c_im);

            // Post-multiply: c = (2/sqrt(N)) * w * c
            const scale = 2 / Math.sqrt(N);
            for (let t = 0; t < N4; t++) {
                const re = (c_re[t] * w_re[t] - c_im[t] * w_im[t]) * scale;
                const im = (c_re[t] * w_im[t] + c_im[t] * w_re[t]) * scale;
                c_re[t] = re;
                c_im[t] = im;
            }

            // Build output
            const y = new Array(M).fill(0);
            for (let t = 0; t < N4; t++) {
                y[2 * t] = c_re[t];
                y[M - 2 * t - 1] = -c_im[t];
            }
            return y;
        }

        function imdct(x) {
            const N = x.length;
            if (N % 2 !== 0) throw new Error("iMDCT4 only defined for even-length vectors.");
            const M = N / 2;
            const N2 = N * 2;

            // Precompute complex exponential w
            const w_re = new Array(M);
            const w_im = new Array(M);
            for (let t = 0; t < M; t++) {
                const angle = -2 * Math.PI * (t + 1 / 8) / N2;
                w_re[t] = Math.cos(angle);
                w_im[t] = Math.sin(angle);
            }

            // Build complex signal c
            const c_re = new Array(M).fill(0);
            const c_im = new Array(M).fill(0);
            for (let t = 0; t < M; t++) {
                c_re[t] = x[2 * t];
                c_im[t] = x[N - 2 * t - 1];
            }

            // Multiply by w: c = 0.5 * w * c
            for (let t = 0; t < M; t++) {
                const re = w_re[t] * c_re[t] - w_im[t] * c_im[t];
                const im = w_re[t] * c_im[t] + w_im[t] * c_re[t];
                c_re[t] = 0.5 * re;
                c_im[t] = 0.5 * im;
            }

            // Perform FFT
            miniFFT(c_re, c_im);

            // Post-multiply: c = (8/sqrt(N2)) * w * c
            const scale = 8 / Math.sqrt(N2);
            for (let t = 0; t < M; t++) {
                const re = (w_re[t] * c_re[t] - w_im[t] * c_im[t]) * scale;
                const im = (w_re[t] * c_im[t] + w_im[t] * c_re[t]) * scale;
                c_re[t] = re;
                c_im[t] = im;
            }

            // Build rotated signal
            const rot = new Array(N2).fill(0);
            for (let t = 0; t < M; t++) {
                rot[2 * t] = c_re[t];
                rot[N + 2 * t] = c_im[t];
            }

            // Apply symmetry: rot[t] = -rot[N2-t-1] for odd indices
            for (let t = 1; t < N2; t += 2) {
                rot[t] = -rot[N2 - t - 1];
            }

            // Final windowed rotation
            const y = new Array(N2).fill(0);
            for (let t = 0; t < 3 * M; t++) {
                y[t] = rot[t + M];
            }
            for (let t = 3 * M; t < N2; t++) {
                y[t] = -rot[t - 3 * M];
            }
            return y;
        }

        function quantizeCompress(array) {
            if (!(array instanceof Float32Array)) {
                array = new Float32Array(array);
            }
            if (array.length === 0) return new Uint8Array(0);

            const result = [];

            // Step 1: 量化
            for (let i = 0; i < array.length; i++) {
                const amp = array[i];
                if (amp === 0.0) {
                    result.push(0);
                } else {
                    let logVal = 20 * Math.log10(Math.abs(amp));
                    let val;
                    if (logVal < -127) {
                        val = 0;
                    } else {
                        val = Math.sign(amp) * Math.round(127 + logVal);
                        val = Math.max(-127, Math.min(127, val));
                    }
                    result.push(val);
                }
            }

            // Step 2: 去除末尾 0
            while (result.length && result[result.length - 1] === 0) {
                result.pop();
            }

            // Step 3: RLE 压缩
            const compressed = [];
            let i = 0;
            while (i < result.length) {
                if (result[i] !== 0) {
                    compressed.push(result[i]);
                    i++;
                } else {
                    let zeroStart = i;
                    while (i < result.length && result[i] === 0) {
                        i++;
                    }
                    const zeroCount = i - zeroStart;

                    if (zeroCount >= 3) {
                        compressed.push(-128); // RLE 标志位
                        let count = zeroCount;
                        while (true) {
                            let byte = count & 0x7F;
                            count >>= 7;
                            if (count) {
                                compressed.push(byte | 0x80);
                            } else {
                                compressed.push(byte);
                                break;
                            }
                        }
                    } else {
                        for (let z = 0; z < zeroCount; z++) {
                            compressed.push(0);
                        }
                    }
                }
            }

            // 转成 Int8Array
            const buffer = new Int8Array(compressed);
            return new Uint8Array(buffer.buffer);
        }


        function decompressQuantized(data, targetLen) {
            const int8data = new Int8Array(data.buffer);
            const result = new Int8Array(targetLen);

            let i = 0, j = 0;
            while (i < int8data.length && j < targetLen) {
                const val = int8data[i++];
                if (val !== -128) {
                    result[j++] = val;
                } else {
                    // 解码 LEB128
                    let shift = 0;
                    let count = 0;
                    while (true) {
                        if (i >= int8data.length) throw new Error("Unexpected end of RLE stream");
                        const byte = int8data[i++];
                        count |= (byte & 0x7F) << shift;
                        if ((byte & 0x80) === 0) break;
                        shift += 7;
                    }
                    if (j + count > targetLen) {
                        throw new Error("Decompressed result exceeds target length");
                    }
                    for (let k = 0; k < count; k++) {
                        result[j++] = 0;
                    }
                }
            }

            // 反量化：int8 → float32
            const out = new Float32Array(targetLen);
            for (let k = 0; k < targetLen; k++) {
                const val = result[k];
                if (val === 0) {
                    out[k] = 0.0;
                } else {
                    const sign = val < 0 ? -1.0 : 1.0;
                    out[k] = sign * Math.pow(10, (Math.abs(val) - 127) / 20);
                }
            }

            return out;
        }

        /* QFPv3 Functions */

        // Frame encapsulation

        /**
         * CRC16-Modbus 算法移植
         * @param {Uint8Array} bytes 
         * @returns {number} 16位校验码
         */
        function crc16(bytes) {
            let crc = 0xFFFF;
            for (let i = 0; i < bytes.length; i++) {
                crc ^= bytes[i];
                for (let j = 0; j < 8; j++) {
                    if (crc & 1) {
                        crc = (crc >>> 1) ^ 0xA001;
                    } else {
                        crc = crc >>> 1;
                    }
                }
            }
            return crc & 0xFFFF;
        }

        const START_STOP = 0x7E;
        const ESCAPE = 0x7D;

        /**
         * 封装帧：添加起始符并处理转义
         * @param {Uint8Array} frameBytes 
         * @returns {Uint8Array}
         */
        function encapsulateFrame(frameBytes) {
            let out = [START_STOP]; // 先用普通数组收集，最后转 TypedArray 性能较好

            for (let b of frameBytes) {
                if (b === ESCAPE || b === START_STOP) {
                    out.push(ESCAPE);
                    out.push(b ^ 0x20);
                } else {
                    out.push(b);
                }
            }
            return new Uint8Array(out);
        }

        /**
 * 模拟文件流读取器
 */
        class BufferReader {
            constructor(arrayBuffer) {
                // 如果传入的是 TypedArray，获取其底层的 ArrayBuffer
                this.buffer = arrayBuffer.buffer || arrayBuffer;
                this.data = new Uint8Array(this.buffer);
                this.view = new DataView(this.buffer);
                this.pos = 0;
            }

            // 核心读取方法：返回视图而非拷贝
            read(n) {
                if (this.pos + n > this.data.length) {
                    const res = this.data.subarray(this.pos);
                    this.pos = this.data.length;
                    return res.length > 0 ? res : null;
                }
                const res = this.data.subarray(this.pos, this.pos + n);
                this.pos += n;
                return res;
            }

            readAll() {
                const res = this.data.subarray(this.pos);
                this.pos = this.data.length;
                return res;
            }

            // --- 单字节读取 ---
            readUint8() {
                const val = this.view.getUint8(this.pos);
                this.pos += 1;
                return val;
            }

            readInt8() {
                const val = this.view.getInt8(this.pos);
                this.pos += 1;
                return val;
            }

            // --- 多字节读取 (默认小端序 LE) ---
            readUint16(le = true) {
                const val = this.view.getUint16(this.pos, le);
                this.pos += 2;
                return val;
            }

            readInt16(le = true) {
                const val = this.view.getInt16(this.pos, le);
                this.pos += 2;
                return val;
            }

            readUint32(le = true) {
                const val = this.view.getUint32(this.pos, le);
                this.pos += 4;
                return val;
            }

            readInt32(le = true) {
                const val = this.view.getInt32(this.pos, le);
                this.pos += 4;
                return val;
            }

            readFloat32(le = true) {
                const val = this.view.getFloat32(this.pos, le);
                this.pos += 4;
                return val;
            }

            // 检查剩余字节
            remaining() {
                return this.data.length - this.pos;
            }

            tell() { return this.pos; }

            seek(offset, whence = 0) {
                if (whence === 0) {
                    this.pos = offset;
                } else if (whence === 1) {
                    this.pos += offset;
                } else if (whence === 2) {
                    this.pos = this.data.length + offset;
                }
            }

            get eof() { return this.pos >= this.data.length; }
        }

        class BufferWriter {
            constructor(initialCapacity = 32) {
                this.data = new Uint8Array(initialCapacity);
                this.view = new DataView(this.data.buffer);
                this.pos = 0;
            }

            _ensureCapacity(n) {
                const minRequired = this.pos + n;
                if (minRequired > this.data.length) {
                    let newLength = Math.max(this.data.length * 2, minRequired);

                    const newData = new Uint8Array(newLength);

                    newData.set(this.data);
                    this.data = newData;

                    this.view = new DataView(this.data.buffer);
                }
            }

            write(data) {
                if (data instanceof ArrayBuffer) {
                    if (data.byteLength === 0) return;
                    this._ensureCapacity(data.byteLength);
                    this.data.set(new Uint8Array(data), this.pos);
                    this.pos += data.byteLength;
                } else if (data instanceof Uint8Array) {
                    if (data.length === 0) return;
                    this._ensureCapacity(data.length);
                    this.data.set(data, this.pos);
                    this.pos += data.length;
                } else {
                    console.error("Invalid data type");
                }
            }

            writeUint8(value) {
                this._ensureCapacity(1);
                this.data[this.pos] = value;
                this.pos += 1;
            }

            writeInt8(value) {
                this._ensureCapacity(1);
                this.data[this.pos] = value;
                this.pos += 1;
            }

            writeUint16(value, le = true) {
                this._ensureCapacity(2);
                this.view.setUint16(this.pos, value, le);
                this.pos += 2;
            }

            writeInt16(value, le = true) {
                this._ensureCapacity(2);
                this.view.setInt16(this.pos, value, le);
                this.pos += 2;
            }

            writeUint32(value, le = true) {
                this._ensureCapacity(4);
                this.view.setUint32(this.pos, value, le);
                this.pos += 4;
            }

            writeInt32(value, le = true) {
                this._ensureCapacity(4);
                this.view.setInt32(this.pos, value, le);
                this.pos += 4;
            }

            writeFloat32(value, le = true) {
                this._ensureCapacity(4);
                this.view.setFloat32(this.pos, value, le);
                this.pos += 4;
            }

            writeFloat64(value, le = true) {
                this._ensureCapacity(8);
                this.view.setFloat64(this.pos, value, le);
                this.pos += 8;
            }

            getBuffer() {
                const truncated = new Uint8Array(this.pos);
                truncated.set(this.data.subarray(0, this.pos));
                return truncated;
            }
        }

        /**
         * 解封装帧
         * @param {BufferReader} reader 
         * @returns {Uint8Array | null}
         */
        function decapsulateFrame(reader) {
            // 步骤 1: 寻找起始符 7E
            while (true) {
                const lead = reader.read(1);
                if (!lead) return null;
                if (lead[0] === START_STOP) break;
            }

            let out = [];

            // 步骤 2: 读取内容并处理转义
            while (true) {
                const b = reader.read(1);
                if (!b) return new Uint8Array(out);

                const curr = b[0];

                if (curr === START_STOP) {
                    // 关键：退回指针，以便下一次调用能发现这一帧的开头
                    reader.seek(-1, 1);
                    return new Uint8Array(out);
                }

                if (curr === ESCAPE) {
                    const nextB = reader.read(1);
                    if (nextB) {
                        out.push(nextB[0] ^ 0x20);
                    } else {
                        break; // 格式错误
                    }
                } else {
                    out.push(curr);
                }
            }
        }

        // Number encoder

        /**
 * 变长整数编码 (0 ~ 536,870,911)
 * @param {number} n 
 * @returns {Uint8Array}
 */
        function prefixEncode(n) {
            if (n < 0) throw new Error("仅支持非负整数");

            if (n <= 0x7F) {
                return new Uint8Array([n]);
            } else if (n <= 0x3FFF) {
                return new Uint8Array([0x80 | (n >> 8), n & 0xFF]);
            } else if (n <= 0x1FFFFF) {
                return new Uint8Array([0xC0 | (n >> 16), (n >> 8) & 0xFF, n & 0xFF]);
            } else if (n <= 0x1FFFFFFF) {
                return new Uint8Array([0xE0 | (n >>> 24), (n >> 16) & 0xFF, (n >> 8) & 0xFF, n & 0xFF]);
            } else {
                throw new Error("数值超过4字节编码上限");
            }
        }

        /**
         * 变长整数解码
         * @param {BufferReader} reader 
         * @returns {number}
         */
        function prefixDecode(reader) {
            const firstByte = reader.read(1);
            if (!firstByte) throw new Error("Reach end of stream");
            const first = firstByte[0];

            if ((first & 0x80) === 0) {
                return first;
            } else if ((first & 0xC0) === 0x80) {
                const rem = reader.read(1);
                if (!rem) throw new Error("Truncated 2-byte");
                return ((first & 0x3F) << 8) | rem[0];
            } else if ((first & 0xE0) === 0xC0) {
                const rem = reader.read(2);
                if (!rem || rem.length < 2) throw new Error("Truncated 3-byte");
                return ((first & 0x1F) << 16) | (rem[0] << 8) | rem[1];
            } else if ((first & 0xE0) === 0xE0) {
                const rem = reader.read(3);
                if (!rem || rem.length < 3) throw new Error("Truncated 4-byte");
                // 使用 >>> 0 确保结果为无符号 32 位整数
                return (((first & 0x1F) << 24) | (rem[0] << 16) | (rem[1] << 8) | rem[2]) >>> 0;
            } else {
                throw new Error("Invalid prefix: " + first.toString(2));
            }
        }

        /**
         * 提取长 0 序列
         */
        function posEncode(ints, minLength = 3) {
            const n = ints.length;
            const result = {
                pos: [],      // [[start_idx, length], ...]
                stripped: []  // 剔除长0后的数据
            };

            let i = 0;
            while (i < n) {
                if (ints[i] === 0) {
                    let startIdx = i;
                    while (i < n && ints[i] === 0) i++;

                    // 优化点：末尾的 0 直接丢弃
                    if (i === n) break;

                    let runLength = i - startIdx;
                    if (runLength >= minLength) {
                        result.pos.push([startIdx, runLength]);
                    } else {
                        // 短 0 序列保留在 stripped 中
                        for (let k = 0; k < runLength; k++) result.stripped.push(0);
                    }
                } else {
                    result.stripped.push(ints[i]);
                    i++;
                }
            }
            return result;
        }

        /**
         * 还原长 0 序列
         */
        function posDecode(pos, stripped, originalLength) {
            let result = [];
            let strippedIdx = 0;

            for (const [startIdx, length] of pos) {
                // 填充当前位置到下一个长0起点之间的数据
                let needed = startIdx - result.length;
                if (needed > 0) {
                    const chunk = stripped.slice(strippedIdx, strippedIdx + needed);
                    result.push(...chunk);
                    strippedIdx += needed;
                }
                // 插入长 0
                for (let k = 0; k < length; k++) result.push(0);
            }

            // 补全剩余非零数据
            if (strippedIdx < stripped.length) {
                result.push(...stripped.slice(strippedIdx));
            }

            // 补全末尾隐含的零
            while (result.length < originalLength) {
                result.push(0);
            }

            return result;
        }

        function encodePosArr(pos) {
            let chunks = [];
            for (const [startIdx, length] of pos) {
                chunks.push(prefixEncode(startIdx));
                chunks.push(prefixEncode(length));
            }
            // 合并所有 Uint8Array
            let totalLen = chunks.reduce((acc, c) => acc + c.length, 0);
            let out = new Uint8Array(totalLen);
            let offset = 0;
            for (const c of chunks) {
                out.set(c, offset);
                offset += c.length;
            }
            return out;
        }

        function decodePosArr(reader) {
            const pos = [];
            while (!reader.eof) {
                try {
                    const startIdx = prefixDecode(reader);
                    const length = prefixDecode(reader);
                    pos.push([startIdx, length]);
                } catch (e) {
                    break; // 流结束或格式不全
                }
            }
            return pos;
        }

        /**
         * Scale 压缩到 8-bit
         */
        function encodeScale(scale) {
            if (scale <= 1e-14) return 0;
            let logS = Math.log2(scale);
            let clippedLog = Math.max(-40, Math.min(0, logS));
            let quantized = Math.round((clippedLog + 40) * (255 / 40));
            return quantized;
        }

        /**
         * Scale 还原
         */
        function decodeScale(qScale) {
            if (qScale === 0) return 0;
            let logS = (qScale * (40 / 255)) - 40;
            return Math.pow(2, logS);
        }


        // Float quantization

        class FloatQuantizePlan {
            constructor(bits, exponentBits, mantissaBits, bias = null, hasDenormal = true) {
                this.bits = bits;
                this.exponentBits = exponentBits;
                this.mantissaBits = mantissaBits;
                this.signBits = 1;

                if (bits !== 1 + exponentBits + mantissaBits) {
                    throw new Error(`Total bits ${bits} != S1 + E${exponentBits} + M${mantissaBits}`);
                }

                this.bias = bias === null ? Math.pow(2, exponentBits - 1) - 1 : bias;
                this.hasDenormal = hasDenormal;
                this.maxExpCodepoint = (1 << exponentBits) - 1;

                // 最大规格化数
                const maxExpVal = (this.maxExpCodepoint - 1) - this.bias;
                this.maxNormal = (2 - Math.pow(2, -mantissaBits)) * Math.pow(2, maxExpVal);
                this.minNormal = Math.pow(2, 1 - this.bias);
                this.minDenormal = hasDenormal ? Math.pow(2, 1 - this.bias - mantissaBits) : this.minNormal;

                this.maxValue = this.maxNormal;
            }
        }

        /**
         * 高性能版 frexp：直接提取二进制位
         * 返回 [mantissa, exponent]
         */
        const _f64 = new Float64Array(1);
        const _u32 = new Uint32Array(_f64.buffer);

        function frexp(value) {
            if (value === 0) return [0, 0];
            _f64[0] = value;

            let high = _u32[1];
            // 提取原始指数位 (bits 52-62)
            let exp = (high >>> 20) & 0x7FF;

            if (exp === 0) {
                // 处理非规格化数 (Subnormal) 或 0
                // 对于 QFP 内部 scale 来说，极小值通常已经处理过，这里可简化
                return [value * Math.pow(2, 64), -64];
            }

            // 将指数修改为 1022 (即 0.5 的指数偏移)
            // 0x3FE00000 是指数偏移 1022 的位置
            _u32[1] = (high & 0x800FFFFF) | 0x3FE00000;

            let mant = _f64[0];
            return [mant, exp - 1022];
        }

        class FloatQuantizer {
            constructor(plan) {
                this.plan = plan;
                this.expMaxVal = (1 << plan.exponentBits) - 2;
                this.expInfNan = (1 << plan.exponentBits) - 1;
            }

            quantize(xArray, normalizedRange = 1.0) {
                const scale = normalizedRange > 0 ? this.plan.maxValue / normalizedRange : 1.0;
                const result = new Uint32Array(xArray.length);

                for (let i = 0; i < xArray.length; i++) {
                    let x = xArray[i] * scale;
                    if (x === 0) {
                        result[i] = 0;
                        continue;
                    }

                    const sign = x < 0 ? 1 : 0;
                    let absX = Math.abs(x);
                    let [mant, exp] = frexp(absX);

                    // 映射到 [1.0, 2.0)
                    mant *= 2;
                    exp -= 1;

                    let eBiased = exp + this.plan.bias;

                    // 处理非规格化
                    if (this.plan.hasDenormal && eBiased < 1) {
                        const shift = (1 - this.plan.bias) - exp;
                        mant /= Math.pow(2, shift);
                        eBiased = 0;
                    }

                    let mantInt;
                    if (eBiased >= 1) {
                        mantInt = Math.round((mant - 1.0) * Math.pow(2, this.plan.mantissaBits));
                    } else {
                        mantInt = Math.round(mant * Math.pow(2, this.plan.mantissaBits));
                    }

                    // 处理进位
                    if (mantInt >= Math.pow(2, this.plan.mantissaBits)) {
                        mantInt = 0;
                        eBiased += 1;
                    }

                    // 边界截断
                    if (eBiased > this.expMaxVal) {
                        eBiased = this.expMaxVal;
                        mantInt = (1 << this.plan.mantissaBits) - 1;
                    }

                    const qSign = sign << (this.plan.exponentBits + this.plan.mantissaBits);
                    const qExp = eBiased << this.plan.mantissaBits;
                    result[i] = (qSign | qExp | mantInt) >>> 0;
                }
                return result;
            }

            dequantize(quantized, normalizedRange = 1.0) {
                const M = this.plan.mantissaBits;
                const E = this.plan.exponentBits;
                const val = new Float32Array(quantized.length);

                for (let i = 0; i < quantized.length; i++) {
                    const q = quantized[i];
                    const s = (q >> (E + M)) & 1;
                    const e = (q >> M) & ((1 << E) - 1);
                    const m = q & ((1 << M) - 1);

                    let v = 0;
                    if (e === 0) {
                        if (this.plan.hasDenormal) {
                            v = (m / Math.pow(2, M)) * Math.pow(2, 1 - this.plan.bias);
                        }
                    } else if (e === (1 << E) - 1) {
                        v = Infinity;
                    } else {
                        v = (1.0 + m / Math.pow(2, M)) * Math.pow(2, e - this.plan.bias);
                    }
                    val[i] = v * (s === 1 ? -1 : 1);
                }

                const scale = normalizedRange / this.plan.maxValue;
                for (let i = 0; i < val.length; i++) val[i] *= scale;
                return val;
            }
        }

        class Int2BitSpecialQuantizer {
            constructor() {
                this.bits = 2;
                // 索引映射表: 0=零, 1=正台阶, 2=负台阶, 3=备用(设为0)
                this.lookup = new Float32Array([0.0, 0.5, -0.5, 0.0]);
            }

            /**
             * 量化逻辑
             * @param {Float32Array} x 
             * @returns {Uint8Array}
             */
            quantize(x) {
                const out = new Uint8Array(x.length);
                for (let i = 0; i < x.length; i++) {
                    const val = x[i];
                    const absX = Math.abs(val);

                    // 1. 定义死区逻辑 (abs_x < 0.1 则归零)
                    if (absX < 0.1) {
                        out[i] = 0;
                    } else {
                        // 2. 对称映射：正数映射为 1，负数映射为 2
                        // (根据 Python 源码：out[x>0]=1, out[x<0]=2)
                        out[i] = val > 0 ? 1 : 2;
                    }
                }
                return out;
            }

            /**
             * 反量化逻辑
             * @param {Uint8Array} q 
             * @returns {Float32Array}
             */
            dequantize(q) {
                const out = new Float32Array(q.length);
                const lookup = this.lookup;
                for (let i = 0; i < q.length; i++) {
                    // 相当于 np.take(lookup, q)
                    out[i] = lookup[q[i]];
                }
                return out;
            }
        }

        /**
         * 将量化整数序列打包为字节流
         */
        function floatPack(bits, qArray) {
            if (bits === 8) return new Uint8Array(qArray);

            if (bits === 6) {
                const len = qArray.length;
                const out = new Uint8Array((len / 4) * 3);
                for (let i = 0, j = 0; i < len; i += 4, j += 3) {
                    const v0 = qArray[i], v1 = qArray[i + 1], v2 = qArray[i + 2], v3 = qArray[i + 3];
                    out[j] = (v0 & 0x3F) | ((v1 & 0x03) << 6);
                    out[j + 1] = ((v1 >> 2) & 0x0F) | ((v2 & 0x0F) << 4);
                    out[j + 2] = ((v2 >> 4) & 0x03) | ((v3 & 0x3F) << 2);
                }
                return out;
            }

            if (bits === 4) {
                const out = new Uint8Array(qArray.length / 2);
                for (let i = 0; i < qArray.length; i += 2) {
                    out[i / 2] = (qArray[i] & 0x0F) | ((qArray[i + 1] & 0x0F) << 4);
                }
                return out;
            }

            if (bits === 2) {
                const out = new Uint8Array(qArray.length / 4);
                for (let i = 0; i < qArray.length; i += 4) {
                    out[i / 4] = (qArray[i] & 0x03) |
                        ((qArray[i + 1] & 0x03) << 2) |
                        ((qArray[i + 2] & 0x03) << 4) |
                        ((qArray[i + 3] & 0x03) << 6);
                }
                return out;
            }
        }

        /**
         * 解包
         */
        function floatUnpack(bits, dataBytes, count) {
            const raw = new Uint8Array(dataBytes);
            if (bits === 8) return new Uint32Array(raw);

            const out = new Uint32Array(count);
            if (bits === 6) {
                for (let i = 0, j = 0; j < count; i += 3, j += 4) {
                    const b0 = raw[i], b1 = raw[i + 1], b2 = raw[i + 2];
                    out[j] = b0 & 0x3F;
                    out[j + 1] = (b0 >> 6) | ((b1 & 0x0F) << 2);
                    out[j + 2] = (b1 >> 4) | ((b2 & 0x03) << 4);
                    out[j + 3] = (b2 >> 2) & 0x3F;
                }
            } else if (bits === 4) {
                for (let i = 0; i < raw.length; i++) {
                    out[i * 2] = raw[i] & 0x0F;
                    out[i * 2 + 1] = (raw[i] >> 4) & 0x0F;
                }
            } else if (bits === 2) {
                for (let i = 0; i < raw.length; i++) {
                    out[i * 4] = raw[i] & 0x03;
                    out[i * 4 + 1] = (raw[i] >> 2) & 0x03;
                    out[i * 4 + 2] = (raw[i] >> 4) & 0x03;
                    out[i * 4 + 3] = (raw[i] >> 6) & 0x03;
                }
            }
            return out.slice(0, count);
        }

        function packBits(bitArray) {
            const len = bitArray.length;
            const out = new Uint8Array(Math.ceil(len / 8));
            for (let i = 0; i < len; i++) {
                const byteIndex = Math.floor(i / 8);
                const bitIndex = i % 8;
                if (bitArray[i]) {
                    out[byteIndex] |= (1 << bitIndex);
                }
            }
            return out;
        }

        function unpackBits(bytes, count) {
            const out = new Uint8Array(count);
            for (let i = 0; i < count; i++) {
                const byteIndex = Math.floor(i / 8);
                const bitIndex = i % 8;
                out[i] = (bytes[byteIndex] >> bitIndex) & 1;
            }
            return out;
        }

        /**
        * 非线性陡峭化变换
        * @param {number} x 输入值 (0 到 1)
        * @param {number} k 陡峭系数
        * @returns {number} 映射后的值
        */
        function warpSteep(x, k = 2) {
            // 边界处理，防止 0/0
            if (x <= 0) return 0;
            if (x >= 1) return 1;

            // 如果 k 是整数且较小，Math.pow 性能尚可
            // 但如果 k=2 是常态，直接 x*x 会更快
            if (k === 2) {
                const x2 = x * x;
                const omx = 1 - x;
                return x2 / (x2 + omx * omx);
            }

            const xk = Math.pow(x, k);
            const omxk = Math.pow(1 - x, k);
            return xk / (xk + omxk);
        }


        /**
 * 线性插值函数
 * @param {Array} xPoints 原始 X 坐标 (频段中心)
 * @param {Array} yPoints 原始 Y 坐标 (各频段的损失能量)
 * @param {number} targetX 需要计算的 X 位置
 */
        function lerp(xPoints, yPoints, targetX) {
            if (targetX <= xPoints[0]) return yPoints[0];
            if (targetX >= xPoints[xPoints.length - 1]) return yPoints[yPoints.length - 1];

            // 找到 targetX 所在的区间
            let i = 0;
            while (targetX > xPoints[i + 1]) i++;

            const x0 = xPoints[i], x1 = xPoints[i + 1];
            const y0 = yPoints[i], y1 = yPoints[i + 1];

            // 线性插值公式
            return y0 + (y1 - y0) * (targetX - x0) / (x1 - x0);
        }


        const QUANT_LEVELS = {
            0: { 'bits': 8, 'plan': new FloatQuantizer(new FloatQuantizePlan(8, 4, 3)) },  // 最高精度
            1: { 'bits': 8, 'plan': new FloatQuantizer(new FloatQuantizePlan(8, 5, 2)) },
            2: { 'bits': 8, 'plan': new FloatQuantizer(new FloatQuantizePlan(8, 3, 4)) },
            3: { 'bits': 6, 'plan': new FloatQuantizer(new FloatQuantizePlan(6, 4, 1)) },
            4: { 'bits': 6, 'plan': new FloatQuantizer(new FloatQuantizePlan(6, 3, 2)) },
            5: { 'bits': 6, 'plan': new FloatQuantizer(new FloatQuantizePlan(6, 2, 3)) },
            6: { 'bits': 4, 'plan': new FloatQuantizer(new FloatQuantizePlan(4, 3, 0)) },
            7: { 'bits': 4, 'plan': new FloatQuantizer(new FloatQuantizePlan(4, 2, 1)) },
            8: { 'bits': 4, 'plan': new FloatQuantizer(new FloatQuantizePlan(4, 1, 2)) },
            9: { 'bits': 2, 'plan': new Int2BitSpecialQuantizer() },  // 最低精度
            15: { 'bits': 0, 'plan': null }  // 跳过频段(不编码)
        }

        class QFPEncoder {
            constructor(audioBuffer, qp) {
                this.buffer = audioBuffer; // 音频数据
                this.i = 0; // 当前窗口索引
                this.l = audioBuffer.getChannelData(0); // 左声道数据
                this.r = audioBuffer.numberOfChannels >= 2 ? audioBuffer.getChannelData(1) : this.l; // 右声道数据，如果单声道则与左声道相同
                this.qp = qp; // 量化参数

                this.settings = {};
            }

            // 编码文件头部，包含采样率、窗口大小等元信息
            encodeHeader() {
                const buffer = new ArrayBuffer(17); // 文件头固定17字节
                this.sampleRate = this.buffer.sampleRate; // 获取采样率
                this.winSize = roundDownToPowerOfTwo(this.sampleRate / 16); // 窗口大小设置为采样率的1/16，并向下取整到2的次方
                this.numWins = parseInt(this.buffer.length / this.winSize); // 根据音频长度和窗口大小计算总窗口数量

                const diff = 63 - this.qp; // 用于计算子带量化的偏移值

                // 初始化子带量化参数
                this.subBands = [[], []];
                for (const b of SUB_BANDS) {
                    this.subBands[0].push([
                        Math.min(Math.max(b[0] / this.sampleRate * 2, 0), 1), // 归一化子带的起始频率
                        Math.min(Math.max(b[1] / this.sampleRate * 2, 0), 1), // 归一化子带的结束频率
                        Math.min(Math.max(b[2] - diff - Math.log10(this.winSize / 1024) * 10, 0), 127), // 子带的量化阈值
                    ]);
                    this.subBands[1].push([
                        Math.min(Math.max(b[0] / this.sampleRate * 2, 0), 1),
                        Math.min(Math.max(b[1] / this.sampleRate * 2, 0), 1),
                        Math.min(Math.max(b[2] - diff + 10 - Math.log10(this.winSize / 1024) * 10, 0), 127),
                    ]);
                }

                console.log(this.subBands); // 打印子带信息，方便调试

                const view = new DataView(buffer);
                view.setUint32(0, 1095779921, true); // 设置魔数"QFPA"
                view.setUint8(4, 1); // 版本号
                view.setUint32(5, this.sampleRate, true); // 采样率
                view.setUint32(9, this.winSize, true); // 窗口大小
                view.setUint32(13, this.numWins, true); // 窗口总数
                return buffer;
            }

            // 编码单个帧，处理 L+R 和 L-R 通道
            encodeFrame() {
                const L = this.l.slice(this.i * this.winSize, (this.i + 1) * this.winSize); // 当前帧的左声道数据
                const R = this.r.slice(this.i * this.winSize, (this.i + 1) * this.winSize); // 当前帧的右声道数据

                const winDataLPlusR = L.map((val, idx) => val + R[idx]); // L+R 数据
                const winDataLMinusR = L.map((val, idx) => val - R[idx]); // L-R 数据

                const encodedFrames = []; // 用于存储编码后的数据

                for (let ch = 0; ch < 2; ch++) {
                    const winData = ch === 0 ? winDataLPlusR : winDataLMinusR; // 处理 L+R 或 L-R 数据

                    miniDCT(winData); // 对数据应用离散余弦变换

                    // 归一化并量化
                    let amp = winData.map(value => value / this.winSize);
                    let ampQ = quantizeAmp(amp); // 将幅值量化

                    // 子带处理
                    for (const subBand of this.subBands[ch]) {
                        const bandStart = Math.floor(this.winSize * subBand[0]); // 子带起始索引
                        const bandEnd = Math.floor(this.winSize * subBand[1]); // 子带结束索引
                        const band = ampQ.slice(bandStart, bandEnd).map(value => Math.abs(value) < subBand[2] ? 0 : value); // 应用量化阈值
                        band.forEach((v, i) => ampQ[bandStart + i] = v); // 更新量化后的数据
                    }

                    // 去除尾部的零
                    ampQ = trimZeros(ampQ);

                    // 限制最大长度为 65535
                    if (ampQ.length > 65535) {
                        ampQ = ampQ.slice(0, 65535);
                    }

                    // 运行长度编码压缩
                    const compressedData = rleCompress(ampQ);

                    // 打包长度和压缩数据
                    const lenArray = new ArrayBuffer(2);
                    new DataView(lenArray).setUint16(0, compressedData.byteLength, true);

                    encodedFrames.push(lenArray);
                    encodedFrames.push(compressedData.buffer);
                }
                this.i++;
                return encodedFrames;
            }

            // 判断是否还有未编码的帧
            available() {
                return this.i < this.numWins;
            }

            frameLength() {
                return this.winSize; // 返回每帧的长度
            }
        }

        class QFP2Encoder {
            constructor(audioBuffer, qp) {
                this.buffer = audioBuffer; // 音频数据
                this.i = 0; // 当前窗口索引
                this.l = audioBuffer.getChannelData(0); // 左声道数据
                this.r = audioBuffer.numberOfChannels >= 2 ? audioBuffer.getChannelData(1) : this.l; // 右声道数据，如果单声道则与左声道相同
                this.qp = qp; // 量化参数
                this.quantTable = [
                    [0, 0.0000004],
                    [1000, 0.0000008],
                    [4000, 0.0000016],
                    [8000, 0.0000032],
                    [12000, 0.00001],
                    [15000, 0.000034],
                    [20000, 100]
                ]; // 量化表，包含频率和对应的量化值
                this.attenuationTable = [
                    [0, 0.75],
                    [1000, 0.5],
                    [4000, 0.25],
                    [8000, 0.125],
                    [12000, 0.05],
                    [15000, 0.016],
                    [20000, 0],
                ]
                this.MODES = {
                    CQP: 0,
                    MBR: 1
                }

                this.settings = {
                    voiceOptimization: false,
                    mode: this.MODES.MBR
                }

            }

            // 编码文件头部，包含采样率、窗口大小等元信息
            encodeHeader() {
                const buffer = new ArrayBuffer(21); // 文件头固定21字节
                this.sampleRate = this.buffer.sampleRate; // 获取采样率
                this.winSize = roundDownToPowerOfTwo(this.sampleRate / 8); // 窗口大小设置为采样率的1/16，并向下取整到2的次方
                this.groupSize = 64
                this.hopSize = this.winSize / 2; // 每组的跳跃大小
                this.numWins = Math.floor(this.buffer.length / this.hopSize); // 根据音频长度和窗口大小计算总窗口数量
                this.ampQuant = 0.1 / this.winSize;

                const qScale = 1.25 ** (this.qp - 32); // 用于计算子带量化的偏移值
                this.currentQuantTable = [[], []];
                this.currentAttenuationTable = [[], []]
                this.binFreq = new Float32Array(this.hopSize);
                for (let i = 0; i < this.binFreq.length; i++) {
                    this.binFreq[i] = (i + 0.5) * (this.sampleRate / this.winSize); // 计算当前频率 bin 的频率值
                }

                for (let i = 0; i < this.hopSize; i++) {
                    const binFreq = this.binFreq[i]

                    // 查找对应的量化阈值
                    for (let j = 0; j < this.quantTable.length; j++) {
                        if (binFreq > this.quantTable[j][0] && (j === this.quantTable.length - 1 || binFreq <= this.quantTable[j + 1][0])) {
                            this.currentQuantTable[0][i] = this.quantTable[j][1] * qScale; // L+R 通道的量化值
                            this.currentQuantTable[1][i] = this.quantTable[j][1] * qScale * 4; // L-R 通道的量化值

                            this.currentAttenuationTable[0][i] = this.attenuationTable[j][1];
                            this.currentAttenuationTable[1][i] = this.attenuationTable[j][1] * 0.5;

                            if (this.settings.voiceOptimization) {
                                // keep only 0-4k
                                if (binFreq > 4000) {
                                    this.currentQuantTable[0][i] = 100;
                                    this.currentQuantTable[1][i] = 100;
                                }
                            }
                            break;
                        }
                        else {
                            this.currentQuantTable[0][i] = this.quantTable[this.quantTable.length - 1][1] * qScale; // 默认使用最后一个量化值
                            this.currentQuantTable[1][i] = this.quantTable[this.quantTable.length - 1][1] * qScale * 4; // L-R 通道的量化值
                        }
                    }
                }

                console.log(this.currentAttenuationTable)

                this.window = createMDCTWindow(this.winSize); // 创建满足 Princen-Bradley 条件的窗函数

                const view = new DataView(buffer);
                view.setUint32(0, 1095779921, true); // 设置魔数"QFPA"
                view.setUint8(4, 2); // 版本号
                view.setUint32(5, this.sampleRate, true); // 采样率
                view.setUint32(9, this.winSize, true); // 窗口大小
                view.setUint32(13, this.numWins, true); // 窗口总数
                view.setUint32(17, this.groupSize, true); // 设置组大小

                return buffer;
            }

            frameLength() {
                return this.hopSize; // 返回每帧的长度
            }

            // 编码单个帧，处理 L+R 和 L-R 通道
            encodeFrame() {
                let L = this.l.slice(this.i * this.hopSize, this.i * this.hopSize + this.winSize); // 当前帧的左声道数据
                let R = this.r.slice(this.i * this.hopSize, this.i * this.hopSize + this.winSize); // 当前帧的右声道数据

                // 如果数据长度不足窗口大小，则填充零
                if (L.length < this.winSize) {
                    L = new Float32Array([...L, ...new Array(this.winSize - L.length).fill(0)]);
                }
                if (R.length < this.winSize) {
                    R = new Float32Array([...R, ...new Array(this.winSize - R.length).fill(0)]);
                }

                const winDataLPlusR = L.map((val, idx) => val + R[idx]); // L+R 数据
                const winDataLMinusR = L.map((val, idx) => val - R[idx]); // L-R 数据

                const encodedFrames = []; // 用于存储编码后的数据

                for (let ch = 0; ch < 2; ch++) {
                    // 应用窗函数
                    const sampleData = ch === 0 ? winDataLPlusR : winDataLMinusR; // 处理 L+R 或 L-R 数据
                    const windowedData = sampleData.map((val, idx) => val * this.window[idx]); // 应用窗函数

                    const mdctCoeffs = mdct(windowedData); // 对数据应用离散余弦变换

                    // 归一化并量化
                    for (let i = 0; i < mdctCoeffs.length; i++) {
                        mdctCoeffs[i] /= this.winSize; // 归一化
                    }

                    const ampCoeff = []; // 存储响度系数
                    const numGroups = Math.floor(mdctCoeffs.length / this.groupSize); // 计算组数
                    for (let j = 0; j < numGroups; j++) {
                        const group = mdctCoeffs.slice(j * this.groupSize, (j + 1) * this.groupSize); // 获取当前组数据
                        if (group.length < this.groupSize) break; // 如果组数据不足，跳出循环

                        // 计算每组的响度
                        const ampGroup = group.reduce((sum, value) => sum + Math.abs(value), 0); // 计算绝对值和
                        if (ampGroup > this.ampQuant) { // 只保留大的响度值
                            ampCoeff.push(ampGroup);
                        } else {
                            ampCoeff.push(0.0); // 小于阈值的响度值设为0
                        }
                    }

                    // 丢弃小于阈值的mdct系数
                    switch (this.settings.mode) {
                        case this.MODES.CQP:
                            for (let j = 0; j < mdctCoeffs.length; j++) {
                                if (Math.abs(mdctCoeffs[j]) < this.currentQuantTable[ch][j]) {
                                    mdctCoeffs[j] = 0; // 小于阈值的系数设为0
                                }
                            }
                            break;
                        case this.MODES.MBR:
                            let arr = [...mdctCoeffs].map((e, i) => Math.abs(e))
                            arr.sort((a, b) => a - b)
                            // const targetBitrate = 131072;
                            // const ratio = 1 - (targetBitrate / (this.sampleRate * 32));
                            const ratio = this.qp / 64;
                            let threshold = arr[Math.floor(arr.length * ratio)]
                            // console.log(ratio, threshold, arr)
                            for (let j = 0; j < mdctCoeffs.length; j++) {
                                if (Math.abs(mdctCoeffs[j]) * this.currentAttenuationTable[ch][j] < threshold) {
                                    mdctCoeffs[j] = 0; // 小于阈值的系数设为0
                                }
                            }
                            break
                    }


                    // 量化mdct系数
                    const quantizedMdct = quantizeCompress(mdctCoeffs); // 量化压缩mdct系数
                    // 量化响度系数
                    const quantizedAmp = quantizeCompress(new Float32Array(ampCoeff)); // 量化压缩响度系数

                    // 打包长度和压缩数据
                    const mdctLen = new ArrayBuffer(2);
                    const ampLen = new ArrayBuffer(2);
                    new DataView(mdctLen).setUint16(0, quantizedMdct.byteLength, true); // 设置mdct长度
                    new DataView(ampLen).setUint16(0, quantizedAmp.byteLength, true); // 设置响度长度
                    encodedFrames.push(mdctLen); // 添加mdct长度
                    encodedFrames.push(quantizedMdct.buffer); // 添加压缩后的mdct系数
                    encodedFrames.push(ampLen); // 添加响度长度
                    encodedFrames.push(quantizedAmp.buffer); // 添加压缩后的响度系数
                }
                this.i++; // 更新窗口索引

                return encodedFrames; // 返回编码后的帧数据
            }
            available() {
                return this.i < this.numWins; // 判断是否还有未编码的帧
            }
        }

        class QFP3Encoder {
            constructor(audioBuffer, qp) {
                this.audioBuffer = audioBuffer;
                this.qp = qp;
                this.winSize = 2048;
                this.hopSize = this.winSize / 2;
                this.bandSize = 64;
                this.nyquist = audioBuffer.sampleRate / 2;
                this.numBands = Math.floor(this.hopSize / this.bandSize);
                this.numWins = Math.floor(audioBuffer.length / this.hopSize) - 1;
                this.i = 0; // 当前窗口索引
                this.l = audioBuffer.getChannelData(0); // 左声道数据
                this.r = audioBuffer.numberOfChannels >= 2 ? audioBuffer.getChannelData(1) : this.l; // 右声道数据，如果单声道则与左声道相同

            }

            encodeHeader() {
                const header = new BufferWriter();
                header.writeUint8(0x51); // 文件标识符
                header.writeUint8(0x46); // 文件标识符
                header.writeUint8(0x50); // 文件标识符
                header.writeUint8(0x41); // 文件标识符
                header.writeUint8(3);
                header.writeUint8(0); // V3.0


                // 基础信息
                header.writeUint32(this.audioBuffer.sampleRate);
                header.writeUint32(this.winSize);
                header.writeUint32(this.numWins);
                header.writeUint32(this.bandSize);


                // 元数据

                header.writeUint8(0x55);
                header.writeUint8(0xAA);

                this.window = createMDCTWindow(this.winSize);

                // 构建band plan
                this.bandPlan = [];

                for (let i = 0; i < this.hopSize; i += this.bandSize) {
                    const minFreq = Math.floor(i * this.nyquist / this.hopSize);
                    const maxFreq = Math.floor((i + this.bandSize) * this.nyquist / this.hopSize);
                    let quantizerLevel, krBase;
                    if (minFreq < 4000) {
                        quantizerLevel = 0;
                        krBase = 1.0;
                    } else if (minFreq < 6000) {
                        quantizerLevel = 3;
                        krBase = 0.7;
                    } else if (minFreq < 8000) {
                        quantizerLevel = 6;
                        krBase = 1 / 2;
                    } else if (minFreq < 10000) {
                        quantizerLevel = 6;
                        krBase = 1 / 4;
                    } else if (minFreq < 12000) {
                        quantizerLevel = 6;
                        krBase = 1 / 4;
                    } else if (minFreq < 14000) {
                        quantizerLevel = 9;
                        krBase = 1 / 6;
                    } else if (minFreq < 16000) {
                        quantizerLevel = 9;
                        krBase = 1 / 6;
                    } else if (minFreq < 18000) {
                        quantizerLevel = 9;
                        krBase = 1 / 8;
                    } else if (minFreq >= 20000) {
                        quantizerLevel = 15;
                        krBase = 0.0;
                    } else {
                        quantizerLevel = 9;
                        krBase = 1 / 8;
                    }
                    this.bandPlan.push({ minFreq, maxFreq, quantizerLevel, krBase });
                }
                if (this.qp >= 52) {
                    const cutoff = this.qp >= 56 ? 8000 : 12000;
                    for (let b = 0; b < this.bandPlan.length; b++) {
                        if (this.bandPlan[b].maxFreq > cutoff) {
                            this.bandPlan[b].quantizerLevel = 15;
                        }
                    }
                }
                this.bandPlan[0].krBase = 1.5; // 提升最低频段的保留率

                // 构造双通道静态量化方案
                this.quantLevelsCache = [];
                const offset = this.qp >= 48 ? 3 : 0;
                const lprPlanArr = new Uint8Array(this.bandPlan.length);
                const lmrPlanArr = new Uint8Array(this.bandPlan.length);
                for (let i = 0; i < this.bandPlan.length; i++) {
                    const quantizerLevel = this.bandPlan[i].quantizerLevel;
                    if (quantizerLevel === 15) {
                        lprPlanArr[i] = 15;
                        lmrPlanArr[i] = 15;
                        continue;
                    } else {
                        lprPlanArr[i] = Math.min(quantizerLevel + offset, 9);
                        lmrPlanArr[i] = Math.min(quantizerLevel + offset + 3, 9);
                    }
                }

                // 调试：强制单声道
                // if (this.qp >= 52) {
                //     lmrPlanArr.fill(15);
                // }

                this.quantLevelsCache.push(lprPlanArr);
                this.quantLevelsCache.push(lmrPlanArr);

                // 写入header
                console.log(this.bandPlan);
                console.log(lprPlanArr);
                console.log(lmrPlanArr);

                header.write(floatPack(4, lprPlanArr));
                header.write(floatPack(4, lmrPlanArr));

                return header.getBuffer().buffer;
            }

            frameLength() {
                return this.hopSize; // 返回每帧的长度
            }

            encodeFrame() {

                let L = this.l.slice(this.i * this.hopSize, this.i * this.hopSize + this.winSize); // 当前帧的左声道数据
                let R = this.r.slice(this.i * this.hopSize, this.i * this.hopSize + this.winSize); // 当前帧的右声道数据

                // 如果数据长度不足窗口大小，则填充零
                if (L.length < this.winSize) {
                    L = new Float32Array([...L, ...new Array(this.winSize - L.length).fill(0)]);
                }
                if (R.length < this.winSize) {
                    R = new Float32Array([...R, ...new Array(this.winSize - R.length).fill(0)]);
                }

                const LPR = L.map((val, idx) => (val + R[idx]) * this.window[idx]); // L+R 数据
                const LMR = L.map((val, idx) => (val - R[idx]) * this.window[idx]); // L-R 数据

                const energyLPR = LPR.reduce((a, b) => Math.abs(a) + Math.abs(b), 0);
                const energyLMR = LMR.reduce((a, b) => Math.abs(a) + Math.abs(b), 0);

                const msRatio = energyLMR / (energyLPR + 1e-6);

                let silent = true;
                const quantizeBits = [8, 6, 4, 2];
                const frameBuffer = new BufferWriter();
                const outBuffer = new BufferWriter();

                for (let ch = 0; ch < 2; ch++) {
                    const block = ch ? LMR : LPR;
                    const mdctCoeffs = mdct(block);

                    for (let i = 0; i < mdctCoeffs.length; i++) {
                        mdctCoeffs[i] /= this.winSize;
                    }

                    const absCoeffs = mdctCoeffs.map(Math.abs);
                    const weights = new Float32Array(this.hopSize);

                    for (let bIdx = 0; bIdx < this.bandPlan.length; bIdx++) {
                        const start = bIdx * this.bandSize;
                        const end = start + this.bandSize;
                        const qLvl = this.quantLevelsCache[ch][bIdx];
                        const qBits = QUANT_LEVELS[qLvl]['bits'];
                        const fW = this.bandPlan[bIdx].krBase;
                        const pW = 1 - (qBits / 8.0) * 0.5;
                        const qpSlope = 1.0 + (this.qp / 64.0) * (1.0 - (bIdx / this.numBands));
                        for (let i = start; i < end; i++) {
                            weights[i] = fW * pW * qpSlope;
                        }
                    }

                    const weightedCoeffs = absCoeffs//.map((val, idx) => val * weights[idx]);
                    const channelBouns = ch ? 1 : clamp(msRatio * 1.5, 0.1, 0.5);
                    const globalKeepRatio = clamp(Math.max(0, warpSteep(1.0 - (this.qp / 63), 1.5)) * channelBouns, 0, 0.99);
                    const validWeighted = weightedCoeffs.filter((val) => val > 0);
                    const threshold = validWeighted.length > 0 ? percentile(validWeighted, (1 - globalKeepRatio)) : 0;


                    const bandsData = [];
                    const bandBitmap = new Uint8Array(this.numBands);
                    const mdctBuckets = { 8: [], 6: [], 4: [], 2: [] };

                    for (let bIdx = 0; bIdx < this.numBands; bIdx++) {
                        const start = bIdx * this.bandSize;
                        const end = start + this.bandSize;
                        const qLvl = this.quantLevelsCache[ch][bIdx];
                        const qBits = QUANT_LEVELS[qLvl]['bits'];

                        if (qLvl === 15) {
                            continue;
                        }

                        const blockData = mdctCoeffs.slice(start, end);

                        const energy = blockData.reduce((sum, val) => sum + Math.abs(val), 0);
                        if (energy < 0.000001) {
                            continue;
                        }

                        const prunedData = blockData.map((val, idx) => weightedCoeffs[start + idx] >= threshold ? val : 0);
                        let scale = prunedData.map(e => Math.abs(e)).reduce((a, b) => a > b ? a : b, 0);
                        if (scale === 0) {
                            scale = 1;
                        }
                        for (let i = 0; i < prunedData.length; i++) {
                            prunedData[i] /= scale;
                        }

                        const quantizer = QUANT_LEVELS[qLvl]['plan'];
                        if (quantizer == null) {
                            continue;
                        }

                        const quantizedData = quantizer.quantize(prunedData);

                        const restoredData = quantizer.dequantize(quantizedData);

                        const sumAbsBlock = blockData.reduce((sum, val) => sum + Math.abs(val), 0);
                        const sumAbsRestored = restoredData.reduce((sum, val) => sum + Math.abs(val), 0);
                        const ampLoss = Math.max(0, (sumAbsBlock / scale) - sumAbsRestored) * scale;


                        const lossByte = encodeScale(ampLoss);
                        bandBitmap[bIdx] = 1;
                        silent = false;
                        bandsData.push({
                            scale,
                            lossByte,
                            ampLoss
                        });
                        mdctBuckets[qBits].push(...quantizedData);

                    }

                    frameBuffer.write(packBits(bandBitmap));
                    for (let i = 0; i < bandsData.length; i++) {
                        const bandData = bandsData[i];
                        frameBuffer.writeUint8(encodeScale(bandData.scale));
                        frameBuffer.writeUint8(bandData.lossByte);
                    }

                    for (const bits of quantizeBits) {
                        const bucket = mdctBuckets[bits];
                        const posInfo = posEncode(bucket, Math.floor(3 * 8 / bits));
                        const posBytes = encodePosArr(posInfo['pos']);
                        const stripped = posInfo['stripped'];
                        const align = ({ 8: 1, 6: 4, 4: 2, 2: 4, 1: 8 })[bits] || 1;
                        if (stripped.length % align !== 0) {
                            for (let _ = 0; _ < align - (stripped.length % align); _++) {
                                stripped.push(0);
                            }
                        }
                        const result = floatPack(bits, stripped);
                        frameBuffer.write(prefixEncode(posBytes.length));
                        frameBuffer.write(posBytes);
                        frameBuffer.write(prefixEncode(result.length));
                        frameBuffer.write(result);
                    }

                }
                if (silent) {
                    outBuffer.write(encapsulateFrame(new Uint8Array(0)));
                } else {
                    const frame = frameBuffer.getBuffer();
                    const crc = crc16(frame);
                    const finalFrame = new Uint8Array(frame.length + 2);
                    finalFrame[0] = crc & 0xff;
                    finalFrame[1] = (crc >> 8) & 0xff;
                    finalFrame.set(frame, 2);
                    // console.log(finalFrame + "");
                    outBuffer.write(encapsulateFrame(finalFrame).buffer);
                }
                this.i++;
                return [outBuffer.getBuffer().buffer];
            }

            available() {
                return this.i < this.numWins; // 判断是否还有未编码的帧
            }
        }


        // QFPDecoder: 用于解码 QFP 文件的类
        class QFPDecoder {
            constructor(arrayBuffer) {
                // 初始化缓冲区和数据视图
                this.buffer = arrayBuffer; // 使用输入的原始压缩数据
                this.view = new DataView(this.buffer);
                this.ptr = 0; // 指针位置
                this.read = 0; // 已读取帧数
                this.readHeader(); // 读取文件头信息

                // 解压 gzipped 数据
                this.decompressedData = pako.inflate(arrayBuffer.slice(17)); // 跳过文件头
                this.decompressedView = new DataView(this.decompressedData.buffer); // 创建解压数据的 DataView

                this.compressRatio = this.buffer.byteLength / this.decompressedData.buffer.byteLength; // 计算压缩比

                this.generatePos(); // 可选：预生成帧位置表
            }

            // 读取文件头信息
            readHeader() {
                let magic = new TextDecoder('utf-8').decode(this.buffer.slice(0, 4)); // 读取文件标识符
                console.log("magic: " + magic);
                if (magic !== 'QFPA') throw new Error("magic not match"); // 检查文件标识符是否匹配

                // 读取版本、采样率、窗口大小等元信息
                this.version = this.view.getUint8(4, true); // 版本号
                this.sampleRate = this.view.getUint32(5, true); // 采样率
                this.winSize = this.view.getUint32(9, true); // 窗口大小
                this.numWindows = this.view.getUint32(13, true); // 总窗口数

                console.log("version: " + this.version);
                console.log("sample rate: " + this.sampleRate);
                console.log("win size:" + this.winSize);
                console.log("num win:" + this.numWindows);

                // 计算音频总时长
                this.duration = this.numWindows * (this.winSize / this.sampleRate);

                // 显示文件头信息
                fileInfo.innerHTML = `V${this.version} | SR: ${this.sampleRate}Hz | WS: ${this.winSize} | NW: ${this.numWindows} | ABR: ${(this.buffer.byteLength / this.duration * 8 / 1024).toFixed(2)}kbps`;

                this.L = new Float32Array(this.winSize);
                this.R = new Float32Array(this.winSize);
            }

            // 读取并解码单帧数据
            readFrame() {
                if (this.read >= this.numWindows) throw new Error("No more frames to read"); // 检查是否还有帧可读

                const lr = []; // 存储左右声道数据的数组
                let totalLength = 0; // 累计帧数据长度

                // 遍历左右声道
                for (let ch = 0; ch < 2; ch++) {
                    const length = this.decompressedView.getUint16(this.ptr, true); // 读取帧长度
                    totalLength += length;
                    this.ptr += 2; // 移动指针

                    let ampQ = new Int8Array(this.decompressedData.slice(this.ptr, this.ptr + length)); // 读取量化幅度数据
                    this.ptr += length; // 移动指针

                    ampQ = rleDecompress(ampQ); // 运行长度解压缩
                    ampQ = padArray(ampQ, this.winSize); // 对数据进行填充

                    let amp = dequantizeAmp(ampQ).map(e => e * this.winSize); // 去量化并放大数据

                    miniIDCT(amp); // 对解压后的数据应用逆离散余弦变换（IDCT）

                    lr[ch] = amp; // 存储解码后的声道数据
                }

                // 将左右声道数据转换为实际音频样本
                for (let i = 0; i < this.winSize; i++) {
                    this.L[i] = (lr[0][i] + lr[1][i]) / 2; // 左声道数据
                    this.R[i] = (lr[0][i] - lr[1][i]) / 2; // 右声道数据
                }

                this.read++; // 更新已读取帧数
                return [this.L, this.R, totalLength]; // 返回解码后的左右声道数据和帧总长度
            }

            // 预生成帧位置表（加速随机访问）
            generatePos() {
                this.lookUp = [];
                for (let i = 0; i < this.numWindows; i++) {
                    this.lookUp.push(this.ptr); // 存储当前帧的指针位置
                    for (let ch = 0; ch < 2; ch++) {
                        const length = this.decompressedView.getUint16(this.ptr, true); // 读取帧长度
                        this.ptr += 2 + length; // 移动指针到下一帧
                    }
                }
                this.reset(); // 重置指针和读取状态
            }

            // 定位到指定帧（需要预生成帧位置表）
            seek(frame) {
                this.ptr = 0 + this.lookUp[frame];
                this.read = frame;
            }

            seekSeconds(sec) {
                const progress = sec / this.duration;
                this.seekProgress(progress)
            }

            seekProgress(progress) {
                const frame = Math.floor(this.numWindows * progress);
                this.seek(frame);
            }

            currentTime() {
                return this.read * (this.winSize / this.sampleRate)
            }

            // 重置解码器状态
            reset() {
                this.ptr = 0;
                this.read = 0;
            }

            frameLength() {
                return this.winSize; // 返回每帧的长度
            }

            getVersion() {
                return 'v1'
            }

            setOption(key, value) {

            }
        }

        class QFP2Decoder {
            constructor(arrayBuffer) {
                this.buffer = arrayBuffer; // 使用输入的原始压缩数据
                this.view = new DataView(this.buffer);
                this.ptr = 0; // 指针位置
                this.read = 0; // 已读取帧数
                this.readHeader(); // 读取文件头信息

                // 解压 gzipped 数据
                this.decompressedData = pako.inflate(arrayBuffer.slice(21)); // 跳过文件头
                this.decompressedView = new DataView(this.decompressedData.buffer); // 创建解压数据的 DataView

                this.compressRatio = this.buffer.byteLength / this.decompressedData.buffer.byteLength; // 计算压缩比

                this.generatePos(); // 可选：预生成帧位置表

                this.settings = {
                    noiseFilling: true
                }
            }

            readHeader() {
                let magic = new TextDecoder('utf-8').decode(this.buffer.slice(0, 4)); // 读取文件标识符
                console.log("magic: " + magic);
                if (magic !== 'QFPA') throw new Error("magic not match"); // 检查文件标识符是否匹配

                // 读取版本、采样率、窗口大小等元信息
                this.version = this.view.getUint8(4, true); // 版本号
                this.sampleRate = this.view.getUint32(5, true); // 采样率
                this.winSize = this.view.getUint32(9, true); // 窗口大小
                this.numWindows = this.view.getUint32(13, true); // 总窗口数
                this.groupSize = this.view.getUint32(17, true); // 组大小
                this.hopSize = this.winSize / 2; // 步长大小，默认为窗口大小的一半

                console.log("version: " + this.version);
                console.log("sample rate: " + this.sampleRate);
                console.log("win size:" + this.winSize);
                console.log("num win:" + this.numWindows);
                console.log("group size:" + this.groupSize);

                // 计算音频总时长
                this.duration = this.numWindows * (this.hopSize / this.sampleRate);

                // 显示文件头信息
                fileInfo.innerHTML = `V${this.version} | SR: ${this.sampleRate}Hz | WS: ${this.winSize} | NW: ${this.numWindows} | GS: ${this.groupSize} | ABR: ${(this.buffer.byteLength / this.duration * 8 / 1024).toFixed(2)}kbps`;


                this.constructBuffer = [
                    new Float32Array(this.winSize + this.hopSize),
                    new Float32Array(this.winSize + this.hopSize) // 用于存储解码后的音频数据
                ]
                this.L = new Float32Array(this.hopSize);
                this.R = new Float32Array(this.hopSize);
                this.window = createMDCTWindow(this.winSize)
                this.noiseGain = Math.sqrt(this.hopSize)
            }

            readFrame() {
                if (this.read >= this.numWindows) throw new Error("No more frames to read"); // 检查是否还有帧可读

                let start = this.ptr; // 记录当前指针位置

                for (let ch = 0; ch < 2; ch++) {
                    const mdctLength = this.decompressedView.getUint16(this.ptr, true); // 读取 MDCT 数据长度
                    this.ptr += 2; // 移动指针
                    let mdctDataRaw = this.decompressedData.slice(this.ptr, this.ptr + mdctLength); // 读取 MDCT 数据
                    let mdctData = decompressQuantized(mdctDataRaw, this.hopSize); // 解压量化的 MDCT 数据
                    let numOfGroups = Math.floor(mdctData.length / this.groupSize); // 计算组数
                    this.ptr += mdctLength; // 移动指针


                    const ampLength = this.decompressedView.getUint16(this.ptr, true); // 读取幅度数据长度
                    this.ptr += 2; // 移动指针
                    let ampDataRaw = this.decompressedData.slice(this.ptr, this.ptr + ampLength); // 读取幅度数据
                    let ampData = decompressQuantized(ampDataRaw, numOfGroups); // 解压量化的幅度数据
                    this.ptr += ampLength; // 移动指针

                    const ampLoss = new Float32Array(numOfGroups + 2); // 创建幅度损失数组
                    for (let i = 0; i < numOfGroups; i++) {
                        // 计算每组的响度
                        const group = mdctData.slice(i * this.groupSize, (i + 1) * this.groupSize);
                        if (group.length < this.groupSize) break; // 如果组不完整则跳出循环
                        const groupAmp = group.reduce((sum, val) => sum + Math.abs(val), 0); // 计算组的响度
                        const recordedAmp = ampData[i] || 0.0; // 获取记录的响度
                        ampLoss[i + 1] = recordedAmp - groupAmp; // 计算损失
                    }

                    // 插值计算幅度损失
                    const ampLossInterp = new Float32Array(mdctData.length); // 创建插值数组

                    for (let i = 0; i < mdctData.length; i++) {
                        const xOld = (i / mdctData.length) * (numOfGroups + 1); // 计算旧的 x 坐标
                        const groupIndex = Math.floor(xOld);
                        const frac = xOld - groupIndex; // 小数部分

                        if (groupIndex < numOfGroups) {
                            ampLossInterp[i] = ampLoss[groupIndex] * (1 - frac) + ampLoss[groupIndex + 1] * frac; // 线性插值
                        } else {
                            ampLossInterp[i] = ampLoss[numOfGroups]; // 边界情况
                        }

                        ampLossInterp[i] *= 0.707;
                    }

                    for (let i = 0; i < mdctData.length; i++) {
                        if (this.settings.noiseFilling) mdctData[i] += gaussianRandom() * ampLossInterp[i] / this.noiseGain; // 添加噪声到 MDCT 数据
                        mdctData[i] *= this.winSize; // 增益mdct
                    }

                    let reconCh = imdct(mdctData); // 逆变换得到重建的音频数据

                    // 加窗
                    for (let i = 0; i < reconCh.length; i++) {
                        reconCh[i] *= this.window[i];
                    }

                    // 将重建的音频数据添加到构造缓冲区
                    for (let i = 0; i < this.winSize; i++) {
                        this.constructBuffer[ch][i + this.hopSize] += reconCh[i]; // 将重建数据放入对应的声道缓冲区
                    }

                }

                this.read++; // 更新已读取帧数

                // 计算 L 和 R 声道
                for (let i = 0; i < this.hopSize; i++) {
                    this.L[i] = (this.constructBuffer[0][i] + this.constructBuffer[1][i]) / 2; // 左声道
                    this.R[i] = (this.constructBuffer[0][i] - this.constructBuffer[1][i]) / 2; // 右声道
                }

                // 前进缓冲区
                for (let ch = 0; ch < 2; ch++) {
                    for (let i = 0; i < this.winSize; i++) {
                        this.constructBuffer[ch][i] = this.constructBuffer[ch][i + this.hopSize]; // 向前移动缓冲区
                    }
                    this.constructBuffer[ch].fill(0, this.winSize);
                }

                return [this.L, this.R, this.ptr - start]; // 返回重建的左右声道数据和帧大小
            }

            reset() {
                this.ptr = 0;
                this.read = 0;
            }

            frameLength() {
                return this.hopSize; // 返回每帧的长度
            }

            // 预生成帧位置表（加速随机访问）
            generatePos() {
                this.lookUp = [];
                for (let i = 0; i < this.numWindows; i++) {
                    this.lookUp.push(this.ptr); // 存储当前帧的指针位置
                    for (let ch = 0; ch < 2; ch++) {
                        const length = this.decompressedView.getUint16(this.ptr, true); // 读取帧长度
                        this.ptr += 2 + length;
                        const length2 = this.decompressedView.getUint16(this.ptr, true); // 读取帧长度
                        this.ptr += 2 + length2;
                    }
                }
                this.reset(); // 重置指针和读取状态
            }

            // 定位到指定帧（需要预生成帧位置表）
            seek(frame) {
                this.ptr = 0 + this.lookUp[frame];
                this.read = frame;
            }

            seekSeconds(sec) {
                const progress = sec / this.duration;
                this.seekProgress(progress)
            }

            seekProgress(progress) {
                const frame = Math.floor(this.numWindows * progress);
                this.seek(frame);
            }

            currentTime() {
                return this.read * (this.hopSize / this.sampleRate)
            }

            getVersion() {
                return 'v2'
            }


            setOption(key, value) {
                switch (key) {
                    case 'noise-filling':
                        this.settings.noiseFilling = value;
                        break;

                    default:
                        break;
                }
            }
        }

        class QFP3Decoder {
            constructor(arrayBuffer) {
                this.buffer = arrayBuffer; // 使用输入的原始压缩数据
                this.reader = new BufferReader(arrayBuffer);
                this.ptr = 0; // 指针位置
                this.read = 0; // 已读取帧数
                this.readHeader(); // 读取文件头信息

                // 解压 gzipped 数据
                const data = this.reader.readAll()
                this.decompressedData = pako.inflate(data);
                this.decompressedReader = new BufferReader(this.decompressedData);

                this.compressRatio = this.buffer.byteLength / this.decompressedData.buffer.byteLength; // 计算压缩比

                this.generatePos(); // 可选：预生成帧位置表

                this.settings = {
                    noiseFilling: true
                }
            }

            readHeader() {
                let magic = new TextDecoder('utf-8').decode(this.buffer.slice(0, 4)); // 读取文件标识符
                console.log("magic: " + magic);
                if (magic !== 'QFPA') throw new Error("magic not match"); // 检查文件标识符是否匹配

                this.reader.seek(4);

                // 读取版本、采样率、窗口大小等元信息
                this.version = this.reader.readUint8(); // 版本号
                this.subVersion = this.reader.readUint8(); // 子版本号
                this.sampleRate = this.reader.readUint32(); // 采样率
                this.winSize = this.reader.readUint32(); // 窗口大小
                this.numWindows = this.reader.readUint32(); // 总窗口数
                this.bandSize = this.reader.readUint32(); // 组大小
                this.hopSize = this.winSize / 2; // 步长大小，默认为窗口大小的一半

                console.log("version: " + this.version);
                console.log("sample rate: " + this.sampleRate);
                console.log("win size:" + this.winSize);
                console.log("num win:" + this.numWindows);
                console.log("group size:" + this.bandSize);

                // 计算音频总时长
                this.duration = this.numWindows * (this.hopSize / this.sampleRate);

                // 显示文件头信息
                fileInfo.innerHTML = `V${this.version}.${this.subVersion} | SR: ${this.sampleRate}Hz | WS: ${this.winSize} | NW: ${this.numWindows} | GS: ${this.bandSize} | ABR: ${(this.buffer.byteLength / this.duration * 8 / 1024).toFixed(2)}kbps`;

                this.metadata = {};

                // 读取meta
                let dataByte = this.reader.readUint8();
                if (dataByte === 0x55) {
                    while (true) {
                        let mType = this.reader.readUint8();
                        if (mType === 0xAA) {
                            break;
                        }
                        let mLen = prefixDecode(this.reader);
                        let mData = this.reader.read(mLen);
                        this.metadata[mType] = mData;
                        console.log("Found Metadata Type " + mType + ", Len " + mLen + ", Content: " + mData);
                    }
                } else {
                    this.reader.seek(-1, 1);
                }

                this.constructBuffer = [
                    new Float32Array(this.winSize + this.hopSize),
                    new Float32Array(this.winSize + this.hopSize) // 用于存储解码后的音频数据
                ]
                this.L = new Float32Array(this.hopSize);
                this.R = new Float32Array(this.hopSize);
                this.window = createMDCTWindow(this.winSize)

                // 读取Band Plan
                this.numBands = this.hopSize / this.bandSize;
                let planBytesLen = this.numBands / 2;
                let lprPlan = floatUnpack(4, this.reader.read(planBytesLen), this.numBands);
                let lmrPlan = floatUnpack(4, this.reader.read(planBytesLen), this.numBands);
                this.dualChPlans = [lprPlan, lmrPlan];

                console.log("LPR Plan: ", lprPlan);
                console.log("LMR Plan: ", lmrPlan);

            }

            readFrame() {
                if (this.read >= this.numWindows) throw new Error("No more frames to read"); // 检查是否还有帧可读


                this.L.fill(0);
                this.R.fill(0);

                const frame = decapsulateFrame(this.decompressedReader);
                this.read++;
                if (frame.length == 0) {
                    return [this.L, this.R, 1]; // 左声道，右声道，帧长
                }

                const frameReader = new BufferReader(frame);

                const crcStored = frameReader.readUint16();
                const crcComputed = crc16(new Uint8Array(frame.subarray(2)));
                if (crcStored !== crcComputed) {
                    console.warn("CRC check failed for frame " + this.read);
                    // 对于校验失败的帧，直接返回静音帧防止破音
                    return [this.L, this.R, frame.length]; // 左声道，右声道，帧长
                }

                for (let ch = 0; ch < 2; ch++) {
                    const mdctCoeffs = new Float32Array(this.hopSize);

                    const bitmapSize = Math.ceil(this.numBands / 8);
                    const bitmapData = frameReader.read(bitmapSize);

                    const bitmap = unpackBits(bitmapData, this.numBands);

                    const bandMeta = [];
                    for (let bIdx = 0; bIdx < this.numBands; bIdx++) {
                        if (bitmap[bIdx]) {
                            const scale = decodeScale(frameReader.readUint8());
                            const lossByte = frameReader.readUint8();
                            const lossVal = scale == 0 ? 0 : decodeScale(lossByte) / scale;
                            bandMeta.push({
                                scale: scale,
                                loss: lossVal
                            });
                        }
                    }

                    const mdctBucket = {
                        8: [], 6: [], 4: [], 2: []
                    }

                    for (let bits of [8, 6, 4, 2]) {
                        const posLen = prefixDecode(frameReader);
                        const posData = frameReader.read(posLen);
                        const posReader = new BufferReader(new Uint8Array(posData).buffer);
                        const pos = decodePosArr(posReader);

                        const mdctDataLen = prefixDecode(frameReader);
                        const mdctData = frameReader.read(mdctDataLen);

                        if (mdctDataLen == 0) continue;

                        let activeBands = 0;
                        for (let bIdx = 0; bIdx < this.numBands; bIdx++) {
                            if (bitmap[bIdx] && QUANT_LEVELS[this.dualChPlans[ch][bIdx]]['bits'] === bits) {
                                activeBands++;
                            }
                        }

                        const stripped = floatUnpack(bits, mdctData, Math.ceil(mdctData.length * 8 / bits));
                        const fullBucket = posDecode(pos, stripped, activeBands * this.bandSize);
                        mdctBucket[bits] = fullBucket;

                    }

                    let metaPtr = 0;
                    const bucketPtrs = { 8: 0, 6: 0, 4: 0, 2: 0 };
                    const ampLosses = new Float32Array(this.numBands);

                    for (let bIdx = 0; bIdx < this.numBands; bIdx++) {
                        if (bitmap[bIdx] == 0) continue;

                        const qBits = QUANT_LEVELS[this.dualChPlans[ch][bIdx]]['bits'];
                        const scale = bandMeta[metaPtr].scale;
                        const lossNorm = bandMeta[metaPtr].loss;
                        metaPtr++;

                        const startP = bucketPtrs[qBits];
                        const endP = startP + this.bandSize;
                        let qSlice = mdctBucket[qBits].slice(startP, endP);
                        bucketPtrs[qBits] = endP;

                        if (qSlice.length == 0) {
                            qSlice = new Float32Array(this.bandSize).fill(0);
                        }

                        const quantizer = QUANT_LEVELS[this.dualChPlans[ch][bIdx]]['plan'];
                        const dequantized = quantizer.dequantize(qSlice);
                        for (let i = 0; i < this.bandSize; i++) {
                            mdctCoeffs[bIdx * this.bandSize + i] = dequantized[i] * scale * this.winSize;
                        }

                        ampLosses[bIdx] = lossNorm * scale;
                    }

                    if (this.settings.noiseFilling) {

                        // 1. 构建插值点 (对应 Python 的 x_points, y_points)
                        const xPoints = [];
                        const yPoints = [];

                        // 添加左边界
                        xPoints.push(-this.bandSize);
                        yPoints.push(0);

                        // 添加每个频段的中心点
                        for (let b = 0; b < this.numBands; b++) {
                            xPoints.push(b * this.bandSize + this.bandSize / 2);
                            yPoints.push(ampLosses[b]); // ampLosses 是你在上一步计算的 lossNorm * scale
                        }

                        // 添加右边界
                        xPoints.push(this.hopSize + this.bandSize);
                        yPoints.push(0);

                        // 2. 生成噪声并注入
                        for (let bIdx = 0; bIdx < this.numBands; bIdx++) {
                            const start = bIdx * this.bandSize;
                            const end = start + this.bandSize;

                            // 计算该频段的原始噪声总能量 (用于归一化)
                            let currNoiseSum = 0;
                            const rawNoise = new Float32Array(this.bandSize);
                            for (let i = 0; i < this.bandSize; i++) {
                                // 使用 Math.random() 生成 [-1, 1] 的噪声 (近似高斯或均匀分布)
                                rawNoise[i] = gaussianRandom();
                                currNoiseSum += Math.abs(rawNoise[i]);
                            }

                            if (currNoiseSum > 0) {
                                for (let i = 0; i < this.bandSize; i++) {
                                    const globalIdx = start + i;

                                    // 只在系数为 0 的位置注入
                                    if (mdctCoeffs[globalIdx] === 0) {
                                        // 计算该位置的插值包络高度
                                        const envelopeVal = lerp(xPoints, yPoints, globalIdx);

                                        // 注入归一化后的噪声能量
                                        // Python: (curr_noise / curr_sum) * target_amp
                                        mdctCoeffs[globalIdx] = (rawNoise[i] / currNoiseSum) * envelopeVal * this.winSize;
                                    }
                                }
                            }
                        }
                    }


                    // if (ch == 0) console.log(mdctCoeffs.toString());
                    let reconCh = imdct(mdctCoeffs); // 逆变换得到重建的音频数据

                    // 加窗
                    for (let i = 0; i < reconCh.length; i++) {
                        reconCh[i] *= this.window[i];
                    }

                    // 将重建的音频数据添加到构造缓冲区
                    for (let i = 0; i < this.winSize; i++) {
                        this.constructBuffer[ch][i + this.hopSize] += reconCh[i]; // 将重建数据放入对应的声道缓冲区
                    }

                }

                for (let i = 0; i < this.hopSize; i++) {
                    this.L[i] = (this.constructBuffer[0][i] + this.constructBuffer[1][i]) / 2; // 左声道
                    this.R[i] = (this.constructBuffer[0][i] - this.constructBuffer[1][i]) / 2; // 右声道
                }

                // 前进缓冲区
                for (let ch = 0; ch < 2; ch++) {
                    for (let i = 0; i < this.winSize; i++) {
                        this.constructBuffer[ch][i] = this.constructBuffer[ch][i + this.hopSize]; // 向前移动缓冲区
                    }
                    this.constructBuffer[ch].fill(0, this.winSize);
                }

                return [this.L, this.R, frame.length];

            }

            reset() {
            }

            generatePos() {
                this.framePositions = new Uint32Array(this.numWindows);
                // 保存当前指针位置以便恢复
                const initialPos = this.decompressedReader.pos;
                this.decompressedReader.seek(0);

                for (let i = 0; i < this.numWindows; i++) {
                    // 记录当前帧在解压流中的绝对位置
                    this.framePositions[i] = this.decompressedReader.pos;

                    // 使用 decapsulateFrame 快速跳过数据，不进行逻辑处理
                    // 这一步会根据帧头定义的长度移动 decompressedReader.pos
                    decapsulateFrame(this.decompressedReader);
                }

                // 扫描完成后恢复指针
                this.decompressedReader.seek(initialPos);
                console.log(`Scan complete: indexing ${this.numWindows} frames.`);
            }

            frameLength() {
                return this.hopSize;
            }

            seek(frameIndex) {
                if (frameIndex < 0) frameIndex = 0;
                if (frameIndex >= this.numWindows) frameIndex = this.numWindows - 1;

                // 1. 跳转解码器指针
                const targetPos = this.framePositions[frameIndex];
                this.decompressedReader.seek(targetPos);
                this.read = frameIndex;

                // 2. 关键：重置 OLA 缓冲区
                // 如果不重置，seek 后的第一帧会和 seek 前的内容重叠相加，产生爆音或杂音
                for (let ch = 0; ch < 2; ch++) {
                    this.constructBuffer[ch].fill(0);
                }
            }

            seekSeconds(seconds) {
                // 根据时间计算帧索引
                // 公式: index = seconds * sampleRate / hopSize
                const frameIndex = Math.floor(seconds * this.sampleRate / this.hopSize);
                this.seek(frameIndex);
            }

            seekProgress(progress) {
                const targetFrame = Math.floor(progress * this.numWindows);
                this.seek(targetFrame);
            }

            currentTime() { return this.read * this.hopSize / this.sampleRate }


            getVersion() {
                return 'v3';
            }

            setOption(key, value) {
                switch (key) {
                    case 'noise-filling':
                        this.settings.noiseFilling = value;
                        break;

                    default:
                        break;
                }
            }
        }

        function qfpFactory(arrayBuffer) {
            if (!(arrayBuffer instanceof ArrayBuffer)) {
                throw new Error("Input must be an ArrayBuffer.");
            }

            // 检查文件版本
            const magic = new TextDecoder('utf-8').decode(arrayBuffer.slice(0, 4));
            if (magic !== 'QFPA') {
                throw new Error("Invalid QFP file format.");
            }

            const version = new DataView(arrayBuffer).getUint8(4, true);
            if (version === 1) {
                return new QFPDecoder(arrayBuffer); // 返回 QFP1 解码器实例
            } else if (version === 2) {
                return new QFP2Decoder(arrayBuffer); // 返回 QFP2 解码器实例
            } else if (version === 3) {
                return new QFP3Decoder(arrayBuffer); // 返回 QFP3 解码器实例
            } else {
                throw new Error("Unsupported QFP version: " + version);
            }
        }

        function qfpEncoderFactory(audioBuffer, qp) {
            if (!(audioBuffer instanceof AudioBuffer)) {
                throw new Error("Input must be an AudioBuffer.");
            }

            if (qp < 0 || qp > 63) {
                throw new Error("QP must be between 0 and 63.");
            }

            // version select radio buttons
            const versionSelect = document.getElementById('version-select');
            const version = versionSelect.querySelector('input[name="version"]:checked').value;
            console.log("Selected QFP version: " + version);
            if (version === 'v1') {
                return new QFPEncoder(audioBuffer, qp); // 返回 QFP1 编码器实例
            } else if (version === 'v2') {
                return new QFP2Encoder(audioBuffer, qp); // 返回 QFP2 编码器实例
            } else if (version === 'v3') {
                return new QFP3Encoder(audioBuffer, qp); // 返回 QFP3 编码器实例
            } else {
                throw new Error("Unsupported QFP version: " + version);
            }
        }


        class QFPPlayer {
            /**
             * @param {QFPDecoder} qfp 解码器实例，用于读取音频帧
             */
            constructor(qfp) {
                this.qfp = qfp; // 关联解码器
                this.t = 0; // 当前音频播放进度（秒）
                this.started = false; // 是否已经开始播放
                this.nodeList = []; // 存储已创建的音频节点
                this.stopped = false; // 是否已经停止
                this.frameLength = []; // 用于计算平均比特率的帧长度记录
                this.preloadDuration = 1; // 预加载的音频时长（秒）
            }

            // 启动音频播放，只能启动一次
            start() {
                if (this.started) throw new Error("QFPPlayer can only be started once.");
                this.startTime = ctx.currentTime; // 记录启动时间
                this.updateProgress(); // 初始化进度条

                // 根据窗口大小和采样率计算需要预加载的帧数
                let preloadFrames = Math.max(Math.floor(this.preloadDuration / (this.qfp.winSize / this.qfp.sampleRate)), 2);
                for (let i = 0; i < preloadFrames; i++) {
                    this.playFrame(); // 逐帧预加载
                }
            }

            seekProgress(progress) {
                for (const node of this.nodeList) {
                    node.disconnect(); // 断开所有音频节点
                }
                this.nodeList = [];
                this.qfp.seekProgress(progress)
                this.startTime = ctx.currentTime; // 记录启动时间
                this.t = 0;
                this.playFrame();
            }

            // 设置播放/暂停状态
            setPaused(b) {
                if (b) {
                    ctx.suspend(); // 暂停音频上下文
                } else {
                    ctx.resume(); // 恢复音频上下文
                }
            }

            // 更新进度条信息
            updateProgress() {
                let currentTime = this.qfp.currentTime()//Math.min(ctx.currentTime - this.startTime, this.qfp.duration); // 当前播放时间
                let prog = currentTime / this.qfp.duration; // 播放进度百分比
                timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(this.qfp.duration)}`;
                progressDisplay.style.width = (prog * 100) + "%"; // 更新进度条显示
            }

            // 播放一个音频帧
            playFrame() {
                if (!this.stopped) {
                    const frame = this.qfp.readFrame(); // 从解码器读取下一帧

                    // 创建音频缓冲区并填充左右声道数据
                    const buffer = ctx.createBuffer(2, frame[0].length, this.qfp.sampleRate);
                    const l = buffer.getChannelData(0);
                    const r = buffer.getChannelData(1);
                    l.set(frame[0]);
                    r.set(frame[1]);

                    this.frameLength.push(frame[2]); // 记录帧的比特长度

                    // 控制 frameLength 的缓存大小，避免内存占用过多
                    const frameOf1S = Math.max(Math.floor(1 / (this.qfp.frameLength() / this.qfp.sampleRate)), 2);
                    while (this.frameLength.length > frameOf1S * (this.preloadDuration + 0.5)) {
                        this.frameLength.shift();
                    }

                    // 计算平均比特率（ABR）并更新界面
                    let abrBuffer = this.frameLength.slice(0, frameOf1S / 2);
                    let abr = abrBuffer.reduce((a, b) => a + b, 0) / (this.qfp.frameLength() / this.qfp.sampleRate * abrBuffer.length) / 128;
                    info.textContent = `ABR ≈ ${(abr * this.qfp.compressRatio).toFixed(1)} (${abr.toFixed(1)} raw) kbps`;

                    const node = ctx.createBufferSource(); // 创建音频节点
                    node.buffer = buffer;
                    node.onended = () => { // 当帧播放完毕时的回调
                        node.disconnect();
                        this.nodeList.shift(); // 移除已完成的节点

                        if (!this.stopped) {
                            this.updateProgress();
                            this.playFrame(); // 播放下一帧
                        }
                    };
                    node.connect(analyser).connect(ctx.destination); // 连接到音频分析器和输出
                    node.start(this.startTime + this.t); // 安排帧播放时间
                    this.nodeList.push(node); // 添加节点到列表
                    this.t += buffer.duration; // 更新进度
                }
            }

            // 停止播放
            stop() {
                if (this.stopped) throw new Error("QFPPlayer already stopped.");
                for (const node of this.nodeList) {
                    node.disconnect(); // 断开所有音频节点
                }
                this.stopped = true;
            }

            // 重新播放
            replay() {
                this.stop(); // 停止当前播放
                this.t = 0; // 重置播放进度
                this.stopped = false;
                this.started = false;
                this.qfp.reset(); // 重置解码器
                this.start(); // 重新启动播放
            }

            setOption(key, value) {
                this.qfp.setOption(key, value)
            }
        }

        let paused = true;
        let player;

        // 监听文件输入事件，用于加载音频文件
        document.getElementById('fileInput').addEventListener('change', e => {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a file.'); // 未选择文件时提示
                return;
            }

            const reader = new FileReader(); // 创建文件读取器

            // 将文件读取为 ArrayBuffer
            reader.readAsArrayBuffer(file);

            reader.onload = function (event) {
                try {
                    const arrayBuffer = event.target.result; // 获取读取结果

                    let qfp = qfpFactory(arrayBuffer); // 创建解码器实例
                    if (player) player.stop(); // 如果已有播放器实例，先停止
                    player = new QFPPlayer(qfp); // 创建新的播放器实例
                    player.start(); // 开始播放

                    document.querySelectorAll('.player-opt').forEach(e => {
                        e.style.display = 'none'
                    })

                    document.getElementById("settings-" + qfp.getVersion()).style.display = 'block'

                    // 如果当前是暂停状态，自动开始播放
                    if (paused) pauseBtn.click();
                } catch (error) {
                    alert("Error decoding QFP:" + error.message); // 解码错误提示
                    console.error(error);
                    throw error;
                }
            };

            reader.onerror = function (event) {
                console.error('Error reading file:', event); // 输出错误日志
                alert('Error reading file.'); // 提示文件读取错误
            };
        });

        // 暂停按钮控制逻辑
        let pauseBtn = document.getElementById('pause');
        pauseBtn.addEventListener('click', function () {
            paused = !paused; // 切换播放状态

            if (paused) {
                ctx.suspend(); // 暂停音频上下文
                pauseBtn.innerHTML = '播放'; // 更新按钮文本为“播放”
            } else {
                ctx.resume(); // 恢复音频上下文
                pauseBtn.innerHTML = '暂停'; // 更新按钮文本为“暂停”
            }
        });

        // 重新播放按钮
        document.getElementById('replay').addEventListener('click', e => {
            player.replay(); // 调用播放器重新播放方法
        });

        // 编码按钮逻辑
        const encodeBtn = document.getElementById('encode');

        const showEncodeProgress = (currentTime, duration) => {
            const percent = Math.min(100, currentTime / duration * 100); // 确保百分比不超过100
            encodeProgressDisplay.style.width = percent + "%"; // 更新进度条宽度
            encodeTimeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`; // 更新显示的时间
            return new Promise(resolve => {
                setTimeout(resolve, 0); // 模拟延时
            });
        }

        encodeBtn.addEventListener('click', e => {
            const fileInput = document.getElementById('audioInput');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a file.'); // 未选择文件时提示
                return;
            }
            encodeBtn.disabled = true; // 编码过程中禁用按钮

            const promise = new Promise((resolve, reject) => {
                const reader = new FileReader(); // 创建文件读取器

                // 将文件读取为 ArrayBuffer
                reader.readAsArrayBuffer(file);

                reader.onload = function (event) {
                    const arrayBuffer = event.target.result; // 获取读取结果
                    ctx.decodeAudioData(arrayBuffer).then(async data => {
                        const encoder = qfpEncoderFactory(data, parseInt(document.getElementById('qp').value)); // 创建编码器实例
                        const chunks = [];

                        // 编码头部信息
                        const header = encoder.encodeHeader();
                        const sampleRate = encoder.sampleRate || ctx.sampleRate; // 获取采样率
                        const duration = encoder.numWins * (encoder.frameLength() / sampleRate); // 计算总时长

                        // 编码音频帧
                        let encodedFrames = 0;
                        while (encoder.available()) {
                            for (const frame of encoder.encodeFrame()) {
                                chunks.push(frame);
                            }
                            encodedFrames++;
                            if (encodedFrames % 100 === 0) {
                                const currentTime = encodedFrames * (encoder.frameLength() / sampleRate); // 计算当前编码时间
                                await showEncodeProgress(currentTime, duration); // 更新进度条
                                // await showEncodeProgress((encodedFrames / encoder.numWins) * 100); // 更新进度条
                                console.log(`Encoded ${encodedFrames} frames`); // 输出编码进度
                            }
                        }
                        await showEncodeProgress(duration, duration); // 完成时更新进度条为100%

                        // 合并所有帧为一个 Uint8Array
                        const combinedChunks = new Uint8Array(chunks.reduce((acc, chunk) => acc + chunk.byteLength, 0));
                        let offset = 0;
                        for (const chunk of chunks) {
                            combinedChunks.set(new Uint8Array(chunk), offset);
                            offset += chunk.byteLength;
                        }

                        // 使用 pako 压缩数据
                        const compressedData = pako.deflate(combinedChunks);

                        // 创建 Blob 并生成下载链接
                        const blob = new Blob([header, compressedData], { type: "application/octet-stream" });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement("a");
                        a.href = url;
                        a.download = replaceFileExtension(file.name, "qfp"); // 设置文件名
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url); // 清理 URL
                        resolve();
                    }).catch(e => {
                        console.error(e);
                        reject("Error encoding audio: " + e); // 编码失败
                    });
                };

                reader.onerror = function (event) {
                    reject('Error reading file:' + event); // 文件读取失败
                };
            });

            promise.catch(e => alert(e)).finally(() => encodeBtn.disabled = false); // 最终启用按钮
        });

        document.querySelectorAll('.player-opt-item').forEach(e => {
            e.addEventListener('change', () => {
                player.setOption(e.dataset.key, e.checked)
            })
        })
    </script>
</body>

</html>