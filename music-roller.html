
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>音乐过山车</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* 隐藏滚动条 */
        }

        canvas {
            display: block; /* 移除 canvas 下方的空隙 */
            width: 100%;
            height: 100%;
            background-color: #000;
        }

        #fileInput {
           /* display: none; /* 隐藏文件上传 input */
        }

        #progressBarContainer {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 10px;
            background-color: #ddd;
        }

        #progressBar {
            width: 0%;
            height: 100%;
            background-color: #4CAF50;
        }
    </style>
</head>
<body>
    <canvas id="musicCanvas"></canvas>
    <input type="file" id="fileInput" accept="audio/*">
    <div id="progressBarContainer">
        <div id="progressBar"></div>
    </div>
    <audio id="player" hidden>
<!-- 在 HTML 中插入以下代码 -->
<script src="//cdn.jsdelivr.net/npm/eruda"></script>
<script>eruda.init();</script>

    <script>
        const canvas = document.getElementById('musicCanvas');
        const ctx = canvas.getContext('2d');
        const fileInput = document.getElementById('fileInput');
        const progressBar = document.getElementById('progressBar');
        const player = document.getElementById('player')
        const audioCtx = new AudioContext();
        
       /* const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;

        // 计算 Canvas 中心点的坐标
        const centerX = canvasWidth / 2;
        const centerY = canvasHeight / 2;

        // 将 Canvas 的原点移动到中心点
        ctx.translate(centerX, centerY);*/
        
        async function fileToAudioBuffer(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();

    reader.onload = function(event) {
      //const audioContext = new (window.AudioContext || window.webkitAudioContext)();

      audioCtx.decodeAudioData(event.target.result,
        (buffer) => {
          resolve(buffer);
        },
        (error) => {
          reject(error);
        }
      );
    };

    reader.onerror = function(error) {
      reject(error);
    };

    reader.readAsArrayBuffer(file);
  });
}

function calculateRMS(buffer, intervalInSeconds) {
  const rawData = buffer.getChannelData(0);
  const sampleRate = buffer.sampleRate;
  const bufferSize = rawData.length;
  const rmsValues = [];

  let startIdx = 0;
  while (startIdx < bufferSize) {
    const endIdx = Math.min(startIdx + Math.round(intervalInSeconds * sampleRate), bufferSize);
    const interval = endIdx - startIdx; // 实际的采样点数量

    let sumOfSquares = 0;
    for (let j = startIdx; j < endIdx; j++) {
      const sample = rawData[j];
      sumOfSquares += sample * sample;
    }
    const rms = Math.sqrt(sumOfSquares / interval);
    rmsValues.push(rms);

    startIdx = endIdx;
  }

  return rmsValues;
}

function rmsToDb(rmsValues, reference = 1) {
  const dbValues = [];

  for (let i = 0; i < rmsValues.length; i++) {
    const rms = rmsValues[i];
    const db = 20 * Math.log10(rms / reference);
    dbValues.push(db);
  }

  return dbValues;
}
function calculateTrackPoints(amplitudeData, scaleFactor = 1, slopeFactor = 45) {
    const points = [];
    let x = 0, y = 0;
    
    // 计算动态分界点
    const sum = amplitudeData.reduce((acc, val) => acc + val, 0);
    const turning = sum / amplitudeData.length;       // 平均值作为分界点
    const lowerBound = turning - 40;                  // 新下限 = 平均值 -40
    const maxAmplitude = Math.max(...amplitudeData);   // 保留最大值计算

    for (const amplitude of amplitudeData) {
        let angle;
        
        // 智能角度映射
        if (amplitude > turning) {
            // 高于平均值：slopeFactor° ~ 0°
            const range = Math.max(maxAmplitude - turning, 1);    // 防除零且最小跨度1
            const ratio = Math.min((amplitude - turning) / range, 1); // 限制最大比例
            angle = slopeFactor * (1 - ratio);
        } else {
            // 低于平均值：0° ~ -slopeFactor°
            const range = Math.max(turning - lowerBound, 1);       // 强制有效范围
            const safeAmplitude = Math.max(amplitude, lowerBound); // 防止数值越界
            const ratio = (turning - safeAmplitude) / range;
            angle = -slopeFactor * ratio;
        }
        
        let length =(1-(maxAmplitude- amplitude) / (maxAmplitude - lowerBound))*5
        if (!isFinite(length) || isNaN(length)) length = 0;
        
        
        // 增量计算
        let deltaY = Math.tan(angle * Math.PI / 180) * scaleFactor* length;
        if (!isFinite(deltaY) || isNaN(deltaY)) deltaY = 0;
        points.push({ x, y: y += deltaY });
        x += scaleFactor*length;
    }
    
    return points;
}



function getHsvColor(amplitude, maxAmplitude) {
    const hue = 240 * (1 - amplitude / maxAmplitude);  // 蓝色到红色渐变
    return `hsv(${hue}, 100%, 50%)`;
}


function drawFrame(track, time) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 计算当前帧索引
    let idx = Math.floor(time * 120);
    idx = Math.max(0, Math.min(idx, track.length - 1)); // 边界保护
    
    // 中心点坐标
    const currentPoint = track[idx];
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    // 绘制双向轨道
    ctx.strokeStyle = "white";
    ctx.beginPath();
    
    // 起始点定位到屏幕中心
    ctx.moveTo(centerX, centerY);
    
    // 向左绘制轨道 (逆向绘制)
    let leftX = centerX;
    for(let i = 1; ; i++) {
        const line = track[idx - i];
        if (!line || leftX < 0) break;
        
        // 计算相对坐标
        const currentX = (line.x - currentPoint.x) + centerX;
        const currentY = (line.y - currentPoint.y) + centerY;
        
        ctx.lineTo(currentX, currentY);
        leftX = currentX;
    }
    
    // 回到中心点
    ctx.moveTo(centerX, centerY);
    
    // 向右绘制轨道 (正向绘制)
    let rightX = centerX;
    for(let i = 1; ; i++) {
        const line = track[idx + i];
        if (!line || rightX > canvas.width) break;
        
        const currentX = (line.x - currentPoint.x) + centerX;
        const currentY = (line.y - currentPoint.y) + centerY;
        
        ctx.lineTo(currentX, currentY);
        rightX = currentX;
    }
    
    ctx.stroke();
    
    // 绘制中心小球
    ctx.beginPath();
    ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
    ctx.fillStyle = "red";
    ctx.fill();
}


        // 设置 canvas 尺寸为全屏
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // 点击 canvas 触发文件上传
        canvas.addEventListener('click', function() {
            fileInput.click();
        });

        // 文件上传处理
        fileInput.addEventListener('change',async function(e) {
            const file = e.target.files[0];
            if (file) {
                // TODO: 加载和解析音频文件，生成过山车动画
                console.log('Selected file:', file);
                // 示例：更新进度条
                updateProgressBar(50); // 假设加载进度为 50%
                
                const buffer = await fileToAudioBuffer(file)
                
                const rms = rmsToDb(calculateRMS(buffer, 1/120))
                const track = calculateTrackPoints(rms)
                
                console.log(track)
                
                const url =URL.createObjectURL(file)
                player.src=url
                player.play()
                
                let update=()=>{
                	drawFrame(track,player.currentTime)
                	updateProgressBar(player.currentTime/player.duration*100)
                	requestAnimationFrame(update)
                }
                requestAnimationFrame(update)
            }
        });

        // 更新进度条
        function updateProgressBar(percentage) {
            progressBar.style.width = percentage + '%';
        }

        // TODO: 添加音频可视化和过山车动画代码
    </script>
</body>
</html>
