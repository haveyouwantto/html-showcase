<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="description" content="Infinite deep and fast Mandelbrot set explorer">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mandelbrot Perturbation</title>
    <style>
        :root {
            --theme-color: #ff4081;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: hidden;
            /* Prevent scrollbars */
        }

        #mandelbrot {
            position: fixed;
            top: 0;
            left: 0;
            width: 100dvw;
            height: 100dvh;
            cursor: grab;
            background: repeating-linear-gradient(45deg, var(--theme-color), var(--theme-color) 8px, #000 8px, #000 16px);
            /* For smoother transforms */
            transform-origin: 0 0;
            will-change: transform;
        }

        #mandelbrot:active {
            cursor: grabbing;
        }

        .transition {
            transition: transform 0.1s ease-out;
        }

        .transition-long {
            transition: transform 0.2s ease-in-out;
        }

        #menu-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1002;
            font-size: 24px;
            width: 40px;
            height: 40px;
            background-color: rgba(51, 51, 51, 0.8);
            color: #fff;
            border: 1px solid #666;
            border-radius: 5px;
            cursor: pointer;
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        #menu-toggle:hover {
            background-color: var(--theme-color);
        }

        #sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: 300px;
            height: 100dvh;
            background-color: #2a2a2a;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.5);
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
            z-index: 1001;
            overflow-y: auto;
            padding: 10px;
            box-sizing: border-box;
        }

        #sidebar.open {
            transform: translateX(0);
        }

        #info-overlay {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 5px;
            font-size: 0.9rem;
            z-index: 1000;
            max-width: 90vw;
            transition: 0.3s ease-in-out;
            margin-top: 10px;
        }

        #info-location {
            margin-bottom: 5px;
            word-break: break-all;
        }

        .info-overlay-collapsed {
            width: 40px !important;
            height: 40px !important;
            padding: 0 !important;
        }

        .info-overlay-collapsed::after {
            content: "‚ÑπÔ∏è";
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        .info-overlay-collapsed * {
            display: none !important;
        }

        .info-overlay-collapsed:hover {
            background-color: var(--theme-color) !important;
            cursor: pointer;
        }

        .progress-container {
            display: flex;
            z-index: 999;
            width: 100%;
            position: fixed;
            height: 4px;
        }

        dialog .progress-container {
            background-color: #00000080;
        }

        .progress {
            background-color: white;
            width: 0;
            height: 100%;
        }

        .guessed-progress {
            background-color: rgba(255, 255, 255, 0.5);
        }

        /* Inherited styles for controls inside sidebar */
        .location {
            display: flex;
            flex-direction: column;
        }

        button {
            margin-top: 8px;
            background-color: #333;
            color: #fff;
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: var(--theme-color);
        }

        button:disabled {
            filter: brightness(0.5);
            cursor: not-allowed;
        }

        .icon {
            font-size: 30px;
            font-family: emoji;
            font-weight: bold;
            width: 35px;
            height: 35px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        textarea {
            background-color: #333;
            color: #fff;
            border: 1px solid #666;
            padding: 4px;
            resize: vertical;
            font-size: 0.8rem;
        }

        .shortcut {
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        .running {
            cursor: wait !important;
        }

        hr {
            width: 100%;
            border: 1px solid #444;
            /* Dark color for the horizontal rule */
            margin: 20px 0;
            /* Adjust margin as needed */
        }

        select {
            background-color: #333;
            /* Dark background color for select dropdown */
            color: #fff;
            /* Light text color for select options */
            padding: 8px;
            border: 1px solid #666;
            /* Dark border color */
            border-radius: 4px;
            appearance: none;
            /* Remove default appearance */
            transition: background-color 0.3s;
        }

        select:hover,
        select:focus {
            background-color: #444;
            /* Change background color on hover/focus */
        }

        .shortcut {
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        .running,
        .rendering-video {
            outline: var(--theme-color) 4px solid;
            pointer-events: none !important;
            filter: grayscale(0.5);
            cursor: wait !important;
        }

        .video-progress-container {
            width: 100%;
            height: 6px;
            background-color: #333;
            overflow: hidden;
            margin: 10px 0;
        }

        .video-progress-fill {
            height: 100%;
            background: white;
            width: 0%;
            transition: width 0.3s ease;
        }

        #video-progress-dialog,
        #video-config-dialog {
            background-color: #222;
            color: white;
            border: 1px solid #666;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            width: 350px;
            text-align: center;
        }

        #video-progress-dialog h3,
        #video-config-dialog h3 {
            margin-top: 0;
            color: white;
        }

        .video-config-field {
            margin-bottom: 15px;
            text-align: left;
        }

        .video-config-field label {
            display: block;
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .video-config-field input {
            width: 100%;
            box-sizing: border-box;
        }

        #video-preview-canvas {
            width: 100%;
            height: auto;
            max-height: 200px;
            border: 1px solid #444;
            margin: 10px 0;
            background-color: #000;
        }

        .video-btn-cancel,
        .video-btn-start {
            background-color: #333;
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
            width: 100%;
            transition: background-color 0.3s;
            border-radius: 0;
        }

        .video-btn-start {
            background-color: var(--theme-color);
        }

        .video-btn-cancel:hover {
            background-color: #444;
        }

        .video-btn-start:hover {
            filter: brightness(1.1);
        }

        /* Unified Rectangular Styles */
        dialog input,
        dialog select,
        dialog button,
        dialog textarea {
            border-radius: 0 !important;
        }

        /* Video Editor Styles */
        .video-editor-fullscreen {
            width: 95vw;
            max-width: 1600px;
            height: 90vh;
            max-height: none;
            padding: 0;
            background-color: #1a1a1a;
            color: #fff;
            border: 2px solid var(--theme-color);
        }

        .video-editor-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background-color: #222;
            border-bottom: 2px solid var(--theme-color);
        }

        .editor-header h2 {
            margin: 0;
            font-size: 1.5rem;
        }

        .editor-close-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: 2rem;
            cursor: pointer;
            padding: 0;
            width: 40px;
            height: 40px;
            line-height: 1;
        }

        .editor-close-btn:hover {
            color: var(--theme-color);
        }

        .editor-main {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .editor-left {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
        }

        .editor-right {
            width: 320px;
            padding: 20px;
            background-color: #1f1f1f;
            border-left: 1px solid #333;
            overflow-y: auto;
        }

        .preview-section {
            margin-bottom: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #000;
            padding: 10px;
            border: 1px solid #333;
            position: relative;
        }

        #editor-preview-wrapper:fullscreen {
            width: 100vw;
            height: 100vh;
            justify-content: center;
            padding: 0;
            margin: 0;
            border: none;
        }

        #editor-preview-wrapper:fullscreen canvas {
            max-height: 85vh;
        }

        #editor-preview-wrapper:fullscreen .playback-controls {
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.5);
            width: 90%;
        }

        #editor-preview-canvas {
            max-width: 100%;
            height: auto;
            flex: 1;
            display: block;
            object-fit: contain;
        }

        .playback-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            width: 100%;
        }

        .playback-btn {
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 1rem;
        }

        .playback-btn:hover {
            background-color: #444;
        }

        #timeline-scrubber {
            flex: 1;
            height: 6px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        #timeline-scrubber::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--theme-color);
            cursor: pointer;
        }

        .time-display {
            font-size: 0.9rem;
            color: #aaa;
            white-space: nowrap;
        }

        .timeline-section {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .timeline-section h3 {
            margin: 0 0 10px 0;
        }

        .timeline-controls {
            margin-bottom: 10px;
        }

        .small-btn {
            background-color: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .small-btn:hover {
            background-color: #444;
        }

        .timeline-list {
            flex: 1;
            overflow-y: auto;
            border: 1px solid #333;
            padding: 10px;
            background-color: #1a1a1a;
        }

        .control-point-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background-color: #252525;
            border: 1px solid #333;
            margin-bottom: 8px;
        }

        .control-point-item input {
            flex: 1;
            width: 0;
            min-width: 0;
            background-color: #1a1a1a;
            color: #fff;
            border: 1px solid #444;
            padding: 4px 8px;
        }

        .control-point-item button {
            background-color: #d33;
            color: #fff;
            border: none;
            padding: 4px 8px;
            cursor: pointer;
        }

        .setting-group {
            margin-bottom: 15px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            color: #aaa;
        }

        .setting-group input[type="number"] {
            width: 100%;
            background-color: #2a2a2a;
            color: #fff;
            border: 1px solid #444;
            padding: 8px;
        }

        .resolution-inputs {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .resolution-inputs input {
            flex: 1;
            width: 0;
            min-width: 0;
        }

        .keyframe-info {
            background-color: #252525;
            border: 1px solid #444;
            padding: 12px;
            margin-bottom: 15px;
            font-size: 0.85rem;
        }

        .keyframe-info .info-status {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .keyframe-info .info-detail {
            color: #aaa;
            margin: 3px 0;
        }

        .editor-btn {
            width: 100%;
            padding: 10px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .editor-btn.primary {
            background-color: var(--theme-color);
            color: #000;
        }

        .editor-btn.secondary {
            background-color: #555;
            color: #fff;
        }

        .editor-btn.export {
            background-color: #28a745;
            color: #fff;
        }

        .editor-btn:disabled {
            background-color: #333;
            color: #666;
            cursor: not-allowed;
        }

        .editor-btn:not(:disabled):hover {
            filter: brightness(1.1);
        }

        /* Mobile Optimization for Video Editor */
        @media (max-width: 850px) {
            .video-editor-fullscreen {
                width: 100vw;
                height: 100vh;
                max-width: none;
                max-height: none;
                border: none;
            }

            .editor-main {
                flex-direction: column;
                overflow-y: auto;
            }

            .editor-left {
                flex: none;
                padding: 10px;
                overflow-y: visible;
            }

            .editor-right {
                width: 100%;
                border-left: none;
                border-top: 1px solid #333;
                padding: 15px;
                flex: none;
                overflow-y: visible;
                background-color: #1a1a1a;
            }

            .preview-section {
                padding: 5px;
                margin-bottom: 10px;
            }

            .playback-controls {
                gap: 5px;
                justify-content: center;
            }

            .playback-btn {
                padding: 6px 12px;
                font-size: 0.9rem;
            }

            .time-display {
                font-size: 0.8rem;
                width: 100%;
                text-align: center;
                margin-top: 5px;
            }

            #timeline-scrubber {
                order: 10;
                margin-top: 10px;
            }

            .control-point-item {
                gap: 5px;
                padding: 5px;
                flex-wrap: wrap;
                justify-content: space-between;
            }

            .control-point-item label {
                font-size: 0.75rem;
                flex: none;
                width: auto;
            }

            .control-point-item input {
                padding: 4px;
                font-size: 0.85rem;
                min-width: 60px;
            }

            .timeline-list {
                padding: 5px;
            }

            .editor-header h2 {
                font-size: 1.1rem;
            }

            .editor-close-btn {
                font-size: 1.5rem;
            }

            dialog {
                width: 95vw !important;
                padding: 15px !important;
            }

            #video-preview-canvas {
                max-width: 100% !important;
                height: auto !important;
            }
        }

        #color-list {
            list-style: none;
            outline: 1px solid var(--theme-color);
            padding: 8px;
            margin: 8px;
            flex-wrap: wrap;
            max-height: 60dvh;
            overflow-y: auto;
        }

        dialog {
            width: 400px;
            padding: 20px;
            background-color: #222;
            color: #fff;
            border: none;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            max-width: 90%;
            max-height: 90dvh;
        }

        #palette-dialog h2 {
            margin-top: 0;
        }

        #palette-dialog::backdrop {
            background-color: rgba(0, 0, 0, 0.5);
            /* Semi-transparent backdrop */
        }

        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            padding: 0;
            margin: 0;
            cursor: pointer;
            appearance: none;
            background: none;
        }

        input[type="number"] {
            padding: 4px;
            border: 1px solid #666;
            background-color: #333;
            color: #fff;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
            width: 20px;
            height: 20px;
            accent-color: var(--theme-color);
        }

        .color-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        #smart-zoom {
            position: fixed;
            top: 60px;
            right: 10px;
            z-index: 1002;
            font-size: 24px;
            width: 40px;
            height: 40px;
            background-color: rgba(51, 51, 51, 0.8);
            color: #fff;
            border: 1px solid #666;
            border-radius: 5px;
            cursor: pointer;
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }


        @media (max-width: 600px) {
            .container {
                flex-direction: column;
            }

            #mandelbrot {
                width: 100%;
                height: auto;
            }

            .location {
                margin-left: 0;
            }

            .shortcut {
                justify-content: space-evenly;
            }
        }
    </style>
</head>

<body>
    <canvas id="mandelbrot" width="800" height="800"></canvas>

    <div id="info-overlay" class="info-overlay-collapsed">
        <div id="info-location">
            <div>Re: <span id="info-re"></span></div>
            <div>Im: <span id="info-im"></span></div>
            <div>Zoom: <span id="info-zoom"></span></div>
            <div>Iterations: <span id="info-iter"></span></div>
        </div>
        <div id="stats"></div>
    </div>
    <div class="progress-container">
        <div id="progress" class="progress"></div>
        <div id="guessed-progress" class="progress guessed-progress"></div>
    </div>

    <button id="menu-toggle" title="Toggle Controls">&#9776;</button>
    <button id="smart-zoom" title="Smart Zoom">üîç</button>

    <aside id="sidebar">
        <!-- ÊâÄÊúâÂéüÂßãÁöÑÊéß‰ª∂ÈÉΩÁßªÂä®Âà∞ËøôÈáå -->
        <div class="location">
            Real:
            <textarea id="re" class="large" rows="6"></textarea><br>
            Imaginary:
            <textarea id="im" class="large" rows="6"></textarea><br>
            Zoom:
            <textarea id="zoom" rows="2"></textarea><br>
            Iterations:
            <textarea id="it" rows="1"></textarea>
            <div class="shortcut">
                <button class="icon control-button" id="zoom-in" title="Zoom in">&#10133;</button>
                <button class="icon control-button" id="zoom-out" title="Zoom out">&#10134;</button>
                <button class="icon control-button" id="increase-iter" title="Iterations x2">&#128314;</button>
                <button class="icon control-button" id="decrease-iter" title="Iterations /2">&#128315;</button>
            </div>
            <div class="shortcut">
                <button class="icon control-button" id="goto" title="Go to location">&#128640;</button>
                <button class="icon control-button" id="home" title="Reset view">&#127968;</button>
                <button class="icon control-button" id="palette" title="Palette Editor">üé®</button>
                <button class="icon control-button" id="download" title="Download PNG">&#128248;</button>
            </div>
            <div class="shortcut">
                <button class="icon control-button" id="iteration-button" title="Iteration Settings">üîß</button>
                <button class="icon control-button" id="kfr" title="Load KFR file">üìÇ</button>
                <button class="icon control-button" id="save-kfr" title="Save KFR file">üíæ</button>
                <button class="icon control-button" id="makeVideo" title="Make Video">üé•</button>
            </div>
            <div class="shortcut">
                <button class="icon control-button" id="fullscreen" title="Toggle Fullscreen">‚õ∂</button>
            </div>
            <hr>
            Samples
            <select id="samples">
                <option value="seahorse">Seahorse</option>
                <option value="snowflake">Snowflake</option>
                <option value="spiral">Spiral</option>
                <option value="luxury">Luxury</option>
                <option value="horizon">Horizon</option>
                <option value="flora">Flora</option>
                <option value="classic">Classic</option>
                <option value="e200">E200</option>
                <option value="radiant">Radiant</option>
                <option value="branches">Branches</option>
            </select>
            <button id="load-sample" class="control-button">Load</button>
        </div>
        <div id="more"></div>
    </aside>

    <!-- Dialogs remain unchanged -->
    <dialog id="palette-dialog">
        <h2>Color Settings</h2>
        <label for="color-step">Color Step:</label>
        <input type="number" id="color-step" value="1" min="1" max="100" step="1"><br>
        <div id="random-group">
            <label for="algorithm-select">Generation Scheme:</label>
            <select id="algorithm-select">
                <option value="random">Fully Random</option>
                <option value="random-bw">B&W Phases</option>
                <option value="wandering" selected>Wandering Hue</option>
                <option value="golden">Golden Ratio</option>
                <option value="teal-orange">Cinematic Teal-Orange</option>
                <option value="organic-sine">Organic Waves</option>
            </select>
            <button id="random-colors">Random</button>
        </div>
        <ol id="color-list">
            <!-- Color settings -->
        </ol>
        <button id="apply-colors">Apply</button>
        <button id="reset-colors">Reset</button>
        <button id="close-dialog">Close</button>
    </dialog>
    <dialog id="iteration-dialog">
        <h2>Iteration Settings</h2>
        <label for="bailout">Bailout:</label>
        <input type="number" id="bailout" value="16" min="2" step="1"><br>
        <label for="smooth">Smooth:</label>
        <input type="checkbox" id="smooth" checked><br>
        <button id="apply-iter">Apply</button>
        <button id="close-iter-dialog">Close</button>
    </dialog>

    <dialog id="video-config-dialog">
        <h3>Video Settings</h3>
        <div class="video-config-field">
            <label for="video-preset">Resolution Preset:</label>
            <select id="video-preset">
                <option value="custom">Custom</option>
                <option value="720p">720p (1280x720)</option>
                <option value="1080p" selected>1080p (1920x1080)</option>
                <option value="2k">2K (2560x1440)</option>
                <option value="4k">4K (3840x2160)</option>
            </select>
        </div>
        <div class="video-config-field">
            <label for="video-width">Width (px):</label>
            <input type="number" id="video-width" value="1920" min="100" max="8192">
        </div>
        <div class="video-config-field">
            <label for="video-height">Height (px):</label>
            <input type="number" id="video-height" value="1080" min="100" max="8192">
        </div>
        <div class="video-config-field">
            <label for="video-fps">FPS:</label>
            <input type="number" id="video-fps" value="30" min="1" max="60">
        </div>
        <button id="video-config-start" class="video-btn-start">Start Rendering</button>
        <button id="video-config-cancel" class="video-btn-cancel">Cancel</button>
    </dialog>

    <dialog id="video-progress-dialog">
        <h3>Video Generation</h3>
        <p id="video-stage">Initializing...</p>

        <canvas id="video-preview-canvas"></canvas>

        <div style="text-align: left; font-size: 0.8rem; margin-bottom: 2px;">Overall Progress</div>
        <div class="progress-container" style="height: 6px; margin: 5px 0 15px 0; position: relative; width: 100%;">
            <div id="video-total-progress" class="progress"></div>
        </div>

        <div style="text-align: left; font-size: 0.8rem; margin-bottom: 2px;">Current Frame</div>
        <div class="progress-container" style="height: 6px; margin: 5px 0 10px 0; position: relative; width: 100%;">
            <div id="video-frame-progress" class="progress"></div>
        </div>

        <p id="video-status" style="font-size: 0.8rem; color: #aaa;">Please wait...</p>

        <button id="video-cancel" class="video-btn-cancel">Cancel Video</button>
    </dialog>

    <!-- Video Editor Dialog (New) -->
    <dialog id="video-editor-dialog" class="video-editor-fullscreen">
        <div class="video-editor-container">
            <!-- Header -->
            <div class="editor-header">
                <h2>üé¨ Video Editor</h2>
                <button id="editor-close" class="editor-close-btn">√ó</button>
            </div>

            <!-- Main Content Area -->
            <div class="editor-main">
                <!-- Preview & Timeline Section -->
                <div class="editor-left">
                    <!-- Preview Canvas -->
                    <div class="preview-section" id="editor-preview-wrapper">
                        <canvas id="editor-preview-canvas"></canvas>
                        <div class="playback-controls">
                            <button id="play-pause-btn" class="playback-btn">‚ñ∂</button>
                            <button id="stop-btn" class="playback-btn">‚èπ</button>
                            <input type="range" id="timeline-scrubber" min="0" max="1000" value="0">
                            <span class="time-display">
                                <span id="current-time">0.0</span>s / <span id="total-duration">0.0</span>s
                            </span>
                            <button id="fullscreen-btn" class="playback-btn">‚õ∂</button>
                        </div>
                    </div>

                    <!-- Timeline Editor -->
                    <div class="timeline-section">
                        <h3>Timeline Control Points</h3>
                        <div class="timeline-controls">
                            <button id="add-control-point" class="small-btn">+ Add Point</button>
                        </div>
                        <div class="timeline-list" id="timeline-list">
                            <!-- Control points will be added here dynamically -->
                        </div>
                    </div>
                </div>

                <!-- Settings Panel -->
                <div class="editor-right">
                    <h3>Video Settings</h3>

                    <div class="setting-group">
                        <label for="editor-preset">Resolution Preset</label>
                        <select id="editor-preset">
                            <option value="custom">Custom</option>
                            <option value="720p">720p (1280√ó720)</option>
                            <option value="1080p" selected>1080p (1920√ó1080)</option>
                            <option value="2k">2K (2560√ó1440)</option>
                            <option value="4k">4K (3840√ó2160)</option>
                            <option value="8k">8K (7680√ó4320)</option>
                        </select>
                    </div>

                    <div class="setting-group">
                        <label>Custom Resolution</label>
                        <div class="resolution-inputs">
                            <input type="number" id="editor-width" value="1920" min="100" max="8192">
                            <span>√ó</span>
                            <input type="number" id="editor-height" value="1080" min="100" max="8192">
                        </div>
                    </div>

                    <div class="setting-group">
                        <label for="editor-fps">FPS</label>
                        <input type="number" id="editor-fps" value="30" min="1" max="120">
                    </div>

                    <div class="keyframe-info" id="keyframe-info">
                        <div class="info-status">Keyframes: Not Collected</div>
                    </div>

                    <button id="collect-keyframes-btn" class="editor-btn primary">Collect Keyframes</button>
                    <button id="resume-keyframes-btn" class="editor-btn secondary">Resume Rendering</button>
                    <button id="clear-keyframes-btn" class="editor-btn secondary" style="display: none;">Clear
                        Keyframes</button>

                    <hr>

                    <button id="export-video-btn" class="editor-btn export" disabled>Export Video</button>
                </div>
            </div>
        </div>
    </dialog>

    <script src="lib/decimal.9.0.0.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gmp-wasm"></script>
    <script src="https://w3c.github.io/webcodecs/samples/capture-to-file/webm-writer2.js"></script>
    <script>
        const canvas = document.getElementById('mandelbrot');
        const reInput = document.getElementById('re')
        const imInput = document.getElementById('im');
        const zoomInput = document.getElementById('zoom')
        const itInput = document.getElementById('it')
        const statsLabel = document.getElementById('stats')
        const progressBar = document.getElementById('progress');
        const guessedProgressBar = document.getElementById('guessed-progress');
        const sampleSelect = document.getElementById('samples')
        const sampleLoadBtn = document.getElementById('load-sample')
        const more = document.getElementById("more");


        const CPU_CORES = Math.max(navigator.hardwareConcurrency ?? 1, 1);

        class FloatExp {
            static expTable = [];
            static LOG2_10 = Math.log2(10);
            static LOG10_2 = Math.log10(2);
            static buffer = new ArrayBuffer(8);
            static floatView = new Float64Array(FloatExp.buffer);
            static int32View = new Int32Array(FloatExp.buffer);

            // Pre-allocate standard constants to avoid recreation
            static ZERO = new FloatExp(0, 0);
            static ONE = new FloatExp(1, 0);
            static NEGATIVE_ONE = new FloatExp(-1, 0);
            static TWO = new FloatExp(2, 0);
            static FOUR = new FloatExp(4, 0);
            static INFINITY = new FloatExp(1, Number.MAX_SAFE_INTEGER); // Set a very high exponent to represent infinity
            static NEGATIVE_INFINITY = new FloatExp(-1, Number.MAX_SAFE_INTEGER);

            static {
                this.expTable = [];
                for (let i = 0; i < 324 + 308; i++) {
                    this.expTable[i] = Math.pow(10, i - 324);
                }
            }

            static getExp(exp) {
                if (exp < -324) return 0;
                else if (exp > 308) return Infinity;
                return this.expTable[exp + 324];
            }

            static getExpOfDouble(d) {
                if (d === 0) throw new Error("Exponent of zero is undefined.");

                // Inlining some logic for speed could be done here, 
                // but keeping original logic for safety as provided.
                const LOG10_2 = Math.LOG10E;
                const BIAS = 1023;
                FloatExp.floatView[0] = d;
                const highBits = FloatExp.int32View[1];
                const lowBits = FloatExp.int32View[0];
                const rawExp = (highBits >>> 20) & 0x7FF;

                let actualExp;
                if (rawExp === 0) {
                    let mantissaHigh = highBits & 0xFFFFF;
                    const mantissaLow = lowBits;
                    let leadingZeros = 0;
                    if (mantissaHigh === 0) {
                        leadingZeros += 32;
                        let temp = mantissaLow;
                        while (temp !== 0 && (temp & 0x80000000) === 0) {
                            temp <<= 1;
                            leadingZeros++;
                        }
                    } else {
                        let temp = mantissaHigh;
                        while ((temp & 0x80000) === 0) {
                            temp <<= 1;
                            leadingZeros++;
                        }
                    }
                    actualExp = -1022 - leadingZeros;
                } else {
                    actualExp = rawExp - BIAS;
                }
                return Math.floor(actualExp * LOG10_2);
            }

            constructor(base, exp = 0, normalize = true) {
                // Removed validations for performance in this hot path, 
                // assuming internal usage ensures validity.
                this.base = base;
                this.exp = exp;
                if (normalize) this.norm();
            }

            norm() {
                if (this.base == 0) {
                    this.exp = 0;
                    return this;
                }

                while (Math.abs(this.base) > 10) {
                    this.base /= 10;
                    this.exp++;
                }

                while (Math.abs(this.base) < 1) {
                    this.base *= 10;
                    this.exp--;
                }

                return this;

                // if (this.base != 0 && (Math.abs(this.base) >= 10 || Math.abs(this.base) < 1)) {
                //     let exp = FloatExp.getExpOfDouble(this.base);
                //     if (exp != 0) {
                //         this.exp += exp;
                //         this.base /= FloatExp.getExp(exp);
                //     }
                // }
                // return this;
            }

            /**
             * Copies the value of this FloatExp into the target `store`.
             * @param {FloatExp} store 
             */
            storeTo(store) {
                store.base = this.base;
                store.exp = this.exp;
                return store;
            }

            // --- Optimized Math Operations ---

            add(other) {
                // Create result container once
                return this.addTo(other, new FloatExp(0, 0, false));
            }

            addMut(other) {
                return this.addTo(other, this);
            }

            addTo(other, store) {
                let oBase, oExp;
                if (typeof other === 'number') {
                    oBase = other;
                    oExp = 0;
                } else {
                    oBase = other.base;
                    oExp = other.exp;
                }

                if (oBase === 0) return this.storeTo(store);
                if (this.base === 0) {
                    store.base = oBase;
                    store.exp = oExp;
                    return store;
                }

                const expDiff = oExp - this.exp;

                if (expDiff === 0) {
                    store.base = this.base + oBase;
                    store.exp = this.exp;
                } else if (expDiff > 16) {
                    store.base = oBase;
                    store.exp = oExp;
                    // No normalization needed here usually if 'other' is already norm, but safe to do so
                    return store;
                } else if (expDiff < -16) {
                    // 'other' is too small to affect 'this'
                    store.base = this.base;
                    store.exp = this.exp;
                    return store;
                } else {
                    store.base = this.base + oBase * FloatExp.getExp(expDiff);
                    store.exp = this.exp;
                }
                return store.norm();
            }

            sub(other) {
                return this.subTo(other, new FloatExp(0, 0, false));
            }

            subMut(other) {
                return this.subTo(other, this);
            }

            subTo(other, store) {
                let oBase, oExp;
                if (typeof other === 'number') {
                    oBase = other;
                    oExp = 0;
                } else {
                    oBase = other.base;
                    oExp = other.exp;
                }

                if (oBase === 0) return this.storeTo(store);
                if (this.base === 0) {
                    store.base = -oBase;
                    store.exp = oExp;
                    return store;
                }

                const expDiff = oExp - this.exp;

                if (expDiff === 0) {
                    store.base = this.base - oBase;
                    store.exp = this.exp;
                } else if (expDiff > 16) {
                    // Result is -other
                    store.base = -oBase;
                    store.exp = oExp;
                    return store;
                } else if (expDiff < -16) {
                    // other is insignificant
                    store.base = this.base;
                    store.exp = this.exp;
                    return store;
                } else {
                    store.base = this.base - oBase * FloatExp.getExp(expDiff);
                    store.exp = this.exp;
                }
                return store.norm();
            }

            mul(other) {
                return this.mulTo(other, new FloatExp(0, 0, false));
            }

            mulMut(other) {
                return this.mulTo(other, this);
            }

            mulTo(other, store) {
                if (other instanceof FloatExp) {
                    store.base = this.base * other.base;
                    store.exp = this.exp + other.exp;
                } else {
                    store.base = this.base * other;
                    store.exp = this.exp;
                }
                return store.norm();
            }

            div(other) {
                return this.divTo(other, new FloatExp(0, 0, false));
            }

            divMut(other) {
                return this.divTo(other, this);
            }

            divTo(other, store) {
                if (other instanceof FloatExp) {
                    store.base = this.base / other.base;
                    store.exp = this.exp - other.exp;
                } else {
                    store.base = this.base / other;
                    store.exp = this.exp;
                }
                return store.norm();
            }

            // --- Other Methods ---

            doubleValue() {
                return this.base * FloatExp.getExp(this.exp);
            }

            toString() {
                this.norm();
                return `${this.base}e${this.exp}`;
            }

            abs() {
                return new FloatExp(Math.abs(this.base), this.exp);
            }

            sqrt() {
                if (this.base < 0) throw new Error("Cannot take square root of negative number");
                if (this.base === 0) return FloatExp.ZERO.copy();

                let newBase = this.base;
                let newExp = this.exp;

                // Â¶ÇÊûúÊåáÊï∞ÊòØÂ•áÊï∞ÔºåÂ∞Ü10ÁöÑÂõ†Â≠êËΩ¨ÁßªÂà∞base‰∏≠
                if (newExp % 2 !== 0) {
                    newBase *= 10;
                    newExp -= 1;
                }

                return new FloatExp(Math.sqrt(newBase), newExp >> 1);
            }

            rev() {
                return new FloatExp(-this.base, this.exp);
            }

            copy() {
                return new FloatExp(this.base, this.exp, false);
            }

            square() {
                return new FloatExp(this.base * this.base, this.exp * 2);
            }

            squareMut() {
                this.base *= this.base;
                this.exp *= 2;
                return this.norm();
            }

            zero() {
                this.base = 0;
                this.exp = 0;
                return this;
            }


            compareTo(o) {
                if (this.base > 0 && o.base < 0) return 1;
                if (this.base < 0 && o.base > 0) return -1;
                if (this.base === 0 && o.base === 0) return 0;
                if (this.base === 0) return o.base > 0 ? -1 : 1;
                if (o.base === 0) return this.base > 0 ? 1 : -1;
                if (this.exp > o.exp) return this.base > 0 ? 1 : -1;
                if (this.exp < o.exp) return this.base > 0 ? -1 : 1;
                if (this.base > o.base) return 1;
                if (this.base < o.base) return -1;
                return 0;
            }

            gt(o) {
                return this.compareTo(o) > 0;
            }

            lt(o) {
                return this.compareTo(o) < 0;
            }

            equals(o) {
                return this.compareTo(o) === 0;
            }

            log2Value() {
                const log2Mantissa = Math.log2(this.base);
                const log2Exponent = this.exp * FloatExp.LOG2_10;
                return log2Mantissa + log2Exponent;
            }

            static fromLog2(val) {
                const log10 = val * FloatExp.LOG10_2;
                return new FloatExp(Math.pow(10, log10 - Math.trunc(log10)), Math.trunc(log10));
            }

            static max(...a) {
                let max = a[0];
                for (let i = 1; i < a.length; i++) {
                    if (a[i].compareTo(max) > 0) {
                        max = a[i];
                    }
                }
                return max;
            }

            static min(...a) {
                let min = a[0];
                for (let i = 1; i < a.length; i++) {
                    if (a[i].compareTo(min) < 0) {
                        min = a[i];
                    }
                }
                return min;
            }
        }

        function normalizeScientificNotation(input) {
            // Â§ÑÁêÜËæìÂÖ•‰∏∫Êï∞Â≠óÁ±ªÂûãÁöÑÊÉÖÂÜµ
            let str = typeof input === 'number' ? String(input) : input.trim();

            // Â§ÑÁêÜÁâπÊÆäÊÉÖÂÜµ
            if (str === '' || str === 'NaN' || str === 'Infinity' || str === '-Infinity') {
                return str;
            }

            // Ê£ÄÊü•ÊòØÂê¶‰∏∫0
            if (str === '0' || str === '-0' || str === '+0') {
                return '0e0';
            }

            // ÊèêÂèñÁ¨¶Âè∑
            let sign = '';
            if (str.startsWith('-') || str.startsWith('+')) {
                sign = str[0];
                str = str.slice(1);
            }

            // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÊòØÁßëÂ≠¶ËÆ°Êï∞Ê≥ï
            const eIndex = str.search(/[eE]/);
            let mantissaStr, originalExponent = 0;

            if (eIndex !== -1) {
                // ÂàÜÁ¶ªÂ∞æÊï∞ÂíåÊåáÊï∞
                mantissaStr = str.slice(0, eIndex);
                const exponentStr = str.slice(eIndex + 1);
                originalExponent = parseInt(exponentStr, 10);

                if (isNaN(originalExponent)) {
                    throw new Error('Invalid exponent format');
                }
            } else {
                // ÊôÆÈÄöÊï∞Â≠óÊ†ºÂºè
                mantissaStr = str;
            }

            // Â§ÑÁêÜÂ∞æÊï∞ÈÉ®ÂàÜÁöÑÁ¨¶Âè∑
            if (mantissaStr.startsWith('+') || mantissaStr.startsWith('-')) {
                sign = mantissaStr[0];
                mantissaStr = mantissaStr.slice(1);
            }

            // Êü•ÊâæÂ∞èÊï∞ÁÇπ‰ΩçÁΩÆ
            const dotIndex = mantissaStr.indexOf('.');
            let integerPart, fractionalPart;

            if (dotIndex === -1) {
                // Ê≤°ÊúâÂ∞èÊï∞ÁÇπ
                integerPart = mantissaStr;
                fractionalPart = '';
            } else {
                // ÊúâÂ∞èÊï∞ÁÇπ
                integerPart = mantissaStr.slice(0, dotIndex);
                fractionalPart = mantissaStr.slice(dotIndex + 1);
            }

            // ÂêàÂπ∂ÊâÄÊúâÊï∞Â≠ó
            const allDigits = integerPart + fractionalPart;

            // ÊâæÂà∞Á¨¨‰∏Ä‰∏™ÈùûÈõ∂Êï∞Â≠óÁöÑ‰ΩçÁΩÆ
            let firstNonZeroIndex = -1;
            for (let i = 0; i < allDigits.length; i++) {
                if (allDigits[i] !== '0') {
                    firstNonZeroIndex = i;
                    break;
                }
            }

            if (firstNonZeroIndex === -1) {
                // ÂÖ®ÈÉ®ÊòØÈõ∂
                return '0e0';
            }

            // ÊâæÂà∞ÊúÄÂêé‰∏Ä‰∏™ÈùûÈõ∂Êï∞Â≠óÁöÑ‰ΩçÁΩÆ
            let lastNonZeroIndex = -1;
            for (let i = allDigits.length - 1; i >= 0; i--) {
                if (allDigits[i] !== '0') {
                    lastNonZeroIndex = i;
                    break;
                }
            }

            // ÊèêÂèñÊúâÊïàÊï∞Â≠óÈÉ®ÂàÜ
            const significantDigits = allDigits.slice(firstNonZeroIndex, lastNonZeroIndex + 1);

            // ËÆ°ÁÆóÊåáÊï∞
            let exponent;

            if (dotIndex === -1) {
                // Ê≤°ÊúâÂ∞èÊï∞ÁÇπÔºöÊåáÊï∞ = Êï∞Â≠óÊÄª‰ΩçÊï∞ - 1
                exponent = allDigits.length - 1;
            } else {
                if (firstNonZeroIndex < integerPart.length) {
                    // Á¨¨‰∏Ä‰∏™ÈùûÈõ∂Êï∞Â≠óÂú®Êï¥Êï∞ÈÉ®ÂàÜ
                    exponent = integerPart.length - firstNonZeroIndex - 1;
                } else {
                    // Á¨¨‰∏Ä‰∏™ÈùûÈõ∂Êï∞Â≠óÂú®Â∞èÊï∞ÈÉ®ÂàÜ
                    exponent = -(firstNonZeroIndex - integerPart.length + 1);
                }
            }

            // ÊÄªÊåáÊï∞ = ÂéüÂßãÊåáÊï∞ + ÂΩìÂâçËÆ°ÁÆóÁöÑÊåáÊï∞
            const totalExponent = originalExponent + exponent;

            // ÊûÑÂª∫ËßÑÊ†ºÂåñÁßëÂ≠¶ËÆ°Êï∞Ê≥ï
            let normalizedMantissa;
            if (significantDigits.length === 1) {
                normalizedMantissa = significantDigits[0];
            } else {
                normalizedMantissa = significantDigits[0] + '.' + significantDigits.slice(1);
            }

            // Â§ÑÁêÜÁ¨¶Âè∑
            const signPrefix = sign === '-' ? '-' : '';

            return [signPrefix + normalizedMantissa, totalExponent];
        }

        function parseFloatExp(string) {
            var [b, e] = normalizeScientificNotation(string)
            var fp = new FloatExp(parseFloat(b), (isNaN(e) ? 0 : e));
            // fp.norm();
            return fp;
        }

        function doubleToFloatExp(num) {
            if (num === 0) return FloatExp.ZERO.copy();
            // Get the exponent
            let exponent = Math.floor(Math.log10(Math.abs(num)));
            // Calculate the significand
            let scale = FloatExp.getExp(exponent);
            let significand = scale ? num / scale : 0;
            return new FloatExp(significand, exponent);
        }

        function decimalToFloatExp(num) {
            let base = num.d[0];
            for (let i = 1; i < 3; i++) {
                if (num.d[i]) base = base * 1e8 + num.d[i];
            }
            if (num.e == 0) return new FloatExp(base, 0);
            let off = Math.floor(Math.log10(base));
            let exp = num.e - off;
            return new FloatExp(base, exp);
        }

        function getFloatExp(obj) {
            if (obj instanceof FloatExp) return obj;
            else if (typeof obj === "number") {
                return doubleToFloatExp(obj);
            } else if (obj instanceof Decimal) {
                return decimalToFloatExp(obj);
            } else return parseFloatExp(obj.toString())
        }
        class Complex {
            // Static cache variables to avoid object creation in intermediate calculations
            static CACHE_RE = 0;
            static CACHE_IM = 0;
            static CACHE_RE2 = 0;
            static CACHE_IM2 = 0;

            constructor(re, im) {
                this.re = re;
                this.im = im;
                this.absValue = null; // Cache for absolute value squared
            }

            // Clear cache when values change
            _clearCache() {
                this.absValue = null;
            }

            // --- Addition Operations ---
            add(other) {
                return this.addTo(other, new Complex(0, 0));
            }

            addMut(other) {
                return this.addTo(other, this);
            }

            addTo(other, store) {
                if (typeof other === 'number') {
                    store.re = this.re + other;
                    store.im = this.im;
                } else {
                    store.re = this.re + other.re;
                    store.im = this.im + other.im;
                }
                store._clearCache(); // Clear cache in store
                return store;
            }

            // --- Subtraction Operations ---
            sub(other) {
                return this.subTo(other, new Complex(0, 0));
            }

            subMut(other) {
                return this.subTo(other, this);
            }

            subTo(other, store) {
                if (typeof other === 'number') {
                    store.re = this.re - other;
                    store.im = this.im;
                } else {
                    store.re = this.re - other.re;
                    store.im = this.im - other.im;
                }
                store._clearCache();
                return store;
            }

            // --- Multiplication Operations ---
            mul(other) {
                return this.mulTo(other, new Complex(0, 0));
            }

            mulMut(other) {
                return this.mulTo(other, this);
            }

            /**
             * Optimized multiplication using static cache to avoid object creation
             * (a + bi)(c + di) = (ac - bd) + (ad + bc)i
             */
            mulTo(other, store) {
                if (typeof other === 'number') {
                    store.re = this.re * other;
                    store.im = this.im * other;
                    store._clearCache();
                    return store;
                }

                // Use static cache for intermediate values
                // ac -> CACHE_RE
                Complex.CACHE_RE = this.re * other.re;
                // bd -> CACHE_IM
                Complex.CACHE_IM = this.im * other.im;
                // Real part: ac - bd -> CACHE_RE2 (temporary for real result)
                Complex.CACHE_RE2 = Complex.CACHE_RE - Complex.CACHE_IM;

                // ad -> CACHE_RE (reuse)
                Complex.CACHE_RE = this.re * other.im;
                // bc -> CACHE_IM (reuse)
                Complex.CACHE_IM = this.im * other.re;
                // Imag part: ad + bc -> CACHE_IM2 (temporary for imag result)
                Complex.CACHE_IM2 = Complex.CACHE_RE + Complex.CACHE_IM;

                // Store results
                store.re = Complex.CACHE_RE2;
                store.im = Complex.CACHE_IM2;
                store._clearCache();

                return store;
            }

            // --- Division Operations ---
            div(other) {
                return this.divTo(other, new Complex(0, 0));
            }

            divMut(other) {
                return this.divTo(other, this);
            }

            /**
             * Optimized division
             * (a + bi)/(c + di) = ((ac + bd) + (bc - ad)i) / (c^2 + d^2)
             */
            divTo(other, store) {
                if (typeof other === 'number') {
                    store.re = this.re / other;
                    store.im = this.im / other;
                    store._clearCache();
                    return store;
                }

                // Denominator: c^2 + d^2 -> CACHE_RE
                Complex.CACHE_RE = other.re * other.re + other.im * other.im;

                // Numerator Real: ac + bd -> CACHE_IM
                Complex.CACHE_IM = this.re * other.re + this.im * other.im;

                // Numerator Imag: bc - ad -> CACHE_RE2
                Complex.CACHE_RE2 = this.im * other.re - this.re * other.im;

                // Final division
                store.re = Complex.CACHE_IM / Complex.CACHE_RE;
                store.im = Complex.CACHE_RE2 / Complex.CACHE_RE;
                store._clearCache();

                return store;
            }

            // --- Square Operations ---
            square() {
                return this.squareTo(new Complex(0, 0));
            }

            squareMut() {
                return this.squareTo(this);
            }

            squareTo(store) {
                // (a+bi)^2 = (a^2 - b^2) + 2abi
                Complex.CACHE_RE = this.re * this.re - this.im * this.im; // Real part
                Complex.CACHE_IM = 2 * this.re * this.im; // Imag part

                store.re = Complex.CACHE_RE;
                store.im = Complex.CACHE_IM;
                store._clearCache();

                return store;
            }

            zero() {
                this.re = 0;
                this.im = 0;
                this.absValue = 0;
                return this;
            }

            // --- Other Methods (updated) ---
            abs() {
                if (this.absValue === null) {
                    this.absValue = this.re * this.re + this.im * this.im;
                }
                return this.absValue;
            }

            toNumberArray() {
                return [this.re, this.im];
            }

            norm() {
                return Math.max(Math.abs(this.re), Math.abs(this.im));
            }

            equals(other) {
                return this.re === other.re && this.im === other.im;
            }

            copy() {
                return new Complex(this.re, this.im);
            }

            toString() {
                return `(${this.re}, ${this.im})`;
            }

            // Static methods similar to FloatExpComplex
            static ZERO = new Complex(0, 0);
            static ONE = new Complex(1, 0);
            static I = new Complex(0, 1);
            static NEGATIVE_ONE = new Complex(-1, 0);
            static TWO = new Complex(2, 0);
        }

        class DeepComplex {
            constructor(re, im) {
                this.re = re instanceof Decimal ? re : new Decimal(re);
                this.im = im instanceof Decimal ? im : new Decimal(im);
            }

            abs() {
                return this.re.pow(2).plus(this.im.pow(2));
            }

            mul(other) {
                if (other instanceof DeepComplex) {
                    const realPart = this.re.times(other.re).minus(this.im.times(other.im));
                    const imagPart = this.re.times(other.im).plus(this.im.times(other.re));
                    return new DeepComplex(realPart, imagPart);
                } else if (other instanceof Complex) {
                    const realPart = this.re.times(other.re).minus(this.im.times(other.im));
                    const imagPart = this.re.times(other.im).plus(this.im.times(other.re));
                    return new DeepComplex(realPart, imagPart);
                } else if (other instanceof FloatExpComplex) {
                    other = other.toDeepComplex();
                    const realPart = this.re.times(other.re).minus(this.im.times(other.im));
                    const imagPart = this.re.times(other.im).plus(this.im.times(other.re));
                    return new DeepComplex(realPart, imagPart);
                } else if (typeof other === 'number') {
                    return new DeepComplex(this.re.times(other), this.im.times(other));
                } else {
                    throw new Error('Invalid type for multiplication');
                }
            }

            add(other) {
                if (other instanceof FloatExpComplex) {
                    other = other.toDeepComplex();
                }
                return new DeepComplex(this.re.plus(other.re), this.im.plus(other.im));
            }

            sub(other) {
                if (other instanceof FloatExpComplex) {
                    other = other.toDeepComplex();
                }
                return new DeepComplex(this.re.minus(other.re), this.im.minus(other.im));
            }

            downCast() {
                return new Complex(this.re.toNumber(), this.im.toNumber())
            }

            toFloatExp() {
                return new FloatExpComplex(
                    getFloatExp(this.re.toString()),
                    getFloatExp(this.im.toString())
                )
            }

            square() {
                const realPart = this.re.times(this.re).minus(this.im.times(this.im)); // a^2 - b^2
                const imagPart = this.re.plus(this.re).times(this.im);     // 2ab
                return new DeepComplex(realPart, imagPart);
            }

            copy() {
                return new DeepComplex(this.re.add(0), this.im.add(0));
            }
        }

        class FloatExpComplex {
            static ZERO = new FloatExpComplex(FloatExp.ZERO, FloatExp.ZERO);
            static ONE = new FloatExpComplex(FloatExp.ONE, FloatExp.ZERO);
            static NEGATIVE_ONE = new FloatExpComplex(FloatExp.NEGATIVE_ONE, FloatExp.ZERO);
            static TWO = new FloatExpComplex(FloatExp.TWO, FloatExp.ZERO);

            // Static scratchpads (cache) for internal calculations to avoid object creation
            static CACHE_1 = new FloatExp(0, 0);
            static CACHE_2 = new FloatExp(0, 0);
            static CACHE_3 = new FloatExp(0, 0);
            static CACHE_4 = new FloatExp(0, 0);

            constructor(re, im) {
                // Assuming getFloatExp is available globally or users pass FloatExp
                this.re = (re instanceof FloatExp) ? re : new FloatExp(re);
                this.im = (im instanceof FloatExp) ? im : new FloatExp(im);
            }

            storeTo(store) {
                this.re.storeTo(store.re);
                this.im.storeTo(store.im);
                return store;
            }

            copy() {
                return new FloatExpComplex(this.re.copy(), this.im.copy());
            }

            // --- Optimized Math Operations ---

            add(other) {
                return this.addTo(other, new FloatExpComplex(new FloatExp(0), new FloatExp(0)));
            }

            addMut(other) {
                return this.addTo(other, this);
            }

            addTo(other, store) {
                if (typeof other === 'number') {
                    this.re.addTo(other, store.re);
                    this.im.storeTo(store.im);
                } else {
                    this.re.addTo(other.re, store.re);
                    this.im.addTo(other.im, store.im);
                }
                return store;
            }

            sub(other) {
                return this.subTo(other, new FloatExpComplex(new FloatExp(0), new FloatExp(0)));
            }

            subMut(other) {
                return this.subTo(other, this);
            }

            subTo(other, store) {
                if (typeof other === 'number') {
                    this.re.subTo(other, store.re);
                    this.im.storeTo(store.im);
                } else {
                    this.re.subTo(other.re, store.re);
                    this.im.subTo(other.im, store.im);
                }
                return store;
            }

            mul(other) {
                return this.mulTo(other, new FloatExpComplex(new FloatExp(0), new FloatExp(0)));
            }

            mulMut(other) {
                return this.mulTo(other, this);
            }

            /**
             * Optimized multiplication using static scratchpads to ensure 0 allocation for intermediate steps.
             * Formula: (a + bi)(c + di) = (ac - bd) + (ad + bc)i
             */
            mulTo(other, store) {
                if (typeof other === 'number') {
                    this.re.mulTo(other, store.re);
                    this.im.mulTo(other, store.im);
                    return store;
                }

                // Use static cache for intermediate values to avoid 'new FloatExp'
                // This prevents aliasing issues if 'store' is 'this' or 'other'

                // ac -> CACHE_1
                this.re.mulTo(other.re, FloatExpComplex.CACHE_1);
                // bd -> CACHE_2
                this.im.mulTo(other.im, FloatExpComplex.CACHE_2);

                // Real part: ac - bd -> CACHE_3 (Temporary storage for Real Result)
                FloatExpComplex.CACHE_1.subTo(FloatExpComplex.CACHE_2, FloatExpComplex.CACHE_3);

                // ad -> CACHE_1 (reuse)
                this.re.mulTo(other.im, FloatExpComplex.CACHE_1);
                // bc -> CACHE_2 (reuse)
                this.im.mulTo(other.re, FloatExpComplex.CACHE_2);

                // Imag part: ad + bc -> CACHE_4 (Temporary storage for Imag Result)
                FloatExpComplex.CACHE_1.addTo(FloatExpComplex.CACHE_2, FloatExpComplex.CACHE_4);

                // Finally, copy from temp storage to the actual store
                FloatExpComplex.CACHE_3.storeTo(store.re);
                FloatExpComplex.CACHE_4.storeTo(store.im);

                return store;
            }

            div(other) {
                return this.divTo(other, new FloatExpComplex(new FloatExp(0), new FloatExp(0)));
            }

            divMut(other) {
                return this.divTo(other, this);
            }

            /**
             * Optimized division.
             * Formula: (a + bi)/(c + di) = ((ac + bd) + (bc - ad)i) / (c^2 + d^2)
             */
            divTo(other, store) {
                if (typeof other === 'number') {
                    this.re.divTo(other, store.re);
                    this.im.divTo(other, store.im);
                    return store;
                }

                // Denominator: c^2 + d^2 -> CACHE_1
                other.re.mulTo(other.re, FloatExpComplex.CACHE_2); // c^2
                other.im.mulTo(other.im, FloatExpComplex.CACHE_3); // d^2
                FloatExpComplex.CACHE_2.addTo(FloatExpComplex.CACHE_3, FloatExpComplex.CACHE_1); // Denom stored in CACHE_1

                // Numerator Real: ac + bd -> CACHE_2
                this.re.mulTo(other.re, FloatExpComplex.CACHE_3); // ac
                this.im.mulTo(other.im, FloatExpComplex.CACHE_4); // bd
                FloatExpComplex.CACHE_3.addTo(FloatExpComplex.CACHE_4, FloatExpComplex.CACHE_2); // NumReal in CACHE_2

                // Numerator Imag: bc - ad -> CACHE_3
                this.im.mulTo(other.re, FloatExpComplex.CACHE_4); // bc
                // Re-calculate ad locally into CACHE_4 buffer to save slots, using CACHE_4 temporarily
                // Wait, need another buffer. Actually, we can compute ad into store.re temporarily if we are careful,
                // but let's use CACHE_4 for 'ad' then subtract.

                // ad
                this.re.mulTo(other.im, store.re); // Using store.re as temp buffer for 'ad'. Safe because we overwrite store.re later.

                // bc (in CACHE_4) - ad (in store.re) -> CACHE_3
                FloatExpComplex.CACHE_4.subTo(store.re, FloatExpComplex.CACHE_3); // NumImag in CACHE_3

                // Final Division
                // Real: NumReal (CACHE_2) / Denom (CACHE_1) -> store.re
                FloatExpComplex.CACHE_2.divTo(FloatExpComplex.CACHE_1, store.re);

                // Imag: NumImag (CACHE_3) / Denom (CACHE_1) -> store.im
                FloatExpComplex.CACHE_3.divTo(FloatExpComplex.CACHE_1, store.im);

                return store;
            }

            // --- Other Methods ---

            abs2() {
                return this.re.mul(this.re).addMut(this.im.mul(this.im));
            }

            // Chebyshev norm
            norm() {
                return FloatExp.max(this.re.abs(), this.im.abs());
            }

            square() {
                const res = new FloatExpComplex(new FloatExp(0), new FloatExp(0));
                return this.squareTo(res);
            }

            squareMut() {
                return this.squareTo(this);
            }

            squareTo(store) {
                // (a+bi)^2 = (a^2 - b^2) + 2abi

                // a^2 -> CACHE_1
                this.re.mulTo(this.re, FloatExpComplex.CACHE_1);
                // b^2 -> CACHE_2
                this.im.mulTo(this.im, FloatExpComplex.CACHE_2);

                // Real: a^2 - b^2 -> CACHE_3
                FloatExpComplex.CACHE_1.subTo(FloatExpComplex.CACHE_2, FloatExpComplex.CACHE_3);

                // Imag: 2ab -> CACHE_4
                this.re.mulTo(this.im, FloatExpComplex.CACHE_4);
                FloatExpComplex.CACHE_4.mulTo(FloatExp.TWO, FloatExpComplex.CACHE_4);

                FloatExpComplex.CACHE_3.storeTo(store.re);
                FloatExpComplex.CACHE_4.storeTo(store.im);

                return store;
            }

            zero() {
                this.re.zero();
                this.im.zero();
                return this;
            }

            equals(o) {
                return this.re.equals(o.re) && this.im.equals(o.im);
            }

            toComplex() {
                return new Complex(this.re.doubleValue(), this.im.doubleValue());
            }

            toDeepComplex() {
                return new DeepComplex(
                    new Decimal(this.re.toString()),
                    new Decimal(this.im.toString())
                )
            }
        }

        class ReferenceCompressor {
            constructor(cRe, cIm) {
                this.keys = [0];
                this.values = [Complex.ZERO];
                this.cRe = cRe;
                this.cIm = cIm;
                this.lastIter = 0;
                this.lastZRe = 0;
                this.lastZIm = 0;

                // È¢ÑËÆ°ÁÆóÂπ≥ÊñπÔºåÈÅøÂÖçÈáçÂ§çËÆ°ÁÆó
                this.cReSquared = cRe * cRe;
                this.cImSquared = cIm * cIm;

                this.lookupResult = [null, null];
                this.keyIndexMap = new Map(); // iter -> index
            }

            addCheckpoint(iter, z) {
                this.keyIndexMap.set(iter, this.keys.length);
                this.keys.push(iter);
                this.values.push(z);
            }

            getKey(iter) {
                return this.keyIndexMap.get(iter) ?? -1;
            }

            lookupLowerKey(iter) {
                let left = 0;
                let right = this.keys.length - 1;
                let lowerKey = null;
                let lowerValue = null;

                let mid;
                while (left <= right) {
                    mid = (left + right) >> 1;
                    const midKey = this.keys[mid];

                    if (midKey <= iter) {
                        lowerKey = midKey;
                        lowerValue = this.values[mid];
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }

                this.lookupResult[0] = lowerKey;
                this.lookupResult[1] = lowerValue;
                this.ckptPtr = mid + 1;
            }

            get(iter) {
                const result = new Complex(0, 0);
                this.getInplace(iter, result);
                return result;
            }

            getInplace(iter, result) {
                // 2. Âü∫Á°ÄÊÉÖÂÜµ
                if (iter === 0) {
                    result.re = 0;
                    result.im = 0;
                    return
                }

                if (iter === this.lastIter) {
                    result.re = this.lastZRe;
                    result.im = this.lastZIm;
                    return;
                }

                // Ê£ÄÊµãÂºÇÂ∏∏
                if (isNaN(this.lastIter) || isNaN(this.lastZRe) || isNaN(this.lastZIm)) {
                    this.lastIter = 0;
                    this.lastZRe = 0;
                    this.lastZIm = 0;
                }

                // 3. ÁâπÊÆäÊÉÖÂÜµÔºöËøûÁª≠Ëø≠‰ª£
                if (iter === this.lastIter + 1) {
                    const checkpointIndex = this.getKey(iter);
                    if (checkpointIndex !== -1) {
                        this.updateLast(iter, this.values[checkpointIndex]);
                    } else {
                        this.calculateNext();
                    }

                    result.re = this.lastZRe;
                    result.im = this.lastZIm;
                    return;
                }

                // 4. ‰ªéÊúÄËøëÁöÑÊ£ÄÊü•ÁÇπÂºÄÂßãËÆ°ÁÆó
                this.lookupLowerKey(iter);
                const lowerKey = this.lookupResult[0];
                const lowerValue = this.lookupResult[1];

                if (lowerKey !== null) {
                    this.updateLast(lowerKey, lowerValue);
                } else {
                    // Ê≤°ÊúâÊâæÂà∞Ê£ÄÊü•ÁÇπÔºå‰ªéÂ§¥ÂºÄÂßã
                    this.lastIter = 0;
                    this.lastZRe = 0;
                    this.lastZIm = 0;
                }

                // 5. Ëø≠‰ª£Âà∞ÁõÆÊ†áÂÄº
                let checkpointIndex = this.findNextCheckpointIndex(lowerKey !== null ? lowerKey + 1 : 1);

                for (let i = this.lastIter + 1; i <= iter; i++) {
                    if (checkpointIndex < this.keys.length && this.keys[checkpointIndex] === i) {
                        // ÈÅáÂà∞‰∫ÜÊ£ÄÊü•ÁÇπ
                        this.updateLast(i, this.values[checkpointIndex]);
                        checkpointIndex++;
                    } else {
                        this.calculateNext();
                    }

                }

                this.lastIter = iter;
                result.re = this.lastZRe;
                result.im = this.lastZIm;
                return;
            }

            // ËæÖÂä©ÊñπÊ≥ï
            calculateNext() {
                const re = this.lastZRe;
                const im = this.lastZIm;
                const reSq = re * re;
                const imSq = im * im;

                this.lastZRe = reSq - imSq + this.cRe;
                this.lastZIm = 2 * re * im + this.cIm;
                this.lastIter++;
            }

            updateLast(iter, complex) {
                this.lastIter = iter;
                this.lastZRe = complex.re;
                this.lastZIm = complex.im;
            }

            findNextCheckpointIndex(startIter) {
                // ‰∫åÂàÜÊü•Êâæ‰∏ã‰∏Ä‰∏™Ê£ÄÊü•ÁÇπ
                let left = 0;
                let right = this.keys.length - 1;
                let result = this.keys.length;  // ÈªòËÆ§Ê≤°ÊúâÊ£ÄÊü•ÁÇπ

                while (left <= right) {
                    const mid = (left + right) >> 1;
                    if (this.keys[mid] >= startIter) {
                        result = mid;
                        right = mid - 1;
                    } else {
                        left = mid + 1;
                    }
                }

                return result;
            }

            decompress() {
                return new DecompressedReference(this);
            }

            get size() {
                return this.keys.length;
            }

            checkpoints() {
                let result = {}
                for (let i = 0; i < this.keys.length; i++) {
                    result[this.keys[i]] = this.values[i];
                }
                return result;
            }
        }

        class DecompressedReference {
            constructor(comp) {
                this.comp = comp;
                this.z = [];
                for (let i = 0; i < comp.length; i++) {
                    this.z.push(comp.get(i));
                }
            }

            get(iter) {
                return this.z[iter];
            }

            getInplace(iter, result) {
                result.re = this.z[iter].re;
                result.im = this.z[iter].im;
            }

            get length() {
                return this.z.length;
            }

            get size() {
                return this.comp.size;
            }

            checkpoints() {
                return this.comp.checkpoints();
            }
        }

        class ReferenceCompressorFloatExp {
            constructor(c) {
                this.keys = [0];
                this.values = [FloatExpComplex.ZERO.copy()];
                this.c = c;
                this.lastIter = 0;
                this.lastZ = FloatExpComplex.ZERO.copy();

                this.cSquared = this.c.square();

                this.lookupResult = [null, null];
                this.keyIndexMap = new Map();
            }

            addCheckpoint(iter, z) {
                this.keyIndexMap.set(iter, this.keys.length);
                this.keys.push(iter);
                this.values.push(z);
            }

            getKey(iter) {
                return this.keyIndexMap.get(iter) ?? -1;
            }

            lookupLowerKey(iter) {
                let left = 0;
                let right = this.keys.length - 1;
                let lowerKey = null;
                let lowerValue = null;

                let mid;
                while (left <= right) {
                    mid = (left + right) >> 1;
                    const midKey = this.keys[mid];

                    if (midKey <= iter) {
                        lowerKey = midKey;
                        lowerValue = this.values[mid];
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }

                this.lookupResult[0] = lowerKey;
                this.lookupResult[1] = lowerValue;
                return this.lookupResult;
            }

            get(iter) {
                const result = new FloatExpComplex(0, 0);
                this.getInplace(iter, result);
                return result;
            }

            getInplace(iter, result) {
                // 1. Âü∫Á°ÄÊÉÖÂÜµ
                if (iter === 0) {
                    FloatExpComplex.ZERO.storeTo(result);
                    return;
                }

                if (iter === this.lastIter) {
                    this.lastZ.storeTo(result);
                    return;
                }


                // Ê£ÄÊµãÂºÇÂ∏∏
                if (isNaN(this.lastIter)) {
                    this.lastIter = 0;
                    this.lastZ.zero();
                }

                // 2. ÁâπÊÆäÊÉÖÂÜµÔºöËøûÁª≠Ëø≠‰ª£
                if (iter === this.lastIter + 1) {
                    const checkpointIndex = this.getKey(iter);
                    if (checkpointIndex !== -1) {
                        this.updateLast(iter, this.values[checkpointIndex]);
                    } else {
                        this.calculateNext();
                    }

                    this.lastZ.storeTo(result);
                    return;
                }

                // 3. ‰ªéÊúÄËøëÁöÑÊ£ÄÊü•ÁÇπÂºÄÂßãËÆ°ÁÆó
                this.lookupLowerKey(iter);
                const lowerKey = this.lookupResult[0];
                const lowerValue = this.lookupResult[1];

                if (lowerKey !== null) {
                    this.updateLast(lowerKey, lowerValue);
                } else {
                    // Ê≤°ÊúâÊâæÂà∞Ê£ÄÊü•ÁÇπÔºå‰ªéÂ§¥ÂºÄÂßã
                    this.lastIter = 0;
                    FloatExpComplex.ZERO.storeTo(this.lastZ);
                }

                // 4. Ëø≠‰ª£Âà∞ÁõÆÊ†áËø≠‰ª£Ê¨°Êï∞
                let checkpointIndex = this.findNextCheckpointIndex(lowerKey !== null ? lowerKey + 1 : 1);

                for (let i = this.lastIter + 1; i <= iter; i++) {
                    if (checkpointIndex < this.keys.length && this.keys[checkpointIndex] === i) {
                        // ÈÅáÂà∞‰∫ÜÊ£ÄÊü•ÁÇπ
                        this.updateLast(i, this.values[checkpointIndex]);
                        checkpointIndex++;
                    } else {
                        this.calculateNext();
                    }

                }

                this.lastIter = iter;
                this.lastZ.storeTo(result);
                return;

            }

            static zSq = FloatExpComplex.ZERO.copy();

            calculateNext() {
                this.lastZ.squareTo(ReferenceCompressorFloatExp.zSq)
                // Z = Z^2 + C;
                ReferenceCompressorFloatExp.zSq.addTo(this.c, this.lastZ);
                this.lastIter++;
            }

            updateLast(iter, z) {
                this.lastIter = iter;
                z.storeTo(this.lastZ);
            }

            findNextCheckpointIndex(startIter) {
                // ‰∫åÂàÜÊü•Êâæ‰∏ã‰∏Ä‰∏™Ê£ÄÊü•ÁÇπ
                let left = 0;
                let right = this.keys.length - 1;
                let result = this.keys.length;  // ÈªòËÆ§Ê≤°ÊúâÊ£ÄÊü•ÁÇπ

                while (left <= right) {
                    const mid = (left + right) >> 1;
                    if (this.keys[mid] >= startIter) {
                        result = mid;
                        right = mid - 1;
                    } else {
                        left = mid + 1;
                    }
                }

                return result;
            }
            decompress() {
                return new DecompressedReferenceFloatExp(this);
            }

            get size() {
                return this.keys.length;
            }

            toComplexRef() {
                const c = this.c.toComplex()
                const cRef = new ReferenceCompressor(c.re, c.im);
                for (let i = 1; i < this.keys.length; i++) {
                    const key = this.keys[i];
                    cRef.addCheckpoint(key, this.values[i]);
                }
                cRef.length = this.length;
                return cRef;
            }

            checkpoints() {
                let result = {};
                for (let i = 0; i < this.keys.length; i++) {
                    result[this.keys[i]] = this.values[i];
                }
                return result;
            }
        }

        class DecompressedReferenceFloatExp {
            constructor(comp) {
                this.comp = comp;
                this.z = [];
                for (let i = 0; i < comp.length; i++) {
                    this.z.push(comp.get(i));
                }
            }

            get(iter) {
                return this.z[iter];
            }

            getInplace(iter, result) {
                this.z[iter].storeTo(result);
            }

            get length() {
                return this.z.length;
            }

            get size() {
                return this.comp.size;
            }

            toComplexRef() {
                return this.comp.toComplexRef().decompress();
            }

            checkpoints() {
                return this.comp.checkpoints();
            }
        }

        const samples = {
            seahorse: {
                re: "-0.74543",
                im: "0.11301",
                zoom: 5e4,
                it: 2048
            },
            snowflake: {
                re: "-0.10109629004872408548585126380133943559",
                im: "0.9562865745329222746947099385459096648",
                zoom: 3.169126e+29,
                it: 2048
            },
            spiral: {
                re: "-1.999993942175717867792242968103527549859576",
                im: "8.6071861910492399703689002138183e-21",
                zoom: 5.192297e+33,
                it: 2048
            },
            luxury: {
                re: "-0.79580869118304321175952779938151856806452507855882",
                im: "0.18469182276676613095841056743436302824144029079562",
                zoom: 1.3e42,
                it: 4096
            },
            horizon: {
                re: "-1.8584343800176784682217288203669595446250882516610855163",
                im: 0,
                zoom: 2.338403e+48,
                it: 8192
            },
            flora: {
                re: "-1.99909599626591118385320862404514647238736998791060410728750271382258617296138194612160227",
                im: "2.7580719798153099801178971305087708486297199751987655897677764832896127755911711978e-7",
                zoom: 1.554135e+85,
                it: 12000
            },
            classic: {
                re: "-1.740062382579339905220844167065825638296641720436171866879862418461182919644153056054840718339483225743450008259172138785492983677915427169",
                im: "0.02817533977921104899241152114431950968753907674299060857040130959588017432409201863854008146585605536156950844867740770006690377105617915918",
                zoom: 3.169127e+129,
                it: 16384
            },
            e200: {
                re: "-1.966802851116594708819298912851462114119985811705618926682822172678211294505900454587066386326486696211109981444987492635874831274786202351721769325471466717092496114767216598301545236111458996508055081585396",
                im: "0.0010977722859744975944199816905137002369183368289711851029920379829671969621655021360812521504061553173015969230096789768757462998082308739346850130554776214016764573717626859656016612926260380492615038665711972",
                zoom: 3.061802e+200,
                it: 2560
            },
            radiant: {
                re: "-1.99999999999999999999999999999999999999999999999999999999999985604992427869224505485316659406169263456244557162707394015035258073628597813990573253878488792954728746460753235734445467801735035140789540329931747966277516467943284583061883624921231436068907582257",
                im: "-8.91471704727989229599363700420508490047745648395754111902776340339365777429490330220597376804879333373511664660430230981300478098523390924266124801444129e-108",
                zoom: 6.190352e+250,
                it: 32768
            },
            branches: {
                re: "-1.6292734442048283318938320396270139993976098667361842769438797568378211896685981215295380430631824444939812959088045104000652511090002918608428367750404559604873908045574737562161798763493882467959347522331334565200535419490490792109572426042012307199142243133244778278658423929305351347449296418283955642234980665610830226069420767708737186375011028341136058680534715563202637094315075646672266222835522732620561624291470918925972479094214439824838059879454955180554531579035878862691173748960700828240715259267985644677355092076437915522889997465324097488586896011539207914088325170690741321143420090542550202239848652811940259393780795046066233233901935939495310855142242101042",
                im: "0.03869400209621531644885884354220643543483856432312340490566021352296232798895918154015224599032404970872042582187369535150768927860463654320654167750197244691011756126324382371624135105468469098307733451525287938447855301549425418319315644599440229040004000393629694918121347776683198213801647169431881760881989559740902877967780796990256450970464951956949842553605553300056814346433987027958609011265495269006410527939833349934593968626122035005120083542187577701148430417027976032242752140056316110069588785859474053819290291277818754134945550976828752797151560991794888216365813883286779093669780620189356923473044461454552716354829377180996852428111452867133487261674235339815",
                zoom: "1.5710523668200003e671",
                it: 22067
            }
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        const COMPRESS_THRESHOLD = 2 ** -40;

        async function* getReferenceOrbitMPFR(C, radius, iterations, precisionBits) {
            let Z = new DeepComplex(0, 0),
                z = new Complex(0, 0),
                dzdc = new Complex(1, 0),
                one = new Complex(1, 0);
            // const orbit = [new Complex(0, 0)];
            let predCenter = null;

            const roundingMode = gmp.FloatRoundingMode.ROUND_DOWN;
            const options = { precisionBits: precisionBits, roundingMode };

            let gmpinit = await gmp.init();
            let ctx = gmpinit.getContext(options);

            let cre = ctx.Float(C.re.toString());
            let cim = ctx.Float(C.im.toString());
            let mpzre = ctx.Float(0);
            let mpzim = ctx.Float(0);

            let lpzre = 0;
            let lpzim = 0;
            let lpcre = C.re.toNumber();
            let lpcim = C.im.toNumber();


            let updateTimer = performance.now();

            const binding = gmpinit.binding;
            const tempVars = {
                re2: ctx.Float(0), im2: ctx.Float(0), reim: ctx.Float(0),
                temp1: ctx.Float(0), temp2: ctx.Float(0)
            };

            let compressor = new ReferenceCompressor(lpcre, lpcim);

            for (let i = 1; i < iterations; i++) {
                dzdc = z.add(z).mulMut(dzdc).addMut(one);

                // Â§çÊï∞Âπ≥ÊñπËÆ°ÁÆó
                binding.mpfr_sqr(tempVars.re2.mpfr_t, mpzre.mpfr_t);
                binding.mpfr_sqr(tempVars.im2.mpfr_t, mpzim.mpfr_t);
                binding.mpfr_mul(tempVars.reim.mpfr_t, mpzre.mpfr_t, mpzim.mpfr_t);

                // Êñ∞ÂÆûÈÉ®: re^2 - im^2 + cre
                binding.mpfr_sub(mpzre.mpfr_t, tempVars.re2.mpfr_t, tempVars.im2.mpfr_t);
                binding.mpfr_add(mpzre.mpfr_t, mpzre.mpfr_t, cre.mpfr_t);

                // Êñ∞ËôöÈÉ®: 2*re*im + cim
                binding.mpfr_mul_2ui(mpzim.mpfr_t, tempVars.reim.mpfr_t, 1);
                binding.mpfr_add(mpzim.mpfr_t, mpzim.mpfr_t, cim.mpfr_t);

                // Êõ¥Êñ∞‰ΩéÁ≤æÂ∫¶ÂèÇËÄÉ

                let lpzre2 = lpzre * lpzre;
                let lpzim2 = lpzim * lpzim;

                lpzim = 2 * lpzre * lpzim + lpcim;
                lpzre = lpzre2 - lpzim2 + lpcre;

                z = new Complex(mpzre.toNumber(), mpzim.toNumber());
                // orbit.push(z);

                // Ê£ÄÊü•‰ΩéÁ≤æÂ∫¶ÂíåÂÆûÈôÖÁªìÊûúÁöÑËØØÂ∑Æ
                let error = new Complex(lpzre, lpzim).sub(z).abs() / z.abs()
                if (error > COMPRESS_THRESHOLD) {
                    lpzre = z.re;
                    lpzim = z.im;
                    compressor.addCheckpoint(i, z);
                }

                if (dzdc.norm() * radius * 2 > z.norm()) {
                    predCenter = z.div(dzdc);
                    if (!compressor.keyIndexMap.get(i)) compressor.addCheckpoint(i, z);
                    compressor.length = i + 1;
                    break;
                };
                if (z.norm() > 16.0) break;

                if ((i & 0xff) === 0) {
                    let currentTime = performance.now();
                    if (currentTime - updateTimer > 100) {
                        updateTimer = currentTime;
                        compressor.length = i + 1;
                        yield compressor;
                        await delay(0);
                    }
                }
            }

            ctx.destroy();
            return {
                orbit: compressor.length > 1000000 ? compressor : compressor.decompress(),
                predCenter: predCenter
            };
        }

        function MPFR2FloatExp(ctx, num, binding, unscaled) {
            binding.mpfr_set(unscaled.mpfr_t, num.mpfr_t);
            let exponent = binding.mpfr_get_exp(unscaled.mpfr_t);
            binding.mpfr_set_exp(unscaled.mpfr_t, 0);
            let mantissa = unscaled.toNumber();

            if (mantissa === 0) {
                return FloatExp.ZERO.copy();
            }

            // ËÆ°ÁÆó‰ª•10‰∏∫Â∫ïÁöÑÂØπÊï∞
            let sign = Math.sign(mantissa);
            let absMantissa = Math.abs(mantissa);
            // ËÆ°ÁÆó log10(absMantissa) + exponent * log10(2)
            let log10_x = Math.log10(absMantissa) + exponent * FloatExp.LOG10_2;

            let decimalExponent = Math.floor(log10_x);
            let decimalMantissa = sign * Math.pow(10, log10_x - decimalExponent);

            return new FloatExp(decimalMantissa, decimalExponent);
        }

        const COMPRESS_THRESHOLD_FLOATEXP = new FloatExp(2 ** -40);

        async function* getReferenceOrbitFEMPFR(C, radius, iterations, precisionBits) {

            let Z = new DeepComplex(0, 0),
                z = new FloatExpComplex(0, 0),
                dzdc = new FloatExpComplex(1, 0),
                one = new FloatExpComplex(1, 0);
            let predCenter = null;


            const roundingMode = gmp.FloatRoundingMode.ROUND_DOWN;
            const options = { precisionBits: precisionBits, roundingMode };

            let gmpinit = await gmp.init();
            let ctx = gmpinit.getContext(options);

            let cre = ctx.Float(C.re.toString());
            let cim = ctx.Float(C.im.toString());
            let mpzre = ctx.Float(0);
            let mpzim = ctx.Float(0);
            let updateTimer = performance.now();

            const binding = gmpinit.binding;
            const tempVars = {
                re2: ctx.Float(0), im2: ctx.Float(0), reim: ctx.Float(0),
                temp1: ctx.Float(0), temp2: ctx.Float(0), buffer: ctx.Float(0)
            };

            let lpZ = FloatExpComplex.ZERO.copy();
            let lpC = C.toFloatExp();
            let compressor = new ReferenceCompressorFloatExp(lpC);

            for (let i = 1; i < iterations; i++) {
                dzdc = z.add(z).mulMut(dzdc).add(one);

                // Â§çÊï∞Âπ≥ÊñπËÆ°ÁÆó
                binding.mpfr_sqr(tempVars.re2.mpfr_t, mpzre.mpfr_t);
                binding.mpfr_sqr(tempVars.im2.mpfr_t, mpzim.mpfr_t);
                binding.mpfr_mul(tempVars.reim.mpfr_t, mpzre.mpfr_t, mpzim.mpfr_t);

                // Êñ∞ÂÆûÈÉ®: re^2 - im^2 + cre
                binding.mpfr_sub(mpzre.mpfr_t, tempVars.re2.mpfr_t, tempVars.im2.mpfr_t);
                binding.mpfr_add(mpzre.mpfr_t, mpzre.mpfr_t, cre.mpfr_t);

                // Êñ∞ËôöÈÉ®: 2*re*im + cim
                binding.mpfr_mul_2ui(mpzim.mpfr_t, tempVars.reim.mpfr_t, 1);
                binding.mpfr_add(mpzim.mpfr_t, mpzim.mpfr_t, cim.mpfr_t);

                // Êõ¥Êñ∞‰ΩéÁ≤æÂ∫¶ÂèÇËÄÉ
                lpZ = lpZ.square().addMut(lpC);



                z = new FloatExpComplex(MPFR2FloatExp(ctx, mpzre, binding, tempVars.buffer), MPFR2FloatExp(ctx, mpzim, binding, tempVars.buffer));


                // Ê£ÄÊü•‰ΩéÁ≤æÂ∫¶ÂíåÂÆûÈôÖÁªìÊûúÁöÑËØØÂ∑Æ
                let error = lpZ.sub(z).abs2().div(z.abs2());
                if (error.gt(COMPRESS_THRESHOLD_FLOATEXP)) {
                    z.storeTo(lpZ);
                    compressor.addCheckpoint(i, z);
                }

                if (dzdc.norm().mul(radius).mul(2).gt(z.norm())) {
                    predCenter = z.div(dzdc);
                    if (!compressor.keyIndexMap.get(i)) compressor.addCheckpoint(i, z);
                    compressor.length = i + 1;
                    break;
                };
                if (z.norm().doubleValue() > 16.0) break;

                if ((i & 0xf) === 0) {
                    let currentTime = performance.now();
                    if (currentTime - updateTimer > 100) {
                        updateTimer = currentTime;
                        compressor.length = i + 1;
                        yield compressor;
                        await delay(0);
                    }
                }
            }
            ctx.destroy();
            return {
                orbit: compressor.length > 1000000 ? compressor : compressor.decompress(),
                predCenter: predCenter
            };
        }

        function decompressRef(c, waypoints, maxIter) {
            let re = 0, im = 0;
            const orbit = [new Complex(0, 0)];

            const waypointKeys = Object.keys(waypoints);

            let iter = 0;
            while (iter < maxIter) {
                // if iter in waypoint, use waypoint value
                if (waypointKeys.includes(iter.toString())) {
                    re = waypoints[iter].re;
                    im = waypoints[iter].im;
                }
                // do standard mandelbrot iteration
                const re2 = re * re;
                const im2 = im * im;
                const re1 = re;
                const im1 = im;
                if (re2 + im2 > 16.0) break;
                im = 2 * re * im + c.im;
                re = re2 - im2 + c.re;
                orbit.push(new Complex(re, im));
                iter++;
            }
            return orbit;
        }

        function floorPowerOfTwo(n) {
            if (n <= 0) return 0;
            return Math.pow(2, Math.floor(Math.log2(n)));
        }

        const VAILD_SCALE = 5.960464477539063e-08;
        const DIP_DETECTION_THRESHOLD = 0.0009765625;

        class BLAStep {
            constructor(Z, A, B, radius, radiusC, length, next) {
                this.Z = Z;           // Complex
                this.A = A;           // Complex
                this.B = B;           // Complex
                this.radius = radius; // number
                this.radiusC = radiusC; // number
                this.length = length; // number
                this.next = next;     // number
            }

            copy() {
                return new BLAStep(
                    this.Z,
                    this.A,
                    this.B,
                    this.radius,
                    this.radiusC,
                    this.length,
                    this.next
                );
            }

            /**
             * ÊâßË°å‰∏ÄÊ≠•Ëø≠‰ª£
             * @param {Complex} z - ‰∏ã‰∏Ä‰∏™Ëø≠‰ª£ÁÇπÁöÑÂÄº
             * @returns {[BLAStep, boolean]} - Êñ∞ÁöÑÊ≠•È™§ÂíåÊòØÂê¶Ê£ÄÊµãÂà∞‰∏ãÈôç
             */
            step(z) {
                let radius = z.norm() * VAILD_SCALE;
                let result = new BLAStep(
                    this.Z,
                    this.A.mul(z).mul(2),
                    this.B.mul(z).mul(2).add(1),
                    Math.min(this.radius, radius / this.A.norm()),
                    Math.min(this.radiusC, radius / this.B.norm()),
                    this.length + 1,
                    this.next
                );

                let dipDetected = result.radius < this.radius * DIP_DETECTION_THRESHOLD;
                return [result, dipDetected];
            }

            /**
             * ÂêàÂπ∂‰∏§‰∏™Ê≠•È™§
             * @param {BLAStep} other - Ë¶ÅÂêàÂπ∂ÁöÑÂè¶‰∏Ä‰∏™Ê≠•È™§
             * @returns {[BLAStep, boolean]} - ÂêàÂπ∂ÂêéÁöÑÊ≠•È™§ÂíåÊòØÂê¶Ê£ÄÊµãÂà∞‰∏ãÈôç
             */
            merge(other) {
                let radius = other.Z.norm() * VAILD_SCALE;
                let result = new BLAStep(
                    this.Z,
                    this.A.mul(other.Z).mul(2),
                    this.B.mul(other.Z).mul(2),
                    Math.min(this.radius, radius / this.A.norm()),
                    Math.min(this.radiusC, radius / this.B.norm()),
                    this.length + other.length,
                    this.next
                );

                let dipDetected = result.radius < this.radius * DIP_DETECTION_THRESHOLD;

                result.radius = Math.min(result.radius, other.radius / result.A.norm());
                result.radiusC = Math.min(result.radiusC, other.radius / result.B.norm());
                result.A = result.A.mul(other.A);
                result.B = result.B.mul(other.A).add(other.B);

                return [result, dipDetected];
            }

            /**
             * Ê£ÄÊü•ÊòØÂê¶Ê£ÄÊµãÂà∞‰∏ãÈôç
             * @param {Complex} z - ‰∏ã‰∏Ä‰∏™Ëø≠‰ª£ÁÇπÁöÑÂÄº
             * @returns {boolean} - ÊòØÂê¶Ê£ÄÊµãÂà∞‰∏ãÈôç
             */
            detectDip(z) {
                return z.norm() * VAILD_SCALE / this.A.norm() < this.radius * DIP_DETECTION_THRESHOLD;
            }

            /**
             * ÂàõÂª∫Êñ∞ÁöÑBLAÊ≠•È™§
             * @param {number} i - Á¥¢Âºï
             * @param {Complex} z - ZÂÄº
             * @returns {BLAStep} - Êñ∞ÁöÑÊ≠•È™§
             */
            static newBLA(i, z) {
                return new BLAStep(
                    z,
                    new Complex(1, 0),
                    new Complex(1, 0),
                    1,
                    1,
                    1,
                    i
                );
            }

            /**
             * ÂàõÂª∫ÂàùÂßãÁöÑBLAÊ≠•È™§
             * @param {number} i - Á¥¢Âºï
             * @param {Complex} a - AÂÄº
             * @param {Complex} b - BÂÄº
             * @returns {BLAStep} - Êñ∞ÁöÑÊ≠•È™§
             */
            static createBLA(i, a, b) {
                return new BLAStep(
                    a,
                    b.mul(2),
                    b.mul(2).add(1),
                    b.norm() * VAILD_SCALE,
                    b.norm() * VAILD_SCALE,
                    2,
                    i
                );
            }
        }

        class BLAStage {
            constructor(begin, end) {
                this.begin = begin; // number
                this.end = end;     // number
            }

            /**
             * Ëé∑ÂèñÊ≠•È™§ËåÉÂõ¥
             * @returns {[number, number]} - [begin, end]
             */
            getRange() {
                return [this.begin, this.end];
            }

            /**
             * ËΩ¨Êç¢‰∏∫Êï∞ÁªÑÊ†ºÂºèÔºàÁî®‰∫éÂÖºÂÆπÊóßÁöÑAPIÔºâ
             */
            toArray() {
                return [this.begin, this.end];
            }
        }

        class BLATable {
            constructor() {
                this.stages = []; // BLAStage[]
                this.steps = [];  // BLAStep[]
                this.hasBLA = false;
            }

            /**
             * ÁîüÊàêBLAË°®
             * @param {ReferenceCompressor} ref - ÂèÇËÄÉËΩ®ÈÅì
             * @returns {BLATable} - ÂàõÂª∫ÁöÑBLAË°®
             */
            static create(ref) {
                const table = new BLATable();
                let result = table._createBLAStep(ref);

                if (!result.hasBLA || ref.length < 8) {
                    table.hasBLA = false;
                    return table;
                }

                do {
                    result = table._createBLAStage(result.stages, result.steps, ref);
                } while (result.hasBLA);

                table.stages = result.stages;
                table.steps = result.steps;
                table.hasBLA = true;
                return table;
            }

            _createBLAStep(ref) {
                let period = 0;
                let refLen = ref.length - 1;

                let blaStages = [];
                let blaSteps = [];

                let bla = BLAStep.createBLA(0, new Complex(0, 0), ref.get(1));
                let i;
                for (i = 2; i < refLen; i++) {
                    const [result, detected] = bla.step(ref.get(i));
                    if (detected) {
                        period = i;
                        break;
                    }
                    bla = result;
                }

                blaSteps.push(bla);

                if (!period) {
                    blaStages.push(new BLAStage(0, 1));
                    blaSteps.push(BLAStep.newBLA(0, ref.get(refLen)));
                    return {
                        hasBLA: false,
                        steps: blaSteps,
                        stages: blaStages
                    };
                }

                if (i + 1 >= refLen) {
                    bla = BLAStep.newBLA(i, ref.get(i));
                    i++;
                } else {
                    bla = BLAStep.createBLA(i, ref.get(i), ref.get(i + 1));
                    i += 2;
                }

                for (; i < refLen; i++) {
                    const [result, detected] = bla.step(ref.get(i));

                    if (detected || bla.length >= period) {
                        blaSteps.push(bla);

                        if (i + 1 >= refLen || result.detectDip(ref.get(i + 1))) {
                            bla = BLAStep.newBLA(i, ref.get(i));
                        } else {
                            bla = BLAStep.createBLA(i, ref.get(i), ref.get(i + 1));
                            i++;
                        }
                    } else {
                        bla = result;
                    }
                }

                blaSteps.push(bla);
                blaStages.push(new BLAStage(0, blaSteps.length));
                blaSteps.push(BLAStep.newBLA(0, ref.get(refLen)));

                return {
                    hasBLA: true,
                    steps: blaSteps,
                    stages: blaStages
                };
            }

            _createBLAStage(stages, steps, ref) {
                let prev = stages[stages.length - 1];
                let begin = steps.length;

                let period = 0;
                let i = prev.begin;

                let step = steps[i].merge(steps[i + 1])[0];
                step.next = i;
                i += 2;

                for (; i < prev.end; i++) {
                    const [result, detected] = step.merge(steps[i]);

                    if (detected) {
                        period = step.length;
                        steps.push(step);

                        if (i + 1 >= prev.end || result.detectDip(steps[i + 1].Z)) {
                            step = steps[i].copy();
                            step.next = i;
                            i++;
                        } else {
                            step = steps[i].merge(steps[i + 1])[0];
                            step.next = i;
                            i += 2;
                        }
                        break;
                    }
                    step = result;
                }

                if (!period) {
                    steps.push(step);
                    stages.push(new BLAStage(begin, steps.length));
                    steps.push(steps[prev.end]);
                    return {
                        hasBLA: false,
                        steps: steps,
                        stages: stages
                    };
                }

                for (; i < prev.end; i++) {
                    const [result, detected] = step.merge(steps[i]);

                    if (detected || step.length >= period) {
                        steps.push(step);

                        if (i + 1 >= prev.end || result.detectDip(steps[i + 1].Z)) {
                            step = steps[i].copy();
                            step.next = i;
                        } else {
                            step = steps[i].merge(steps[i + 1])[0];
                            step.next = i;
                            i++;
                        }
                    } else {
                        step = result;
                    }
                }

                steps.push(step);
                stages.push(new BLAStage(begin, steps.length));
                steps.push(steps[prev.end]);

                return {
                    hasBLA: true,
                    steps: steps,
                    stages: stages
                };
            }

            /**
             * Ëé∑ÂèñBLA‰ø°ÊÅØÔºàÁî®‰∫éÂÖºÂÆπÊóßÁöÑAPIÔºâ
             */
            getBLAInfo() {
                return {
                    bla: this.hasBLA,
                    stages: this.stages.map(stage => stage.toArray()),
                    steps: this.steps.map(step => step.toObject())
                };
            }
        }

        const VAILD_SCALE_FLOATEXP = new FloatExp(5.960464477539063, -8);
        const DIP_DETECTION_THRESHOLD_FLOATEXP = new FloatExp(0.0009765625, 0);

        class BLAStepFloatExp {
            constructor(Z, A, B, radius, radiusC, length, next) {
                this.Z = Z;           // FloatExpComplex
                this.A = A;           // FloatExpComplex
                this.B = B;           // FloatExpComplex
                this.radius = radius; // number
                this.radiusC = radiusC; // number
                this.length = length; // number
                this.next = next;     // number
            }

            copy() {
                return new BLAStepFloatExp(
                    this.Z.copy(),
                    this.A.copy(),
                    this.B.copy(),
                    this.radius.copy(),
                    this.radiusC.copy(),
                    this.length,
                    this.next
                );
            }

            /**
             * ÊâßË°å‰∏ÄÊ≠•Ëø≠‰ª£
             * @param {FloatExpComplex} z - ‰∏ã‰∏Ä‰∏™Ëø≠‰ª£ÁÇπÁöÑÂÄº
             * @returns {[BLAStepFloatExp, boolean]} - Êñ∞ÁöÑÊ≠•È™§ÂíåÊòØÂê¶Ê£ÄÊµãÂà∞‰∏ãÈôç
             */
            step(z) {
                let radius = z.norm().mul(VAILD_SCALE_FLOATEXP);
                let result = new BLAStepFloatExp(
                    this.Z,
                    this.A.mul(z).mul(2),
                    this.B.mul(z).mul(2).add(1),
                    FloatExp.min(this.radius, radius.div(this.A.norm())),
                    FloatExp.min(this.radiusC, radius.div(this.B.norm())),
                    this.length + 1,
                    this.next
                );
                let dipDetected = result.radius.lt(this.radius.mul(DIP_DETECTION_THRESHOLD_FLOATEXP));
                return [result, dipDetected];
            }

            merge(other) {
                let radius = other.Z.norm().mul(VAILD_SCALE_FLOATEXP);
                let result = new BLAStepFloatExp(
                    this.Z,
                    this.A.mul(other.Z).mul(2),
                    this.B.mul(other.Z).mul(2),
                    FloatExp.min(this.radius, radius.div(this.A.norm())),
                    FloatExp.min(this.radiusC, radius.div(this.B.norm())),
                    this.length + other.length,
                    this.next
                )
                let dipDetected = result.radius.lt(this.radius.mul(DIP_DETECTION_THRESHOLD_FLOATEXP));
                result.radius = FloatExp.min(result.radius, other.radius.div(result.A.norm()));
                result.radiusC = FloatExp.min(result.radiusC, other.radius.div(result.B.norm()));
                result.A = result.A.mul(other.A);
                result.B = result.B.mul(other.A).add(other.B);
                return [result, dipDetected];
            }

            detectDip(z) {
                return z.norm().mul(VAILD_SCALE_FLOATEXP).div(this.A.norm()).lt(this.radius.mul(DIP_DETECTION_THRESHOLD_FLOATEXP))
            }

            static newBLA(i, z) {
                return new BLAStepFloatExp(
                    z,
                    new FloatExpComplex(1, 0),
                    new FloatExpComplex(1, 0),
                    FloatExp.ONE,
                    FloatExp.ONE,
                    1,
                    i
                );
            }

            static createBLA(i, a, b) {
                return new BLAStepFloatExp(
                    a,
                    b.mul(2),
                    b.mul(2).add(1),
                    b.norm().mul(VAILD_SCALE_FLOATEXP),
                    b.norm().mul(VAILD_SCALE_FLOATEXP),
                    2,
                    i
                );
            }
        }

        class BLATableFloatExp {
            constructor() {
                this.stages = []; // BLAStage[]
                this.steps = [];  // BLAStepFloatExp[]
                this.hasBLA = false;
            }

            /**
             * ÁîüÊàêBLAË°®
             * @param {FloatExpComplex[]} ref - ÂèÇËÄÉËΩ®ÈÅì
             * @returns {BLATableFloatExp} - ÂàõÂª∫ÁöÑBLAË°®
             */
            static create(ref) {
                const table = new BLATableFloatExp();
                let result = table._createBLAStep(ref);

                console.log(result)

                if (!result.hasBLA || ref.length < 8) {
                    table.hasBLA = false;
                    return table;
                }

                do {
                    result = table._createBLAStage(result.stages, result.steps, ref);
                } while (result.hasBLA);

                table.stages = result.stages;
                table.steps = result.steps;
                table.hasBLA = true;
                return table;
            }


            _createBLAStep(ref) {
                let period = 0;
                let refLen = ref.length - 1;

                let blaStages = [];
                let blaSteps = [];

                let bla = BLAStepFloatExp.createBLA(0, new FloatExpComplex(0, 0), ref.get(1));
                let i;
                for (i = 2; i < refLen; i++) {
                    const [result, detected] = bla.step(ref.get(i));
                    if (detected) {
                        period = i;
                        break;
                    }
                    bla = result;
                }

                blaSteps.push(bla);

                if (!period) {
                    blaStages.push(new BLAStage(0, 1));
                    blaSteps.push(BLAStepFloatExp.newBLA(0, ref.get(refLen)));
                    return {
                        hasBLA: false,
                        steps: blaSteps,
                        stages: blaStages
                    };
                }

                if (i + 1 >= refLen) {
                    bla = BLAStepFloatExp.newBLA(i, ref.get(i));
                    i++;
                } else {
                    bla = BLAStepFloatExp.createBLA(i, ref.get(i), ref.get(i + 1));
                    i += 2;
                }

                for (; i < refLen; i++) {
                    const [result, detected] = bla.step(ref.get(i));

                    if (detected || bla.length >= period) {
                        blaSteps.push(bla);

                        if (i + 1 >= refLen || result.detectDip(ref.get(i + 1))) {
                            bla = BLAStepFloatExp.newBLA(i, ref.get(i));
                        } else {
                            bla = BLAStepFloatExp.createBLA(i, ref.get(i), ref.get(i + 1));
                            i++;
                        }
                    } else {
                        bla = result;
                    }
                }

                blaSteps.push(bla);
                blaStages.push(new BLAStage(0, blaSteps.length));
                blaSteps.push(BLAStepFloatExp.newBLA(0, ref.get(refLen)));

                return {
                    hasBLA: true,
                    steps: blaSteps,
                    stages: blaStages
                };
            }


            _createBLAStage(stages, steps, ref) {
                let prev = stages[stages.length - 1];
                let begin = steps.length;

                let period = 0;
                let i = prev.begin;

                let step = steps[i].merge(steps[i + 1])[0];
                step.next = i;
                i += 2;

                for (; i < prev.end; i++) {
                    const [result, detected] = step.merge(steps[i]);

                    if (detected) {
                        period = step.length;
                        steps.push(step);

                        if (i + 1 >= prev.end || result.detectDip(steps[i + 1].Z)) {
                            step = steps[i].copy();
                            step.next = i;
                            i++;
                        } else {
                            step = steps[i].merge(steps[i + 1])[0];
                            step.next = i;
                            i += 2;
                        }
                        break;
                    }
                    step = result;
                }

                if (!period) {
                    steps.push(step);
                    stages.push(new BLAStage(begin, steps.length));
                    steps.push(steps[prev.end]);
                    return {
                        hasBLA: false,
                        steps: steps,
                        stages: stages
                    };
                }

                for (; i < prev.end; i++) {
                    const [result, detected] = step.merge(steps[i]);

                    if (detected || step.length >= period) {
                        steps.push(step);

                        if (i + 1 >= prev.end || result.detectDip(steps[i + 1].Z)) {
                            step = steps[i].copy();
                            step.next = i;
                        } else {
                            step = steps[i].merge(steps[i + 1])[0];
                            step.next = i;
                            i++;
                        }
                    } else {
                        step = result;
                    }
                }

                steps.push(step);
                stages.push(new BLAStage(begin, steps.length));
                steps.push(steps[prev.end]);

                return {
                    hasBLA: true,
                    steps: steps,
                    stages: stages
                };
            }
        }

        /**
         * 
        */

        /**
         * ÁîüÊàêBLAË°®Ôºà‰øùÊåÅÂéüÊúâÁöÑAPIÁ≠æÂêç‰∏çÂèòÔºâ
         * @param {Complex[]} ref - ÂèÇËÄÉËΩ®ÈÅì
         * @param {number} scale - ÂΩìÂâçÂõæÂÉèÊØî‰æã
         * @returns {object} - BLA‰ø°ÊÅØ
         */
        function createBLATable(ref) {
            const table = BLATable.create(ref);
            return table;
        }

        function createBLATableFE(ref) {
            const table = BLATableFloatExp.create(ref);
            return table;
        }

        function chebshev(re, im) {
            return Math.max(Math.abs(re), Math.abs(im));
        }

        /**
         * Calculates the escape time for a point in the Mandelbrot set using perturbation theory.
         * @param {Complex} dc - The perturbation applied to the point.
         * @param {Complex[]} ref - The reference orbit.
         * @param {number} maxIter - The maximum iteration.
         * @param {number} bailout - The bailout value used for iteration termination.
         * @returns {number|null} - The escape time for the point or null if it doesn't escape.
         */
        const PTZ = new Complex(0, 0);
        function getPTBLA(dc, ref, steps, stages, maxIter, bailout, smooth = false) {
            let dcNorm = dc.norm()

            // let Z = new Complex(0, 0)
            PTZ.zero();

            let dzRe = 0, dzIm = 0;
            let newDzRe, newDzIm;

            let zRe = 0, zIm = 0;

            let i = 0, j = 0;
            let stage = stages.length;
            if (stage != 0) j = stages[stage - 1].begin;

            while (stage) {
                stage--;
                let begin = stages[stage].begin;
                let end = stages[stage].end;

                while (i < maxIter) {
                    let step = steps[j];
                    // const newDz = dz.mul(step.Z.add(z))
                    let stepZaddzRe = step.Z.re + zRe;
                    let stepZaddzIm = step.Z.im + zIm;
                    newDzRe = dzRe * stepZaddzRe - dzIm * stepZaddzIm;
                    newDzIm = dzRe * stepZaddzIm + dzIm * stepZaddzRe;

                    if (chebshev(newDzRe, newDzIm) > step.radius || dcNorm > step.radiusC) {
                        j = step.next;
                        break;
                    }

                    // dz = newDz.mul(step.A).addMut(dc.mul(step.B))
                    let dzARe = newDzRe * step.A.re - newDzIm * step.A.im;
                    let dzAIm = newDzRe * step.A.im + newDzIm * step.A.re;
                    let dcBRe = dc.re * step.B.re - dc.im * step.B.im;
                    let dcBIm = dc.re * step.B.im + dc.im * step.B.re;
                    dzRe = dzARe + dcBRe;
                    dzIm = dzAIm + dcBIm;

                    i += step.length;
                    j++;

                    // z = dz.add(steps[j].Z);
                    zRe = dzRe + steps[j].Z.re;
                    zIm = dzIm + steps[j].Z.im;

                    if (j == end || chebshev(zRe, zIm) < chebshev(dzRe, dzIm)) {
                        j = begin;
                        dzRe = zRe;
                        dzIm = zIm;
                    }
                }
            }

            // Z = ref.get(j);
            ref.getInplace(j, PTZ);


            while (i < maxIter) {
                // dz = dz.mul(Z.add(z)).add(dc);
                let ZaddzRe = PTZ.re + zRe;
                let ZaddzIm = PTZ.im + zIm;
                let tempDzRe = dzRe * ZaddzRe - dzIm * ZaddzIm;
                let tempDzIm = dzRe * ZaddzIm + dzIm * ZaddzRe;
                dzRe = tempDzRe + dc.re;
                dzIm = tempDzIm + dc.im;

                i++; j++;

                // Z = ref.get(j);
                ref.getInplace(j, PTZ);

                // z = dz.add(Z);
                zRe = dzRe + PTZ.re;
                zIm = dzIm + PTZ.im;
                let zAbs = zRe * zRe + zIm * zIm;

                if (zAbs > bailout) {
                    let iter = i - 1;
                    if (smooth) {
                        let fracIter = Math.log(zAbs) / 2;
                        fracIter = Math.log(fracIter / Math.LN2) / Math.LN2;
                        iter += 1 - fracIter;
                        return iter;
                    } else {
                        return iter; // If not smooth, just return the iteration count
                    }
                }

                if (j == ref.length - 1 || chebshev(zRe, zIm) < chebshev(dzRe, dzIm)) {
                    PTZ.zero();
                    dzRe = zRe;
                    dzIm = zIm;
                    j = 0;
                }
            }
            return i;
        }

        function getPTBLAFE(dc, ref, steps, stages, maxIter, bailout, smooth = false) {
            let dcNorm = dc.norm()

            let dz = new FloatExpComplex(0, 0);
            let z = new FloatExpComplex(0, 0);
            let Z = new FloatExpComplex(0, 0);

            let tempVars = {
                stepZZ: FloatExpComplex.ZERO.copy(),
                dcMulB: FloatExpComplex.ZERO.copy(),
                newDz: FloatExpComplex.ZERO.copy()
            }

            let i = 0, j = 0;
            let stage = stages.length;
            if (stage != 0) j = stages[stage - 1].begin;

            while (stage) {
                stage--;
                let begin = stages[stage].begin;
                let end = stages[stage].end;

                while (i < maxIter) {
                    let step = steps[j];

                    // const newDz = dz.mul(step.Z.add(z))
                    step.Z.addTo(z, tempVars.stepZZ)
                    tempVars.stepZZ.mulTo(dz, tempVars.newDz)

                    if (tempVars.newDz.norm().gt(step.radius) || dcNorm.gt(step.radiusC)) {
                        j = step.next;
                        break;
                    }

                    // dz = tempVars.newDz.mul(step.A).addMut(dc.mul(step.B))
                    tempVars.newDz.mulMut(step.A)
                    dc.mulTo(step.B, tempVars.dcMulB)
                    tempVars.newDz.addTo(tempVars.dcMulB, dz)

                    i += step.length;
                    j++;

                    // z = dz.add(steps[j].Z);
                    dz.addTo(steps[j].Z, z)

                    if (j == end || z.norm().lt(dz.norm())) {
                        j = begin;
                        z.storeTo(dz)
                    }
                }
            }

            // Z = ref.get(j)
            ref.getInplace(j, Z)


            while (i < maxIter) {
                // dz = dz.mul(Z.add(z)).addMut(dc);
                Z.addTo(z, tempVars.stepZZ)
                tempVars.stepZZ.mulTo(dz, tempVars.newDz)
                tempVars.newDz.addTo(dc, dz)

                i++; j++;

                // Z = ref.get(j)
                ref.getInplace(j, Z)

                // z = dz.add(Z);
                dz.addTo(Z, z)

                if (z.abs2().doubleValue() > bailout) {
                    let iter = i - 1;
                    if (smooth) {
                        let fracIter = Math.log(z.abs2().doubleValue()) / 2;
                        fracIter = Math.log(fracIter / Math.LN2) / Math.LN2;
                        iter += 1 - fracIter;
                        return iter;
                    } else {
                        return iter; // If not smooth, just return the iteration count
                    }
                }

                if (j == ref.length - 1 || z.norm().lt(dz.norm())) {
                    Z.zero();
                    z.storeTo(dz);
                    j = 0;
                }
            }
            return i;
        }

        /**
         * Generates a rainbow palette of colors.
         * @param {number} numColors - The number of colors to generate.
         * @returns {number[][]} - An array containing RGBA values for each color in the palette.
         */
        function generateRainbowPalette(numColors) {
            const rainbowColors = [];
            const frequency = 0.2; // Adjust the frequency to change the spread of colors

            for (let i = 0; i < numColors; i++) {
                const red = Math.sin(frequency * i) * 127 + 128;
                const green = Math.sin(frequency * 1.1 * i) * 127 + 128;
                const blue = Math.sin(frequency * 1.2 * i) * 127 + 128;
                rainbowColors.push([red | 0, green | 0, blue | 0, 255]);
            }

            return rainbowColors;
        }

        let defaultPalette = [[1, 1, 1], [205, 92, 92], [240, 128, 128], [255, 0, 0], [178, 34, 34], [139, 0, 0], [188, 143, 143], [165, 42, 42], [128, 0, 0], [250, 128, 114], [255, 99, 71], [233, 150, 122], [255, 127, 80], [255, 69, 0], [255, 160, 122], [160, 82, 45], [210, 105, 30], [139, 69, 19], [244, 164, 96], [255, 218, 185], [205, 133, 63], [255, 228, 196], [255, 140, 0], [222, 184, 135], [210, 180, 140], [255, 222, 173], [255, 228, 181], [255, 165, 0], [245, 222, 179], [184, 134, 11], [218, 165, 32], [255, 215, 0], [240, 230, 140], [238, 232, 170], [189, 183, 107], [255, 255, 0], [128, 128, 0], [107, 142, 35], [154, 205, 50], [85, 107, 47], [173, 255, 47], [127, 255, 0], [124, 252, 0], [0, 255, 0], [50, 205, 50], [152, 251, 152], [144, 238, 144], [34, 139, 34], [0, 128, 0], [0, 100, 0], [143, 188, 143], [46, 139, 87], [60, 179, 113], [0, 255, 127], [0, 250, 154], [102, 205, 170], [127, 255, 212], [64, 224, 208], [32, 178, 170], [72, 209, 204], [0, 139, 139], [0, 128, 128], [0, 255, 255], [175, 238, 238], [0, 206, 209], [95, 158, 160], [176, 224, 230], [173, 216, 230], [0, 191, 255], [135, 206, 235], [135, 206, 250], [70, 130, 180], [30, 144, 255], [176, 196, 222], [100, 149, 237], [65, 105, 225], [0, 0, 255], [0, 0, 205], [0, 0, 139], [0, 0, 128], [25, 25, 112], [106, 90, 205], [72, 61, 139], [123, 104, 238], [147, 112, 219], [138, 43, 226], [75, 0, 130], [153, 50, 204], [148, 0, 211], [186, 85, 211], [216, 191, 216], [221, 160, 221], [238, 130, 238], [255, 0, 255], [139, 0, 139], [128, 0, 128], [218, 112, 214], [199, 21, 133], [255, 20, 147], [255, 105, 180], [219, 112, 147], [220, 20, 60], [255, 192, 203], [255, 182, 193], [220, 220, 220], [211, 211, 211], [192, 192, 192], [169, 169, 169], [128, 128, 128], [105, 105, 105], [119, 136, 153], [112, 128, 144], [47, 79, 79]]
        let palette = defaultPalette;
        let colorStep = 6;
        /**
         * Calculates the color transition between two colors in a palette based on a percentage.
         * @param {number[][]} pal - The palette containing RGB values for colors.
         * @param {number} it - The percentage of transition between two colors (0 to 1).
         * @returns {number[]} - An array containing RGB values for the interpolated color.
         */
        function colorTrans(pal, it) {
            var percent = it - Math.floor(it);
            var c1 = Math.floor(it) % pal.length;
            var c2 = (c1 + 1) % pal.length;
            var r = (1 - percent) * pal[c1][0] + (percent) * pal[c2][0];
            var g = (1 - percent) * pal[c1][1] + (percent) * pal[c2][1];
            var b = (1 - percent) * pal[c1][2] + (percent) * pal[c2][2];
            return [r, g, b]
        }

        /**
         * Gets the color associated with the escape time 'it'.
         * @param {number|null} it - The escape time for a point or null if it doesn't escape.
         * @returns {number[]} - An array containing RGBA values for the color associated with the escape time.
         */
        function getColor(it, maxIter) {
            if (it == null || it >= maxIter) return [0, 0, 0, 255];
            else if (it < 0) return [palette[0][0], palette[0][1], palette[0][2], 255];
            let color = colorTrans(palette, it / colorStep);
            return [color[0], color[1], color[2], 255];
        }

        function groupArray(arr, groupSize = 3) {
            if (!arr || arr.length === 0 || groupSize <= 0) {
                return [];
            }

            const result = [];
            for (let i = 0; i < arr.length; i += groupSize) {
                result.push(arr.slice(i, i + groupSize));
            }
            return result;
        }

        function base64ToByteArray(base64String) {
            try {
                // ËøòÂéüÂ≠óÁ¨¶Âπ∂Â∞ÜURLÂÆâÂÖ®ÁöÑBase64ËΩ¨Êç¢‰∏∫Ê†áÂáÜBase64
                let base64 = base64String.replace(/-/g, '+').replace(/_/g, '/');

                // Ê∑ªÂä† padding (Á°Æ‰øùÈïøÂ∫¶ÊòØ4ÁöÑÂÄçÊï∞)
                const padLength = (4 - (base64.length % 4)) % 4;
                base64 += '='.repeat(padLength);

                const binaryString = atob(base64); // Ëß£Á†ÅBase64
                const byteArray = new Uint8Array(binaryString.length);

                for (let i = 0; i < binaryString.length; i++) {
                    byteArray[i] = binaryString.charCodeAt(i);
                }

                return Array.from(byteArray);
            } catch (error) {
                throw new Error("ËæìÂÖ•‰∏çÊòØ‰∏Ä‰∏™ÊúâÊïàÁöÑURLÂÆâÂÖ®Base64Â≠óÁ¨¶‰∏≤„ÄÇ");
            }
        }

        function byteArrayToBase64(byteArray) {
            if (!Array.isArray(byteArray)) {
                throw new Error("ËæìÂÖ•ÂøÖÈ°ªÊòØ‰∏Ä‰∏™Êï∞ÁªÑ„ÄÇ");
            }

            // È™åËØÅÂ≠óËäÇÊï∞ÁªÑ
            if (byteArray.some(v => typeof v !== 'number' || !Number.isInteger(v) || v < 0 || v > 255)) {
                throw new Error("Êï∞ÁªÑ‰∏≠ÁöÑÊØè‰∏™ÂÖÉÁ¥†ÂøÖÈ°ªÊòØ0-255‰πãÈó¥ÁöÑÊï¥Êï∞„ÄÇ");
            }

            // ÊûÑÂª∫‰∫åËøõÂà∂Â≠óÁ¨¶‰∏≤
            const binaryString = String.fromCharCode(...byteArray);

            // ÁºñÁ†ÅÂπ∂ËΩ¨Êç¢‰∏∫URLÂÆâÂÖ®Ê†ºÂºè
            const base64 = btoa(binaryString)
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=+$/, '');

            return base64;
        }

        /**
         * Represents a Mandelbrot set visualization.
         */
        class Mandelbrot {
            center;
            iterations;
            bailout;
            size;

            canvas;
            context;

            ref;

            refValid;

            stats;

            img;

            rendering;
            currentId;

            /**
             * @param {HTMLCanvasElement} canvas - The canvas element to draw the Mandelbrot set.
             * @param {DeepComplex} center - The center point of the Mandelbrot set.
             * @param {number} iterations - The number of iterations to perform for each point.
             * @param {number} bailout - The bailout value used for iteration termination.
             */
            constructor(canvas, center, iterations, bailout, isSecondary = false) {
                this.center = center;
                this.iterations = iterations;
                this.bailout = bailout * bailout;
                this.smooth = false;

                this.size = FloatExp.FOUR.copy();
                this.deep = false;

                this.canvas = canvas;
                this.context = canvas.getContext('2d', { willReadFrequently: true });
                this.rendering = false;
                this.currentId = 0;
                this.iterMap = null;
                this.videoRendering = false;
                this.isSecondary = isSecondary;
                this.redrawOnResize = true;
                this.canUpdateUrl = true;

                // Interaction state (only for primary instance)
                if (!isSecondary) {
                    this.transformState = { scale: 1, tx: 0, ty: 0 };
                    this.isInteracting = false;
                    this.dragStartPoint = { x: 0, y: 0 };
                    this.transformAtDragStart = { scale: 1, tx: 0, ty: 0 };
                    this.recalculationTimeout = null;
                    this.lastTouchDistance = 0;

                    this.canvas.addEventListener('mousedown', e => this.handleStart(e));
                    this.canvas.addEventListener('mousemove', e => this.handleMove(e));
                    this.canvas.addEventListener('mouseup', e => this.handleEnd(e));
                    this.canvas.addEventListener('mouseleave', e => this.handleEnd(e));
                    this.canvas.addEventListener('wheel', e => this.handleWheel(e), { passive: false });
                    this.canvas.addEventListener('touchstart', e => this.handleStart(e), { passive: false });
                    this.canvas.addEventListener('touchmove', e => this.handleMove(e), { passive: false });
                    this.canvas.addEventListener('touchend', e => this.handleEnd(e));
                    this.canvas.addEventListener('touchcancel', e => this.handleEnd(e));

                    const resizeObserver = new ResizeObserver(() => {
                        this.resizeCanvas();
                    });
                    resizeObserver.observe(this.canvas);
                }

                this.stats = {
                    ref: 0, refC: 0, calc: 0, guess: 0, approx: 0,
                    time: performance.now(), statusText: ''
                };
                this.lastUpdateTime = performance.now();
                this.requestForCancel = false;
                this.cancelling = false;

                if (!isSecondary) {
                    this.resizeCanvas(false);
                }
            }

            resizeCanvas(triggerUpdate = true, w, h) {
                if (this.isSecondary && w && h) {
                    this.canvas.width = w;
                    this.canvas.height = h;
                } else {
                    let dpr = window.devicePixelRatio;
                    this.canvas.width = window.innerWidth * dpr;
                    this.canvas.height = window.innerHeight * dpr;
                }
                this.iterMap = [...new Array(this.canvas.height)].map(e => new Float64Array(this.canvas.width).fill(-1));
                if (triggerUpdate && this.redrawOnResize) {
                    this.clear();
                    this.update();
                }
                this.minStep = Math.min(this.canvas.width, this.canvas.height);
                this.halfWidth = this.canvas.width / 2;
                this.halfHeight = this.canvas.height / 2;
            }

            setRedrawOnResize(bool) {
                this.redrawOnResize = bool;
            }

            setCanUpdateUrl(bool) {
                this.canUpdateUrl = bool;
            }

            handleStart(e) {
                e.preventDefault();
                this.isInteracting = true;
                this.cancel();

                if (e.touches) {
                    this.dragStartPoint = this.getTouchCenter(e.touches);
                    if (e.touches.length === 2) {
                        this.lastTouchDistance = this.getTouchDistance(e.touches);
                    }
                } else {
                    this.dragStartPoint = { x: e.clientX, y: e.clientY };
                }
                // Store the state at the beginning of the interaction
                this.transformAtDragStart = { ...this.transformState };
            }

            handleMove(e) {
                if (!this.isInteracting) return;
                e.preventDefault();

                if (e.touches) {
                    const currentTouchCenter = this.getTouchCenter(e.touches);
                    // Pan
                    const dx = currentTouchCenter.x - this.dragStartPoint.x;
                    const dy = currentTouchCenter.y - this.dragStartPoint.y;
                    this.transformState.tx = this.transformAtDragStart.tx + dx;
                    this.transformState.ty = this.transformAtDragStart.ty + dy;

                    // Pinch zoom
                    if (e.touches.length === 2) {
                        const currentDist = this.getTouchDistance(e.touches);
                        const scaleFactor = currentDist / this.lastTouchDistance;
                        // Combine with existing scale
                        const newScale = this.transformAtDragStart.scale * scaleFactor;

                        // Zoom towards the original touch center
                        const pivot = this.dragStartPoint;
                        this.transformState.tx = pivot.x - (pivot.x - this.transformAtDragStart.tx) * scaleFactor + dx;
                        this.transformState.ty = pivot.y - (pivot.y - this.transformAtDragStart.ty) * scaleFactor + dy;
                        this.transformState.scale = newScale;
                    }
                } else { // Mouse drag
                    const dx = e.clientX - this.dragStartPoint.x;
                    const dy = e.clientY - this.dragStartPoint.y;
                    this.transformState.tx = this.transformAtDragStart.tx + dx;
                    this.transformState.ty = this.transformAtDragStart.ty + dy;
                }

                // Update overlay info during interaction, if not in deep mode for performance
                if (!this.deep) {
                    const delta = this.getCurrentUIDelta();
                    const newCenter = this.center.add(delta);
                    updateInfoOverlay(
                        newCenter.re,
                        newCenter.im,
                        FloatExp.FOUR.div(this.size.div(this.transformState.scale)),
                        this.iterations
                    )
                }
                this.applyCssTransform();
            }

            handleEnd(e) {
                if (!this.isInteracting) return;
                this.isInteracting = false;
                this.applyTransformAndRecalculate();
            }

            handleWheel(e) {
                this.canvas.classList.add(e.fake ? 'transition-long' : 'transition')
                e.preventDefault();

                const scaleFactor = e.fake ? 4 : e.deltaY < 0 ? 2 : 0.5;
                const pivotX = e.clientX;
                const pivotY = e.clientY;

                this.transformState.tx = pivotX - (pivotX - this.transformState.tx) * scaleFactor;
                this.transformState.ty = pivotY - (pivotY - this.transformState.ty) * scaleFactor;
                this.transformState.scale *= scaleFactor;

                this.applyCssTransform();
                this.triggerRecalculation(e.fake ? 200 : 100);
            }

            // --- Helper functions for touch events ---
            getTouchCenter(touches) {
                let centerX = 0, centerY = 0;
                for (const touch of touches) {
                    centerX += touch.clientX;
                    centerY += touch.clientY;
                }
                return { x: centerX / touches.length, y: centerY / touches.length };
            }

            getTouchDistance(touches) {
                return Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
            }

            applyCssTransform() {
                const { scale, tx, ty } = this.transformState;
                this.canvas.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
            }

            triggerRecalculation(delay = 100) {
                clearTimeout(this.recalculationTimeout);
                this.recalculationTimeout = setTimeout(() => {
                    this.applyTransformAndRecalculate();
                }, delay);
            }

            getCurrentUIDelta() {
                const { scale, tx, ty } = this.transformState;
                const canvasX = ((canvas.width * 0.5) - tx / canvas.offsetWidth * canvas.width) / scale;
                const canvasY = ((canvas.height * 0.5) - ty / canvas.offsetHeight * canvas.height) / scale;
                const delta = this.getDelta(canvasX, canvasY);
                return delta
            }

            applyTransformAndRecalculate() {
                const { scale, tx, ty } = this.transformState;

                if (Math.abs(scale - 1) < 1e-9 && Math.abs(tx) < 1 && Math.abs(ty) < 1) {
                    return;
                }

                console.log(`Applying transform: scale=${scale}, tx=${tx}, ty=${ty}`);

                // Map canvas screen delta to canvas coordinate delta
                const delta = this.getCurrentUIDelta();

                // Update mathematical state
                this.goto(
                    this.center.add(delta), false
                )

                // Only zoom if scale is changed, otherwise just translate
                // Use 1e-9 as threshold to avoid floating point issues
                if (Math.abs(scale - 1) > 1e-9) {
                    this.zoom(this.size.div(scale));
                } else {
                    const translateX = tx / canvas.offsetWidth * canvas.width;
                    const translateY = ty / canvas.offsetHeight * canvas.height;
                    this.translate(translateX, translateY);
                }
                // Calculate the source rectangle from the old canvas content that is currently visible.
                const sx = -(tx / canvas.offsetWidth * canvas.width) / scale;
                const sy = -(ty / canvas.offsetHeight * canvas.height) / scale;
                const sWidth = this.canvas.width / scale;
                const sHeight = this.canvas.height / scale;

                // The CSS transform is about to be removed. To prevent a flicker,
                // we use drawImage to "bake" the transformed view into the canvas bitmap.
                // This creates an immediate, low-resolution preview.

                // Important: FIRST, reset the CSS transform so the canvas snaps back to its original state.
                // The browser won't render this change until the current script finishes,
                // so the user won't see the "snap".
                this.canvas.style.transform = '';
                this.context.globalCompositeOperation = 'copy';

                // THEN, draw the calculated portion of the (now untransformed) canvas back onto itself,
                // scaled up to fill the whole view. This effectively applies the transform permanently.
                this.context.drawImage(
                    this.canvas,   // Source image is the canvas itself
                    sx, sy, sWidth, sHeight,  // Source rectangle
                    0, 0, this.canvas.width, this.canvas.height // Destination rectangle (the whole canvas)
                );

                // Reset visual transform state for the next render
                this.transformState = { scale: 1, tx: 0, ty: 0 };

                this.canvas.classList.remove('transition')
                this.canvas.classList.remove('transition-long')
                this.requestForCancel = false;
                this.cancelling = false;
                this.update(floorPowerOfTwo(Math.max(2, scale)));
            }

            zoomOut() {
                const newMap = [...new Array(this.canvas.height)].map(e => new Float64Array(this.canvas.width).fill(-1));
                const h4 = Math.floor(this.canvas.height / 4);
                const w4 = Math.floor(this.canvas.width / 4);

                let inheritedPixels = 0;
                for (let y = 0; y < this.canvas.height; y += 2) {
                    const row = this.iterMap[y];
                    if (!row) continue;
                    const targetRow = newMap[h4 + (y >> 1)];
                    if (!targetRow) continue;
                    for (let x = 0; x < this.canvas.width; x += 2) {
                        targetRow[w4 + (x >> 1)] = row[x];
                        inheritedPixels++;
                    }
                }
                this.iterMap = newMap;
                this.size = this.size.mul(2);
                this.stats.guess += inheritedPixels; // Correctly attribute inherited pixels to progress

                // Scale down existing canvas content to match the new zoom level
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = this.canvas.width;
                tempCanvas.height = this.canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(this.canvas, 0, 0);

                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.context.drawImage(tempCanvas,
                    0, 0, this.canvas.width, this.canvas.height,
                    w4, h4, this.canvas.width / 2, this.canvas.height / 2
                );
            }

            /**
             * Zooms the Mandelbrot set visualization.
             * @param {FloatExp} size - The new size of the visualization.
             */
            zoom(size) {
                Decimal.config({
                    precision: -size.exp + 10
                })
                this.size = size;
                this.clear();
                this.stats.predCenter = null;
            }

            /**
             * Clear iteration map
             */
            clear() {
                this.iterMap.forEach(e => e.fill(-1))
            }

            /**
             * Moves the center of the Mandelbrot set visualization.
             * @param {DeepComplex} c - The new center point.
             */
            goto(c, clear = true) {
                this.center = c;
                this.refValid = false;
                this.stats.predCenter = null;
                if (clear) {
                    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.clear();
                }
            }

            /**
             * Sets the number of iterations for the Mandelbrot set visualization.
             * @param {number} it - The number of iterations.
             */
            setIterations(it) {
                this.iterations = parseInt(it);
            }

            /**
             * Resets the Mandelbrot set visualization to its initial state.
             */
            home() {
                this.goto(new DeepComplex(new Decimal(0), new Decimal(0)))
                this.size = FloatExp.FOUR.copy();
                this.deep = false;
                this.iterations = 256;
            }

            /**
             * Calculates the delta between a point and the base point on the canvas.
             * @param {number} x - The x-coordinate of the point.
             * @param {number} y - The y-coordinate of the point.
             * @param {number} [baseX] - The x-coordinate of the base point (optional).
             * @param {number} [baseY] - The y-coordinate of the base point (optional).
             * @returns {FloatExpComplex} - The delta as a complex number.
             */
            getDelta(x, y, baseX, baseY) {
                if (!baseX) baseX = this.halfWidth;
                if (!baseY) baseY = this.halfHeight;
                let deltaPerPixel = this.size.div(this.minStep);
                return this.deep ? new FloatExpComplex(
                    deltaPerPixel.mul(x - baseX),
                    deltaPerPixel.mul(baseY - y)

                ) : new Complex(
                    (x - baseX) * deltaPerPixel,
                    (baseY - y) * deltaPerPixel
                )
            }

            /**
             * Converts a delta relative to the this.center to screen coordinates.
             **/
            deltaToScreen(delta) {
                let deltaPerPixel = this.size.div(this.minStep);
                if (this.deep) {
                    return {
                        x: delta.re.div(deltaPerPixel).doubleValue() + this.halfWidth,
                        y: this.halfHeight - delta.im.div(deltaPerPixel).doubleValue()
                    }
                } else {
                    return {
                        x: delta.re / deltaPerPixel + this.halfWidth,
                        y: this.halfHeight - delta.im / deltaPerPixel
                    }
                }
            }


            /**
             * Retrieves the iteration of a pixel in the Mandelbrot set visualization.
             * @param {number} x - The x-coordinate of the pixel.
             * @param {number} y - The y-coordinate of the pixel.
             * @returns {number} - The iteration of the given point.
             */
            getIter(x, y) {
                if (x >= this.canvas.width || x < 0 || y >= this.canvas.height || y < 0) return -1
                return this.iterMap[y][x];
            }

            /**
             * Sets the iteration of a pixel in the Mandelbrot set visualization.
             * @param {number} x - The x-coordinate of the pixel.
             * @param {number} y - The y-coordinate of the pixel.
             * @param {number} it - The iteration
             * @param {number} w - The width of the pixel.
             * @param {number} h - The height of the pixel.
             */
            setIter(x, y, it, w = 1, h = 1) {
                if (x < 0 || x >= this.canvas.width || y < 0 || y >= this.canvas.height) return;
                this.iterMap[y][x] = it;

                const color = getColor(it, this.iterations);

                let i = (y * this.canvas.width + x) << 2;
                if (w == 1 && h == 1) {
                    this.image.data[i] = color[0]
                    this.image.data[i + 1] = color[1]
                    this.image.data[i + 2] = color[2]
                    this.image.data[i + 3] = 255
                } else {
                    for (let dy = 0; dy < h; dy++) {
                        if (y + dy >= this.canvas.height) break;
                        for (let dx = 0; dx < w; dx++) {
                            if (x + dx >= this.canvas.width) break;
                            let j = ((y + dy) * this.canvas.width + (x + dx)) << 2;
                            this.image.data[j] = color[0]
                            this.image.data[j + 1] = color[1]
                            this.image.data[j + 2] = color[2]
                            this.image.data[j + 3] = 255
                        }
                    }
                }
            }

            showInfo() {
                let totalPixels = this.canvas.width * this.canvas.height;
                let elapsedTime = performance.now() - this.stats.time;
                let estimatedTotalTime = (elapsedTime / (this.stats.calc + this.stats.guess)) * totalPixels;
                let estimatedRemainingTime = estimatedTotalTime - elapsedTime;

                let statusText = `Ref: ${this.stats.ref?.toLocaleString() ?? 0}it -> ${this.stats.refC?.toLocaleString() ?? 0}ckpts\n`;
                statusText += `BLA: ${this.blaTable?.steps?.length?.toLocaleString() ?? 0} entries\n`;
                statusText += `Res: ${this.canvas.width}x${this.canvas.height}\n`;
                statusText += `Calc/Guess/Total: ${this.stats.calc.toLocaleString()}/${this.stats.guess.toLocaleString()}/${totalPixels.toLocaleString()} px\n`;
                statusText += `Time: ${(elapsedTime / 1000).toFixed(3)}s ETA: ${(estimatedRemainingTime / 1000).toFixed(3)}s`;

                statusText += "\n" + this.stats.statusText;
                statsLabel.innerText = statusText;
                this.updateProgress();
            }

            // NEW: Separate function for progress bar to be called by worker callback
            updateProgress() {
                let totalPixels = this.canvas.width * this.canvas.height;
                progressBar.style.width = `${((this.stats.calc) / totalPixels * 100).toFixed(2)}%`;
                guessedProgressBar.style.width = `${((this.stats.guess) / totalPixels * 100).toFixed(2)}%`;
            }

            /**
             * Updates the Mandelbrot set visualization.
             *
             */
            async update(startBlockSize = 128) {
                const myId = ++this.currentId;
                if (this.rendering) {
                    this.requestForCancel = true;
                    while (this.rendering) {
                        await delay(10);
                        if (this.currentId !== myId) return; // Superceded by another request
                    }
                };

                this.requestForCancel = false;
                this.cancelling = false;
                this.rendering = true;

                const lock = await acquireWakelock();
                try {
                    let preCalculated = 0;
                    for (let y = 0; y < this.canvas.height; y++) {
                        const row = this.iterMap[y];
                        for (let x = 0; x < this.canvas.width; x++) {
                            if (row[x] > -1) preCalculated++;
                        }
                    }

                    this.stats = {
                        ref: 0,
                        refC: 0,
                        calc: 0,
                        guess: preCalculated,
                        approx: 0,
                        time: performance.now()
                    };


                    let prevDeep = this.deep;
                    this.deep = this.size.exp < -300;
                    console.log(prevDeep, this.deep)
                    if (prevDeep !== this.deep) this.refValid = false;

                    updateInfoOverlay(this.center.re, this.center.im, FloatExp.FOUR.div(this.size), this.iterations);
                    reInput.value = this.center.re.toString();
                    imInput.value = this.center.im.toString();
                    zoomInput.value = FloatExp.FOUR.div(this.size).toString();
                    itInput.value = this.iterations;

                    this.image = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);

                    let base, ref;
                    let refLen = 0;

                    base = this.center;
                    if (!this.refValid) {
                        console.log(performance.now() + " computing reference")
                        this.stats.statusText = 'Computing reference'
                        let nextTerm;

                        let precisionInBits = Math.ceil((-this.size.exp) * 3.321928094887362) + 52; // Add extra double precision bits

                        const generator = this.deep ?
                            getReferenceOrbitFEMPFR(base, this.size, this.iterations, precisionInBits) :
                            getReferenceOrbitMPFR(base, this.size.doubleValue(), this.iterations, precisionInBits);
                        while (!(nextTerm = await generator.next()).done) {
                            this.stats.ref = nextTerm.value.length;
                            this.stats.refC = nextTerm.value.size;
                            this.showInfo(); // Update progress
                            if (this.requestForCancel) {
                                this.cancelling = true;
                                return;
                            }
                        }
                        ref = nextTerm.value.orbit;
                        let predCenter = nextTerm.value.predCenter;
                        if (predCenter) {
                            console.log("Predicted center: ", predCenter)
                            // predCenter.x = -predCenter.x;
                            this.stats.predCenter = predCenter;
                        }

                        this.stats.ref = ref.length;
                        this.stats.refC = ref.size;

                        this.ref = ref;
                        this.refValid = true;
                    } else {
                        ref = this.ref;
                        this.stats.ref = ref.length;
                        this.stats.refC = ref.size;
                    }
                    refLen = ref.length;
                    console.log("ref: ", ref)

                    console.log(performance.now() + " bla calculation")
                    this.stats.statusText = 'BLA table construction'

                    if (this.deep) {
                        this.blaTable = createBLATableFE(ref, this.size.div(10));
                    }
                    else
                        this.blaTable = createBLATable(ref, this.size.doubleValue())

                    console.log(this.blaTable)


                    let autoIter = Math.max((refLen - 1) * 32, this.iterations);
                    this.setIterations(autoIter);

                    console.log(performance.now() + " perturbation")
                    this.stats.statusText = 'Perturbation'

                    await this.successiveRefinment(startBlockSize);

                    // Distance estimation
                    if (this.distanceEstimation) {
                        for (let y = 0; y < this.canvas.height - 1; y++) {
                            for (let x = 0; x < this.canvas.width - 1; x++) {
                                let gradX = this.iterMap[y][x + 1] - this.iterMap[y][x];
                                let gradY = this.iterMap[y + 1][x] - this.iterMap[y][x];
                                let diff = Math.sqrt(gradX * gradX + gradY * gradY);

                                let j = (y * this.canvas.width + x) << 2;

                                let color = getColor(Math.log1p(diff) * 32 / colorStep, 10000);

                                this.image.data[j] = color[0]
                                this.image.data[j + 1] = color[1]
                                this.image.data[j + 2] = color[2]
                                this.image.data[j + 3] = 255
                            }
                        }
                        this.context.putImageData(this.image, 0, 0)
                    }

                    if (!this.requestForCancel) this.recolorize();
                    console.log('done!')
                    this.stats.statusText = 'Finished'
                    this.rendering = false;
                    this.showInfo();
                    if (this.canUpdateUrl) {
                        const params = new URLSearchParams(window.location.hash.substring(1));

                        // Êõ¥Êñ∞ÊàñÊ∑ªÂä†Êñ∞ÁöÑÂèÇÊï∞
                        params.set("rec", compressDecimal(this.center.re.toString()));
                        params.set("imc", compressDecimal(this.center.im.toString()));
                        params.set("zmc", compressDecimal(FloatExp.FOUR.div(this.size).toString()));
                        params.set("itc", compressDecimal(this.iterations.toString()));
                        params.set("bailout", Math.sqrt(this.bailout).toString());
                        params.set("colorc", byteArrayToBase64(palette.flat(1)));
                        params.set("colorstep", colorStep);
                        params.set("smooth", this.smooth ? 1 : 0);

                        // ÈáçÂª∫ÂìàÂ∏åÂ≠óÁ¨¶‰∏≤
                        window.location.hash = params.toString();
                    }
                } catch (e) {
                    console.error(e);
                    alert("Error: " + e);
                } finally {
                    this.rendering = false;
                    lock?.release();
                }
            }

            async successiveRefinment(startSize) {
                // 1. ÂàùÂßãÂåñÈÖçÁΩÆ
                const TILE_SIZE = 64;
                const width = this.canvas.width;
                const height = this.canvas.height;
                const cx = width / 2;
                const cy = height / 2;
                // È¢ÑËÆ°ÁÆóÊúÄÂ§ßË∑ùÁ¶ªÂπ≥ÊñπÔºåÈÅøÂÖçÂºÄÊñπÔºåÊèêÂçáÂ∞ëËÆ∏ÊÄßËÉΩ
                const maxDistSq = cx * cx + cy * cy;

                // ËÅöÁÑ¶Âº∫Â∫¶ÔºöË∂äÂ§ß‰∏≠ÂøÉË∂ä‰ºòÂÖà„ÄÇ5.0 Â∑¶Âè≥ÊïàÊûúÂæàÊ£í„ÄÇ
                const FOCUS_STRENGTH = 5.0;
                const initialLog2 = Math.log2(startSize);

                let priorityQueue = [];

                // 2. Â°´ÂÖÖÂàùÂßã‰ªªÂä°
                for (let y = 0; y < height; y += TILE_SIZE) {
                    for (let x = 0; x < width; x += TILE_SIZE) {
                        let tcx = x + TILE_SIZE / 2;
                        let tcy = y + TILE_SIZE / 2;
                        // ÂΩí‰∏ÄÂåñË∑ùÁ¶ª (0~1)
                        let dist = Math.sqrt((tcx - cx) ** 2 + (tcy - cy) ** 2) / Math.sqrt(maxDistSq);

                        priorityQueue.push({
                            x: x, y: y, w: TILE_SIZE, h: TILE_SIZE,
                            step: startSize,
                            dist: dist
                        });
                    }
                }

                // 3. Â§ÑÁêÜÈòüÂàó
                while (priorityQueue.length > 0) {
                    if (this.requestForCancel) {
                        this.cancelling = true;
                        return;
                    }

                    // --- ‰ºòÂÖàÁ∫ßÊéíÂ∫è ---
                    // Score = Level + (Distance * Strength)
                    // step=1 ÁöÑ‰ªªÂä° level ÂæàÂ§ßÔºåÈÄöÂ∏∏ÊéíÂêéÈù¢Ôºå‰ΩÜÂ¶ÇÊûú Distance ÂæàÂ∞è(Âú®‰∏≠ÂøÉ)Ôºå
                    // ÂÆÉÁöÑ Score ‰ºöÊØîËæπÁºòÁöÑ step=8 ËøòÂ∞èÔºå‰ªéËÄåÂÆûÁé∞"‰∏≠ÂøÉÂÖàÂπ≥Êªë"ÁöÑÊïàÊûú„ÄÇ
                    priorityQueue.sort((a, b) => {
                        let levelA = initialLog2 - Math.log2(a.step);
                        let levelB = initialLog2 - Math.log2(b.step);

                        // ËøôÈáåÁªô step=1 (Final Pass) È¢ùÂ§ñÂä†‰∏ÄÁÇπÁÇπÊÉ©ÁΩöÊùÉÈáçÔºå
                        // Á°Æ‰øùÂú®Âêå‰∏ÄÂå∫ÂüüÂÜÖÔºåÂÖàÊää step=2 Èì∫ÂÆåÂÜçÂÅö step=1ÔºåÈÅøÂÖçÊï∞ÊçÆ‰æùËµñÁº∫Â§±
                        if (a.step === 1) levelA += 0.1;
                        if (b.step === 1) levelB += 0.1;

                        let scoreA = levelA + (a.dist * FOCUS_STRENGTH);
                        let scoreB = levelB + (b.dist * FOCUS_STRENGTH);
                        return scoreA - scoreB;
                    });

                    // ÂèñÂá∫‰ªªÂä°
                    const task = priorityQueue.shift();

                    // --- Ê†∏ÂøÉÊ∏≤ÊüìÈÄªËæë ---
                    if (task.step > 1) {
                        // > 1: Á≤óÁ≥ôÊ∏≤ÊüìÊ®°Âºè (Âè™ÁÆóÁΩëÊ†ºÔºåÁîªÊñπÂùó)
                        await this.renderCoarseTile(task);

                        // ÂàÜË£Ç‰ªªÂä°: ÊîæÂÖ•‰∏ã‰∏ÄÁ∫ß step
                        task.step >>= 1; // Èô§‰ª• 2
                        priorityQueue.push(task);
                    } else {
                        // = 1: Êô∫ËÉΩÁåúÊµãÊ®°Âºè (Final PassÔºåÂ∏¶ÊèíÂÄº)
                        await this.renderFinalTile(task);
                        // step 1 ÊòØÁªàÁÇπÔºå‰∏çÈúÄË¶ÅÂÜç push ÂõûÈòüÂàó
                    }

                    // await this.tryUpdateScreen();
                    if (this.requestForCancel) break;
                }

                // ÁªìÊùü
                await this.tryUpdateScreen();
            }

            /**
             * Ê®°Âºè A: Á≤óÁ≥ôÊ∏≤Êüì (Step > 1)
             * Âø´ÈÄüÂ°´ÂÖÖÁΩëÊ†ºÔºåÁªòÂà∂Â§ßÂÉèÁ¥†
             */
            async renderCoarseTile(task) {
                const { x: startX, y: startY, w, h, step } = task;
                const endX = Math.min(startX + w, this.canvas.width);
                const endY = Math.min(startY + h, this.canvas.height);

                // ÁΩëÊ†ºÂØπÈΩê
                const firstX = startX + (step - (startX % step)) % step;
                const firstY = startY + (step - (startY % step)) % step;

                for (let y = firstY; y < endY; y += step) {
                    for (let x = firstX; x < endX; x += step) {
                        // Â¶ÇÊûúÂ∑≤ÁªèË¢´ÁÆóËøá‰∫Ü(ÊØîÂ¶Ç‰∏ä‰∏ÄËΩÆ step*2 Áïô‰∏ãÁöÑÁÇπ)ÔºåÁõ¥Êé•Ë∑≥Ëøá
                        // Ê≥®ÊÑèÔºöËøôÈáåÈúÄË¶Å ensure iterMap ÊúâÂÄº„ÄÇ
                        // Â¶ÇÊûúÊòØÁ¨¨‰∏ÄËΩÆÔºåiterMap ÂèØËÉΩÊòØ -1„ÄÇ
                        if (this.iterMap[y][x] > -1) {
                            // Âè™ÊòØ‰∏∫‰∫ÜÂà∑Êñ∞ visualsÔºåÈáçÁªò‰∏Ä‰∏ã(ÂèØÈÄâÔºåÂ¶ÇÊûúËßâÂæóÈó™ÁÉÅÂèØ‰ª•ÂéªÊéâ)
                            // this.setIter(x, y, this.iterMap[y][x], step, step);
                        } else {
                            // ÁúüÊ≠£ÁöÑËÆ°ÁÆóÔºåÁîª‰∏Ä‰∏™ step x step ÁöÑÁü©ÂΩ¢
                            this.calculatePixel(x, y, step, step);
                        }
                    }
                    if (this.requestForCancel) return;
                    await this.tryUpdateScreen();
                }
            }

            /**
             * Ê®°Âºè B: Á≤æÁªÜÊ∏≤Êüì (Step = 1)
             * ÂåÖÂê´‚ÄúÁåúÊµã‚ÄùÈÄªËæëÔºåÂ°´Ë°• 1x1 ÁöÑÁ©∫Èöô
             */
            async renderFinalTile(task) {
                const { x: startX, y: startY, w, h } = task;
                const endX = Math.min(startX + w, this.canvas.width);
                const endY = Math.min(startY + h, this.canvas.height);

                for (let pass = 0; pass < 3; pass++) {
                    for (let y = startY; y < endY; y++) {
                        for (let x = startX; x < endX; x++) {
                            // 1. Â¶ÇÊûúËøô‰∏™ÁÇπÂ∑≤ÁªèÊúâÂÄº (Êù•Ëá™‰∫é step=2,4,8...)ÔºåË∑≥Ëøá
                            if (this.iterMap[y][x] > -1) {
                                // ÈáçÁªò‰∏Ä‰∏ãÊàê 1x1 (Ê∂àÈô§‰πãÂâçÁöÑÂ§ßÊñπÂùóÊÆãÁïô)
                                this.setIter(x, y, this.iterMap[y][x], 1, 1);
                                continue;
                            }

                            // 2. Â∞ùËØïÁåúÊµã (Guessing)
                            // Ê£ÄÊü•Ê∞¥Âπ≥ÈÇªÂ±Ö (Left & Right)
                            // Ê≥®ÊÑèÔºöÂõ†‰∏∫Êàë‰ª¨ÊòØ Tiled Â§ÑÁêÜÔºåËæπÁïåÂÉèÁ¥†ÂèØËÉΩÈúÄË¶ÅÂéª getIter ÊãøÂÖ∂‰ªñ Tile ÁöÑÊï∞ÊçÆ
                            // this.getIter Â∫îËØ•Â§ÑÁêÜË∂äÁïåËøîÂõû 0 Êàñ null
                            let left = this.getIter(x - 1, y);
                            let right = this.getIter(x + 1, y);

                            let guessed = false;

                            // Ê∞¥Âπ≥ÊèíÂÄºÁ≠ñÁï•
                            if (left > -1 && right > -1 && Math.floor(left) === Math.floor(right)) {
                                this.setIter(x, y, (left + right) / 2, 1, 1);
                                this.stats.guess++;
                                guessed = true;
                            }

                            // Â¶ÇÊûúÊ∞¥Âπ≥Áåú‰∏çÂá∫Êù•ÔºåËØïÂûÇÁõ¥ÊèíÂÄº (Top & Bottom)
                            if (!guessed) {
                                let up = this.getIter(x, y - 1);
                                let down = this.getIter(x, y + 1);

                                if (up > -1 && down > -1 && Math.floor(up) === Math.floor(down)) {
                                    this.setIter(x, y, (up + down) / 2, 1, 1);
                                    this.stats.guess++;
                                    guessed = true;
                                }
                            }

                            // 3. ÂÆûÂú®Áåú‰∏çÂá∫Êù•ÔºåÊö¥ÂäõËÆ°ÁÆó
                            if (pass === 2 && !guessed) {
                                this.calculatePixel(x, y, 1, 1); // drawWidth=1
                            }
                        }
                        if (this.requestForCancel) return;
                        await this.tryUpdateScreen();
                    }
                }
            }

            // ÈÖçÂêà‰∏äËø∞ÈÄªËæëÔºåtryUpdateScreen ÂèØ‰ª•Á®çÂæÆÈôç‰Ωé‰∏ÄÁÇπÂº∫Âà∂Èó¥ÈöîÔºåÂõ†‰∏∫Êàë‰ª¨Â∑≤ÁªèÂú®Â§ßÂæ™ÁéØÈáåÂÅö‰∫ÜÊµÅÊéß
            async tryUpdateScreen() {
                let currentTime = performance.now();
                if (currentTime - this.lastUpdateTime < 100) {
                    return;
                }
                this.showInfo();
                this.updateProgress();
                this.context.putImageData(this.image, 0, 0);
                // ‰ΩøÁî® requestAnimationFrame ÁöÑËøôÁßç await ÂÜôÊ≥ïÂèØ‰ª•ËÆ© UI Á∫øÁ®ãÂëºÂê∏
                await delay(0);
                this.lastUpdateTime = currentTime;
            }

            calculatePixel(x, y, drawWidth, drawHeight) {
                let delta = this.getDelta(x, y);
                let iter = this.deep ?
                    getPTBLAFE(
                        delta,
                        this.ref,
                        this.blaTable.steps,
                        this.blaTable.stages,
                        this.iterations,
                        this.bailout,
                        this.smooth
                    ) :
                    getPTBLA(
                        delta,
                        this.ref,
                        this.blaTable.steps,
                        this.blaTable.stages,
                        this.iterations,
                        this.bailout,
                        this.smooth
                    );

                this.setIter(x, y, iter, drawWidth, drawHeight);
                this.stats.calc++;
            }

            async cancel() {
                this.requestForCancel = true;
                if (!this.rendering) return;
                while (this.rendering) {
                    await delay(10);
                }
            }

            /**
             * Recolorize the Mandelbrot set visualization without recalculating.
             */

            recolorize() {
                this.image = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
                for (let y = 0; y < this.canvas.height; y++) {
                    for (let x = 0; x < this.canvas.width; x++) {
                        let it = this.iterMap[y][x];
                        if (it >= 0) {
                            let color = getColor(it, this.iterations);
                            let i = (y * this.canvas.width + x) << 2;
                            this.image.data[i] = color[0];
                            this.image.data[i + 1] = color[1];
                            this.image.data[i + 2] = color[2];
                            this.image.data[i + 3] = 255;
                        } else {
                            let i = (y * this.canvas.width + x) << 2;
                            this.image.data[i] = 0;
                            this.image.data[i + 1] = 0;
                            this.image.data[i + 2] = 0;
                            this.image.data[i + 3] = 0;
                        }
                    }
                }
                this.context.putImageData(this.image, 0, 0);
            }


            /**
             * Initiates the download of the Mandelbrot set visualization as a PNG image.
             */
            download() {
                const downloadLink = document.createElement('a');

                downloadLink.href = canvas.toDataURL('image/png');
                downloadLink.download = 'mandelbrot.png';

                downloadLink.click();
            }

            /**
             * Increases the number of iterations for the Mandelbrot set visualization.
             * @param {number} mul - The multiplier for increasing the iterations.
             */
            increaseIteration(mul) {
                let prevIter = this.iterations;
                this.setIterations(this.iterations * mul);

                for (let y = 0; y < this.canvas.height; y++) {
                    for (let x = 0; x < this.canvas.width; x++) {
                        if (this.iterMap[y][x] >= prevIter) {
                            this.setIter(x, y, -1)
                        }
                    }
                }
                this.update()
            }

            /** 
             * Translates the iteration map by the specified delta values. Fill -1 for new areas.
             * This is to move the view when panning without recalculating everything.
             * @param {number} deltaX - The delta in the x direction.
             * @param {number} deltaY - The delta in the y direction.
            */
            translate(deltaX, deltaY) {
                // Use inplace translation to avoid extra memory allocation
                let xStart, xEnd, yStart, yEnd;
                let xStep, yStep;
                if (deltaX > 0) {
                    xStart = this.canvas.width - 1;
                    xEnd = -1;
                    xStep = -1;
                } else {
                    xStart = 0;
                    xEnd = this.canvas.width;
                    xStep = 1;
                }
                if (deltaY > 0) {
                    yStart = this.canvas.height - 1;
                    yEnd = -1;
                    yStep = -1;
                } else {
                    yStart = 0;
                    yEnd = this.canvas.height;
                    yStep = 1;
                }
                for (let y = yStart; y != yEnd; y += yStep) {
                    for (let x = xStart; x != xEnd; x += xStep) {
                        let srcX = x - deltaX;
                        let srcY = y - deltaY;
                        if (srcX >= 0 && srcX < this.canvas.width && srcY >= 0 && srcY < this.canvas.height) {
                            this.iterMap[y][x] = this.iterMap[srcY]?.[srcX] ?? -1;
                        } else {
                            this.iterMap[y][x] = -1;
                        }
                    }
                }

            }

            async renderFrames(onProgress, onFrame, startIndex = 0, shouldSkip = null) {
                let frames = [];
                let refreshRef = false;
                this.videoRendering = true;

                try {
                    // Zoom out to the start index zoom level
                    for (let i = 0; i < startIndex; i++) {
                        this.zoomOut();
                        if (this.size.exp > -20 && !refreshRef) {
                            this.center = new DeepComplex(
                                new Decimal(this.center.re.toPrecision(30)),
                                new Decimal(this.center.im.toPrecision(30))
                            );
                            this.refValid = false;
                            this.iterations = Math.min(this.iterations, 1024);
                            refreshRef = true;
                        }
                    }

                    while (this.size.doubleValue() < 32) {
                        if (this.requestForCancel) break;

                        const currentFrameIdx = frames.length + startIndex;
                        let skipped = false;
                        if (shouldSkip && await shouldSkip(currentFrameIdx)) {
                            skipped = true;
                        }

                        if (!skipped) {
                            if (onProgress) onProgress(currentFrameIdx + 1, 0, "Rendering Frame " + (currentFrameIdx + 1));

                            // Capture local progress from update
                            const originalUpdateProgress = this.updateProgress;
                            this.updateProgress = () => {
                                const totalPixels = this.canvas.width * this.canvas.height;
                                const prog = (this.stats.calc + this.stats.guess) / totalPixels;
                                if (onProgress) onProgress(currentFrameIdx + 1, prog, `Rendering Frame ${currentFrameIdx + 1}`);
                                originalUpdateProgress.call(this);
                            };

                            await this.update();
                            this.updateProgress = originalUpdateProgress;

                            if (this.requestForCancel) break;

                            const blob = await this.canvas.convertToBlob();
                            const scale = this.size.copy();

                            if (onFrame) {
                                await onFrame(currentFrameIdx, blob, scale);
                            } else {
                                const img = new Image();
                                await new Promise((resolve) => {
                                    img.onload = resolve;
                                    img.src = URL.createObjectURL(blob);
                                });
                                frames[frames.length] = { frame: img, scale: scale }; // Store in array
                            }
                        } else {
                            if (onProgress) onProgress(currentFrameIdx + 1, 1, `Skipping frame ${currentFrameIdx + 1}`);
                        }

                        if (!frames[currentFrameIdx - startIndex]) {
                            frames[currentFrameIdx - startIndex] = { scale: this.size.copy() };
                        }

                        this.zoomOut();

                        // Reference point management during zoom out
                        if (this.size.exp > -20 && !refreshRef) {
                            this.center = new DeepComplex(
                                new Decimal(this.center.re.toPrecision(30)),
                                new Decimal(this.center.im.toPrecision(30))
                            )
                            this.refValid = false;
                            this.iterations = Math.min(this.iterations, 1024);
                            refreshRef = true;
                        }
                    }
                } finally {
                    this.videoRendering = false;
                }

                return frames;
            }
        }

        class KFRReader {
            constructor(arrayBuffer) {
                this.buffer = arrayBuffer;
                this.content = new TextDecoder().decode(arrayBuffer); // Decode ArrayBuffer to string
                this.data = this.parseContent(); // Parse key-value pairs
            }

            // Parse content line by line into key-value pairs
            parseContent() {
                const result = {};
                const lines = this.content.split(/\r?\n/); // Split into lines
                lines.forEach(line => {
                    const [key, value] = line.split(":").map(part => part.trim());
                    if (key && value !== undefined) {
                        result[key] = value;
                    }
                });
                return result;
            }

            // Getter for `Re`
            get re() {
                return this.data.Re;
            }

            // Getter for `Im`
            get im() {
                return this.data.Im;
            }

            // Getter for `Zoom`
            get zoom() {
                return this.data.Zoom;
            }

            // Getter for `Iterations`
            get iter() {
                return parseInt(this.data.Iterations, 10);
            }

            // Getter for `IterDiv`
            get iterDiv() {
                return parseFloat(this.data.IterDiv) ?? 8;
            }

            get smooth() {
                return this.data.Smooth !== undefined && this.data.Smooth !== "0";
            }

            // Getter for `Colors`, converts the raw color data into an array of [r, g, b] tuples
            get colors() {
                if (!this.data.Colors) return defaultPalette;
                const colorValues = this.data.Colors.split(",").slice(0, -1).map(Number);
                const rgbArray = [];
                for (let i = 0; i < colorValues.length; i += 3) {
                    rgbArray.push([colorValues[i + 2], colorValues[i + 1], colorValues[i]]);
                }
                return rgbArray;
            }

            get period() {
                return parseInt(this.data.Period);
            }

            get refStore() {
                return this.data.RefStore;
            }
        }

        class KFRWriter {
            constructor() {
                this.data = {};
            }

            // Setters for `Re`, `Im`, `Zoom`, `Iterations`, `IterDiv`, and `Colors`
            set re(value) {
                this.data.Re = value;
            }

            set im(value) {
                this.data.Im = value;
            }

            set zoom(value) {
                this.data.Zoom = value;
            }

            set iter(value) {
                this.data.Iterations = value;
            }

            set iterDiv(value) {
                this.data.IterDiv = value;
            }

            set colors(value) {
                this.data.Colors = value.map(color => {
                    // convert each color to BGR format
                    return `${color[2]},${color[1]},${color[0]},`;
                }).join("");
            }

            set smooth(value) {
                this.data.Smooth = value ? "1" : "0";
            }

            set period(value) {
                this.data.Period = value;
            }

            set refStore(compressor) {
                let result = []
                let checkpoints = compressor.checkpoints();
                for (let key in checkpoints) {
                    result.push(`${key}|${checkpoints[key].re}|${checkpoints[key].im}`);
                }
                this.data.RefStore = result.join(",");
            }

            // Convert the data to a KFR formatted string
            toString() {
                return Object.entries(this.data)
                    .map(([key, value]) => `${key}: ${value}`)
                    .join("\r\n");
            }

            load(mandelbrot) {
                this.re = mandelbrot.center.re.toString();
                this.im = mandelbrot.center.im.toString();
                let zoom = FloatExp.FOUR.div(mandelbrot.size);
                this.zoom = `${zoom.base}E${zoom.exp}`;
                this.iter = mandelbrot.iterations.toString();
                this.iterDiv = (colorStep * palette.length) / 1024
                this.colors = palette;
                this.smooth = mandelbrot.smooth;
                this.period = mandelbrot.ref.length - 1;
                this.refStore = mandelbrot.ref;
            }
        }

        const dict = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz123456789'
        function b58Compress(n, pad = true) {
            if (n == 0) return '0'

            // Detect 7 same digits
            let str = n.toString();
            let same = str.split('').every((v, i, a) => v === a[0]) && str.length === 7;
            if (same) {
                let digit = str[0];
                return "I" + digit;
            }

            let b58 = [];
            while (n > 0) {
                b58.push(dict[n % 58]);
                n = Math.floor(n / 58);
            }
            let result = b58.reverse().join("");
            if (pad) result = result.padStart(4, 'A')
            return result;
        }

        function b58Decompress(b58, pad = true) {
            let n = 0;
            let i = 0;
            for (let i = 0; i < b58.length; i++) {
                const char = b58[i];
                n *= 58
                let index = dict.indexOf(char)
                if (index === -1) {
                    throw new Error("Invalid character")
                }
                n += index
            }
            let result = n.toString()
            if (pad) result = result.padStart(7, '0');
            return result
        }

        function compressInteger(str) {
            let hasSign = str[0] === '+' || str[0] === '-';

            let i = 0;
            let builder = []

            if (hasSign) {
                builder.push(str[0] === '+' ? '' : '-');
                i++;
            }

            while (i < str.length) {
                let part = str.slice(i, i + 7);
                let compressed = b58Compress(parseInt(part), part.length === 7)
                builder.push(compressed);
                i += 7;
            }
            return builder.join("")
        }

        function compressDecimal(str) {
            let [mant, exp] = str.toLowerCase().split('e');
            let [dec, frac] = mant.split(".");

            let result = compressInteger(dec)
            if (frac) {
                result += "." + compressInteger(frac);
            }
            if (exp) {
                let expCompressed = compressInteger(exp)
                sign = (expCompressed[0] === '-') ? '' : '_';
                result += sign + expCompressed;
            }

            return result
        }

        function decompressInteger(str) {
            let hasSign = str[0] === '_' || str[0] === '-';

            let i = 0;
            let builder = []

            if (hasSign) {
                builder.push(str[0] === '_' ? '' : '-');
                i++;
            }

            while (i < str.length) {
                if (str[i] === '0') {
                    builder.push("0000000");
                    i++;
                } else if (str[i] === 'I') {
                    let digit = str[i + 1];
                    builder.push(digit.repeat(7));
                    i += 2;
                }
                else {
                    let part = str.slice(i, i + 4);
                    let decompressed = b58Decompress(part, part.length === 4)
                    builder.push(decompressed);
                    i += 4;
                }
            }
            return builder.join("")
        }

        function decompressDecimal(str) {
            let mant, exp;
            let result = '', sign = '';
            str = str.trim();
            if (str.startsWith("_")) {
                mant = str.slice(1)
                sign = ''
            }
            else if (str.startsWith("-")) {
                mant = str.slice(1)
                sign = '-'
            }
            else {
                mant = str;
            }

            let expsign = '';
            if (mant.includes('-')) {
                [mant, exp] = mant.split('-')
                expsign = '-'
            }
            else if (mant.includes('_')) {
                [mant, exp] = mant.split('_')
            }

            let int, frac;
            [int, frac] = mant.split('.')
            result += sign + decompressInteger(int);

            if (frac && frac != '') result += '.' + decompressInteger(frac);

            if (exp && exp != '') {
                result += "e" + expsign + decompressInteger(exp)
            }

            return result;
        }


        function formatLongString(str, len = 30, pre = 15, suf = 15) {
            const s = str.toString();
            if (s.length > len) {
                return s.substring(0, pre) + '...' + s.substring(s.length - suf);
            }
            return s;
        }

        function updateInfoOverlay(re, im, zoom, iter) {
            document.getElementById('info-re').textContent = formatLongString(re);
            document.getElementById('info-im').textContent = formatLongString(im);
            document.getElementById('info-zoom').textContent = formatLongString(zoom.toString());
            document.getElementById('info-iter').textContent = iter.toLocaleString();
        }


        let c = new DeepComplex(
            new Decimal(0), new Decimal(0));

        let size = FloatExp.FOUR.copy();
        let bailout = 2;
        let iterations = 256;
        let smooth = false;

        const params = new URLSearchParams(window.location.hash.substring(1));

        params.forEach((value, key) => {
            switch (key) {

                // readable values
                case "re":
                    c.re = new Decimal(value);
                    params.delete(key);
                    break;
                case "im":
                    c.im = new Decimal(value);
                    params.delete(key);
                    break;
                case "zoom":
                    size = FloatExp.FOUR.div(getFloatExp(value));
                    params.delete(key);
                    break;
                case "iter":
                    iterations = parseInt(value);
                    params.delete(key);
                    break;
                case "bailout":
                    bailout = parseFloat(value);
                    params.delete(key);
                    break;
                case "colors":
                    palette = groupArray(value.split(",").map(e => parseInt(e)))
                    params.delete(key);
                    break;
                case "colorstep":
                    colorStep = parseFloat(value)
                    break;
                case "smooth":
                    smooth = value === "1" || value === "true";
                    break;

                // compressed values
                case "rec":
                    c.re = new Decimal(decompressDecimal(value));
                    break;
                case "imc":
                    c.im = new Decimal(decompressDecimal(value));
                    break;
                case "zmc":
                    size = FloatExp.FOUR.div(parseFloatExp(decompressDecimal(value)));
                    break;
                case "itc":
                    iterations = parseInt(decompressDecimal(value));
                    break;
                case "colorc":
                    palette = groupArray(base64ToByteArray(value));
                    break;
            }
        });
        location.hash = params.toString();

        const mandelbrot = new Mandelbrot(canvas, c, iterations, bailout)
        mandelbrot.smooth = smooth;
        mandelbrot.zoom(size)
        mandelbrot.update()


        document.getElementById('menu-toggle').addEventListener('click', () => {
            document.getElementById('sidebar').classList.toggle('open');
        });

        document.getElementById('info-overlay').addEventListener('click', () => {
            document.getElementById('info-overlay').classList.toggle('info-overlay-collapsed');
        });

        document.getElementById('smart-zoom').addEventListener('click', (e) => {
            if (mandelbrot.stats.predCenter) {

                const screenCoord = mandelbrot.deltaToScreen(mandelbrot.stats.predCenter);
                const fakeEvent = {
                    clientX: (1 - screenCoord.x / canvas.width) * window.innerWidth,
                    clientY: (1 - screenCoord.y / canvas.height) * window.innerHeight,
                    deltaY: -1, // zoom in
                    preventDefault: () => { },
                    fake: true
                };
                mandelbrot.cancel();
                mandelbrot.handleWheel(fakeEvent);
                mandelbrot.stats.predCenter = null;
            }
        });

        document.getElementById('goto').addEventListener('click', e => {
            mandelbrot.goto(new DeepComplex(
                new Decimal(reInput.value),
                new Decimal(imInput.value)
            ))

            mandelbrot.zoom(FloatExp.FOUR.div(parseFloatExp(zoomInput.value)));
            mandelbrot.setIterations(parseInt(itInput.value));

            mandelbrot.update();
        })

        document.getElementById('home').addEventListener('click', e => {
            mandelbrot.home()
            mandelbrot.update()
        })

        document.getElementById('download').addEventListener('click', e => {
            mandelbrot.download()
        })

        sampleLoadBtn.addEventListener('click', e => {
            const loc = samples[sampleSelect.value]
            mandelbrot.goto(new DeepComplex(
                new Decimal(loc.re), new Decimal(loc.im)
            ))
            mandelbrot.zoom(FloatExp.FOUR.div(getFloatExp(loc.zoom)));
            mandelbrot.setIterations(loc.it);
            mandelbrot.update()
        })


        document.getElementById('zoom-in').addEventListener('click', function () {
            mandelbrot.zoom(mandelbrot.size.div(2)); // Changed to 2x for consistency with wheel
            mandelbrot.update();
        });

        document.getElementById('zoom-out').addEventListener('click', function () {
            mandelbrot.zoom(mandelbrot.size.mul(2)); // Changed to 2x
            mandelbrot.update();
        });

        document.getElementById('increase-iter').addEventListener('click', function () {
            mandelbrot.increaseIteration(2);
            mandelbrot.update();
        });

        document.getElementById('decrease-iter').addEventListener('click', function () {
            mandelbrot.setIterations(mandelbrot.iterations / 2);
            mandelbrot.clear();
            mandelbrot.update()
        });

        const fullscreenBtn = document.getElementById('fullscreen');
        fullscreenBtn.addEventListener('click', function () {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else {
                document.exitFullscreen();
            }
        });

        // Dynamically create an input element
        const inputElement = document.createElement("input");
        inputElement.type = "file";
        inputElement.accept = ".kfr"; // Accept only .kfr files
        inputElement.style.display = "none";

        // Append the input element to the document
        document.body.appendChild(inputElement);

        // Trigger file upload when a button is clicked
        document.getElementById("kfr").addEventListener('click', () => {
            inputElement.click(); // Simulate a click on the input element
        });

        document.getElementById("save-kfr").addEventListener('click', () => {
            const writer = new KFRWriter();
            writer.load(mandelbrot);
            const kfrContent = writer.toString();

            // Create a Blob from the KFR content
            const blob = new Blob([kfrContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);

            // Create a link to download the file
            const a = document.createElement('a');
            a.href = url;
            a.download = `mandelbrot-${new Date().toISOString()}.kfr`; // Set the desired file name
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });

        // Handle file selection
        inputElement.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) {
                alert("No file selected!");
                return;
            }

            // Ensure the file is a .kfr file
            if (!file.name.endsWith('.kfr')) {
                alert("Please upload a valid .kfr file.");
                return;
            }

            // Read the file as an ArrayBuffer
            const arrayBuffer = await file.arrayBuffer();

            // Parse the .kfr file using KFRReader
            const reader = new KFRReader(arrayBuffer);

            mandelbrot.goto(new DeepComplex(reader.re, reader.im))
            mandelbrot.zoom(FloatExp.FOUR.div(parseFloatExp(reader.zoom)));
            mandelbrot.setIterations(reader.iter);
            mandelbrot.smooth = reader.smooth;
            palette = reader.colors;
            colorStep = 1024 / reader.colors.length * reader.iterDiv;
            if (reader.period > 0) {
                mandelbrot.period = reader.period;
                let compressor;
                if (mandelbrot.size.lt(new FloatExp(1, -300))) {
                    compressor = new ReferenceCompressorFloatExp(mandelbrot.center.toFloatExp());
                    let checkpoints = reader.refStore.split(',')
                    for (let i = 1; i < checkpoints.length; i++) {
                        let [index, real, imag] = checkpoints[i].split('|')
                        compressor.addCheckpoint(parseInt(index), new FloatExpComplex(parseFloatExp(real), parseFloatExp(imag)))
                    }
                } else {
                    compressor = new ReferenceCompressor(mandelbrot.center.re.toNumber(), mandelbrot.center.im.toNumber());
                    let checkpoints = reader.refStore.split(',')
                    for (let i = 1; i < checkpoints.length; i++) {
                        let [index, real, imag] = checkpoints[i].split('|')
                        compressor.addCheckpoint(parseInt(index), new Complex(parseFloat(real), parseFloat(imag)))
                    }
                }
                compressor.length = reader.period + 1;
                mandelbrot.ref = compressor;
                mandelbrot.refValid = true;
            }
            mandelbrot.update();
        });

        // Frame Storage for Video Editor (File System Access API)
        class FrameStorage {
            constructor() {
                this.dirHandle = null;
                this.cache = new Map();
                this.maxCacheSize = 20; // Reduced RAM cache
            }

            async initDir() {
                try {
                    this.dirHandle = await window.showDirectoryPicker({
                        mode: 'readwrite',
                        id: 'mandelbrot-video-frames'
                    });
                    return true;
                } catch (e) {
                    console.error("DirectoryPicker error:", e);
                    return false;
                }
            }

            async equalsSession(center, size) {
                if (!this.dirHandle) return false;
                const fileHandle = await this.dirHandle.getFileHandle('session.json');
                const file = await fileHandle.getFile();
                const reader = new FileReader();
                reader.readAsText(file);
                reader.onload = () => {
                    const session = JSON.parse(reader.result);
                    return session.center.re.equals(center.re.toString()) &&
                        session.center.im.equals(center.im.toString()) &&
                        session.size.base.equals(size.base.toString()) &&
                        session.size.exp.equals(size.exp.toString());
                }
            }

            async saveFrame(index, blob) {
                if (!this.dirHandle) return;
                const name = `frame_${index.toString().padStart(5, '0')}.png`;
                const fileHandle = await this.dirHandle.getFileHandle(name, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(blob);
                await writable.close();
            }

            async saveSession(metadata) {
                if (!this.dirHandle) return;
                const fileHandle = await this.dirHandle.getFileHandle('session.json', { create: true });
                const writable = await fileHandle.createWritable();
                // Ensure kfrPath is set
                metadata.kfrPath = 'session.kfr';
                await writable.write(JSON.stringify(metadata, null, 2));
                await writable.close();
            }

            async saveKFR(mandelbrot) {
                if (!this.dirHandle) return;
                const writer = new KFRWriter();
                writer.load(mandelbrot);
                const kfrContent = writer.toString();
                const fileHandle = await this.dirHandle.getFileHandle('session.kfr', { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(kfrContent);
                await writable.close();
            }

            async loadKFR() {
                if (!this.dirHandle) return null;
                try {
                    const fileHandle = await this.dirHandle.getFileHandle('session.kfr');
                    const file = await fileHandle.getFile();
                    const arrayBuffer = await file.arrayBuffer();
                    return new KFRReader(arrayBuffer);
                } catch (e) {
                    return null;
                }
            }

            async scanMissingFrames(count) {
                if (!this.dirHandle) return [];
                const missing = [];
                for (let i = 0; i < count; i++) {
                    const exists = await this.checkExistingFrame(i);
                    if (!exists) missing.push(i);
                }
                return missing;
            }

            async loadSession() {
                if (!this.dirHandle) return null;
                try {
                    const fileHandle = await this.dirHandle.getFileHandle('session.json');
                    const file = await fileHandle.getFile();
                    const text = await file.text();
                    return JSON.parse(text);
                } catch (e) {
                    return null;
                }
            }

            async checkExistingFrame(index) {
                if (!this.dirHandle) return false;
                const name = `frame_${index.toString().padStart(5, '0')}.png`;
                try {
                    await this.dirHandle.getFileHandle(name);
                    return true;
                } catch (e) {
                    return false;
                }
            }

            async getFrame(index) {
                if (this.cache.has(index)) {
                    // Move to end of map (LRU)
                    const val = this.cache.get(index);
                    this.cache.delete(index);
                    this.cache.set(index, val);
                    return val;
                }

                if (!this.dirHandle) return null;
                const name = `frame_${index.toString().padStart(5, '0')}.png`;
                try {
                    const fileHandle = await this.dirHandle.getFileHandle(name);
                    const file = await fileHandle.getFile();
                    const img = new Image();
                    img.src = URL.createObjectURL(file);
                    await new Promise(r => img.onload = r);

                    this.cache.set(index, img);
                    if (this.cache.size > this.maxCacheSize) {
                        const firstKey = this.cache.keys().next().value;
                        const oldImg = this.cache.get(firstKey);
                        URL.revokeObjectURL(oldImg.src);
                        this.cache.delete(firstKey);
                    }
                    return img;
                } catch (e) {
                    return null;
                }
            }

            clear() {
                this.cache.forEach(img => URL.revokeObjectURL(img.src));
                this.cache.clear();
            }
        }

        // Video Editor Class
        class VideoEditor {
            constructor() {
                this.keyframes = [];
                this.keyframeMetadata = null;
                this.timeline = [];
                this.resolution = { width: 1920, height: 1080 };
                this.fps = 30;
                this.currentTime = 0;
                this.isPlaying = false;
                this.animationId = null;
                this.lastAnimateTime = 0;
                this.isScrubbing = false;
                this.storage = new FrameStorage();

                // UI Elements
                this.dialog = document.getElementById('video-editor-dialog');
                this.previewCanvas = document.getElementById('editor-preview-canvas');
                this.timelineList = document.getElementById('timeline-list');
                this.keyframeInfo = document.getElementById('keyframe-info');

                this.initUI();
            }

            initUI() {
                // Close button
                document.getElementById('editor-close').onclick = () => this.close();

                // Settings
                const widthInput = document.getElementById('editor-width');
                const heightInput = document.getElementById('editor-height');
                const fpsInput = document.getElementById('editor-fps');
                const presetSelect = document.getElementById('editor-preset');

                presetSelect.onchange = (e) => {
                    const val = e.target.value;
                    if (val === '720p') { widthInput.value = 1280; heightInput.value = 720; }
                    else if (val === '1080p') { widthInput.value = 1920; heightInput.value = 1080; }
                    else if (val === '2k') { widthInput.value = 2560; heightInput.value = 1440; }
                    else if (val === '4k') { widthInput.value = 3840; heightInput.value = 2160; }
                    else if (val === '8k') { widthInput.value = 7680; heightInput.value = 4320; }

                    if (val !== 'custom') {
                        this.resolution.width = parseInt(widthInput.value);
                        this.resolution.height = parseInt(heightInput.value);
                    }
                };

                widthInput.oninput = (e) => {
                    this.resolution.width = parseInt(e.target.value) || 1920;
                    presetSelect.value = 'custom';
                };
                heightInput.oninput = (e) => {
                    this.resolution.height = parseInt(e.target.value) || 1080;
                    presetSelect.value = 'custom';
                };
                fpsInput.oninput = (e) => {
                    this.fps = parseInt(e.target.value) || 30;
                };

                // Buttons
                document.getElementById('collect-keyframes-btn').onclick = () => this.collectKeyframes();
                document.getElementById('resume-keyframes-btn').onclick = () => this.resumeRendering();
                document.getElementById('clear-keyframes-btn').onclick = () => this.clearKeyframes();
                document.getElementById('add-control-point').onclick = () => this.addControlPoint();
                document.getElementById('export-video-btn').onclick = () => this.exportVideo();

                // Playback controls
                document.getElementById('play-pause-btn').onclick = () => this.togglePlayPause();
                document.getElementById('stop-btn').onclick = () => this.stop();
                document.getElementById('timeline-scrubber').oninput = (e) => {
                    this.isScrubbing = true;
                    const value = parseInt(e.target.value) / 1000;
                    this.seekTo(value * this.getTotalDuration());
                };
                document.getElementById('timeline-scrubber').onchange = () => {
                    this.isScrubbing = false;
                };
                document.getElementById('fullscreen-btn').onclick = () => this.toggleFullscreen();
            }

            open() {
                // Set initial resolution from current canvas
                this.resolution.width = mandelbrot.canvas.width | 1 + 1;
                this.resolution.height = mandelbrot.canvas.height | 1 + 1;
                document.getElementById('editor-width').value = this.resolution.width;
                document.getElementById('editor-height').value = this.resolution.height;
                document.getElementById('editor-fps').value = this.fps;

                // Sync preset dropdown
                const presetSelect = document.getElementById('editor-preset');
                if (this.resolution.width === 1280 && this.resolution.height === 720) presetSelect.value = '720p';
                else if (this.resolution.width === 1920 && this.resolution.height === 1080) presetSelect.value = '1080p';
                else if (this.resolution.width === 2560 && this.resolution.height === 1440) presetSelect.value = '2k';
                else if (this.resolution.width === 3840 && this.resolution.height === 2160) presetSelect.value = '4k';
                else if (this.resolution.width === 7680 && this.resolution.height === 4320) presetSelect.value = '8k';
                else presetSelect.value = 'custom';

                // Inhibit redraw on resize while editor is open
                mandelbrot.setRedrawOnResize(false);
                this.dialog.showModal();
            }

            close() {
                this.stop();
                mandelbrot.setRedrawOnResize(true);
                this.storage.clear();
                this.dialog.close();
            }

            async resumeRendering() {
                const progressDialog = document.getElementById("video-progress-dialog");
                const statusText = document.getElementById("video-status");

                // Initialize storage (requests folder)
                if (!await this.storage.initDir()) return;

                this.dialog.close();
                progressDialog.showModal();
                statusText.innerText = "Loading session...";

                try {
                    const session = await this.storage.loadSession();
                    if (!session) {
                        alert("No session.json found in this folder.");
                        progressDialog.close();
                        this.dialog.showModal();
                        return;
                    }

                    const kfrReader = await this.storage.loadKFR();
                    if (!kfrReader) {
                        alert("No session.kfr found in this folder.");
                        progressDialog.close();
                        this.dialog.showModal();
                        return;
                    }

                    // Restore simulation parameters from KFR
                    mandelbrot.goto(new DeepComplex(kfrReader.re, kfrReader.im))
                    mandelbrot.zoom(FloatExp.FOUR.div(parseFloatExp(kfrReader.zoom)));
                    mandelbrot.setIterations(kfrReader.iter);
                    mandelbrot.smooth = kfrReader.smooth;
                    palette = kfrReader.colors;
                    colorStep = 1024 / kfrReader.colors.length * kfrReader.iterDiv;
                    mandelbrot.update();

                    // Restore video settings from session.json
                    this.resolution.width = session.resolution.width;
                    this.resolution.height = session.resolution.height;
                    this.fps = session.fps || 30;

                    // Restore keyframe metadata for playback
                    this.keyframeMetadata = {
                        center: mandelbrot.center.copy(),
                        size: mandelbrot.size.copy(),
                        startScale: new FloatExp(session.size.base, session.size.exp),
                        frameCount: session.frames.length
                    };

                    // Trigger collection with resume info
                    await this.collectKeyframes(true, session);

                } catch (e) {
                    console.error(e)
                    alert("Error resuming session: " + e.message);
                    progressDialog.close();
                    this.dialog.showModal();
                }
            }

            async collectKeyframes(isResume = false, sessionData = null) {
                const progressDialog = document.getElementById("video-progress-dialog");
                const previewCanvas = document.getElementById("video-preview-canvas");
                const previewCtx = previewCanvas.getContext('2d');
                const totalProgBar = document.getElementById("video-total-progress");
                const frameProgBar = document.getElementById("video-frame-progress");
                const stageText = document.getElementById("video-stage");
                const statusText = document.getElementById("video-status");
                const cancelBtn = document.getElementById("video-cancel");

                this.dialog.close();
                progressDialog.showModal();

                let requestCancel = false;
                let currentSession = {
                    center: {
                        re: mandelbrot.center.re.toString(),
                        im: mandelbrot.center.im.toString()
                    },
                    resolution: {
                        width: this.resolution.width,
                        height: this.resolution.height
                    },
                    size: { base: mandelbrot.size.base, exp: mandelbrot.size.exp },
                    frames: [] // Will store indices
                };

                // Initialize storage (requests folder)
                if (!isResume) {
                    if (!await this.storage.initDir()) {
                        progressDialog.close();
                        this.dialog.showModal();
                        return;
                    }
                } else {
                    if (!await this.storage.equalsSession(mandelbrot.center, mandelbrot.size)) {
                        if (confirm("Another session exist, overwrite?")) {
                            this.storage.clear()
                            await this.storage.saveSession(currentSession);
                        } else return;
                    }
                }

                // Initial save of simulation state
                await this.storage.saveKFR(mandelbrot);

                try {
                    const startIndex = 0;

                    cancelBtn.onclick = async () => {
                        requestCancel = true;
                        statusText.innerText = "Saving and Cancelling...";
                        // Final attempt to save metadata before stopping
                        await this.storage.saveSession(currentSession);
                        // Signal Mandelbrot to stop
                        await offMandel.cancel();
                    };

                    // Store metadata for the editor state
                    this.keyframeMetadata = {
                        center: mandelbrot.center.copy(),
                        size: mandelbrot.size.copy(),
                        startScale: mandelbrot.size.copy(),
                        frameCount: 0
                    };

                    // Create offscreen mandelbrot
                    const offCanvas = new OffscreenCanvas(this.resolution.width, this.resolution.height);
                    const offMandel = new Mandelbrot(
                        offCanvas,
                        mandelbrot.center.copy(),
                        mandelbrot.iterations,
                        Math.sqrt(mandelbrot.bailout),
                        true
                    );

                    offMandel.setCanUpdateUrl(false);
                    offMandel.resizeCanvas(false, this.resolution.width, this.resolution.height);
                    offMandel.size = mandelbrot.size.copy();
                    offMandel.smooth = mandelbrot.smooth;

                    if (mandelbrot.refValid) {
                        offMandel.ref = mandelbrot.ref;
                        offMandel.refValid = true;
                    }

                    previewCanvas.width = this.resolution.width;
                    previewCanvas.height = this.resolution.height;

                    // Fix: Use log2 for progress to avoid Infinity issues in deep mode
                    const maxOctaves = Math.ceil(5 - offMandel.size.log2Value());

                    // Collect keyframes using existing renderFrames
                    const renderedResults = await offMandel.renderFrames(
                        (frameIdx, frameProg, status) => {
                            if (requestCancel) {
                                offMandel.requestForCancel = true;
                                return;
                            }
                            const totalProg = Math.min(0.99, (frameIdx - 1 + frameProg) / maxOctaves);
                            totalProgBar.style.width = (totalProg * 100) + "%";
                            frameProgBar.style.width = (frameProg * 100) + "%";
                            stageText.innerText = "Collection Phase";
                            statusText.innerText = status;

                            // Live preview
                            previewCtx.drawImage(offCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
                        },
                        async (idx, blob, scale) => {
                            await this.storage.saveFrame(idx, blob);
                            if (!currentSession.frames.includes(idx)) {
                                currentSession.frames.push(idx);
                                currentSession.frames.sort((a, b) => a - b);
                            }
                            // Periodically save session to avoid loss on crash
                            if (idx % 5 === 0) await this.storage.saveSession(currentSession);
                        },
                        startIndex,
                        async (idx) => {
                            // shouldSkip logic
                            return currentSession.frames.includes(idx);
                        }
                    );

                    if (requestCancel) {
                        this.keyframes = [];
                        this.keyframeMetadata = null;
                        progressDialog.close();
                        this.dialog.showModal();
                        return;
                    }

                    // Final session save
                    await this.storage.saveSession(currentSession);

                    // Reconstruct keyframes metadata (Index based)
                    this.keyframes = currentSession.frames.map(idx => {
                        return { index: idx };
                    });

                    if (this.keyframes.length < 2) {
                        alert("Not enough frames collected (at least 2 required)");
                        this.keyframes = [];
                        this.keyframeMetadata = null;
                        progressDialog.close();
                        this.dialog.showModal();
                        return;
                    }

                    this.keyframeMetadata.frameCount = this.keyframes.length;

                    // Auto-populate initial timeline (Time in seconds)
                    const durationInFrames = this.keyframes.length;
                    this.timeline = [
                        { time: 0, frame: 0 },
                        { time: durationInFrames, frame: this.keyframes.length - 1 }
                    ];

                    this.updateKeyframeDisplay();
                    this.updateTimelineDisplay();
                    this.updateExportButton();

                    // Setup preview canvas
                    this.previewCanvas.width = this.resolution.width;
                    this.previewCanvas.height = this.resolution.height;

                } catch (err) {
                    console.error(err);
                    alert('Error collecting keyframes: ' + err.message);
                } finally {
                    progressDialog.close();
                    this.dialog.showModal();
                }
            }

            clearKeyframes() {
                if (!confirm('Clear all keyframes and timeline data?')) return;

                this.keyframes = [];
                this.keyframeMetadata = null;
                this.timeline = [];
                this.stop();
                this.storage.clear();

                this.updateKeyframeDisplay();
                this.updateTimelineDisplay();
                this.updateExportButton();
            }

            updateKeyframeDisplay() {
                const info = this.keyframeInfo;

                if (this.keyframeMetadata && this.keyframes.length > 0) {
                    const { center, size, frameCount } = this.keyframeMetadata;
                    info.innerHTML = `
                        <div class="info-status">‚úì Collected (${frameCount} frames)</div>
                        <div class="info-detail">Center: ${center.re.toFixed(4)} + ${center.im.toFixed(4)}i</div>
                        <div class="info-detail">Size: ${size.toString()}</div>
                    `;
                    document.getElementById('collect-keyframes-btn').disabled = true;
                    document.getElementById('clear-keyframes-btn').style.display = 'block';
                } else {
                    info.innerHTML = '<div class="info-status">Keyframes: Not Collected</div>';
                    document.getElementById('collect-keyframes-btn').disabled = false;
                    document.getElementById('clear-keyframes-btn').style.display = 'none';
                }
            }

            updateTimelineDisplay() {
                this.timelineList.innerHTML = '';

                this.timeline.forEach((point, index) => {
                    const item = document.createElement('div');
                    item.className = 'control-point-item';
                    item.innerHTML = `
                        <label>Time (s):</label>
                        <input type="number" step="0.1" value="${point.time}" data-index="${index}" data-field="time">
                        <label>Frame:</label>
                        <input type="number" step="0.1" value="${point.frame}" data-index="${index}" data-field="frame">
                        <button onclick="videoEditor.removeControlPoint(${index})">√ó</button>
                    `;

                    // Add change listeners
                    const inputs = item.querySelectorAll('input');
                    inputs.forEach(input => {
                        input.onchange = (e) => {
                            const idx = parseInt(e.target.dataset.index);
                            const field = e.target.dataset.field;
                            this.timeline[idx][field] = parseFloat(e.target.value);
                            this.sortTimeline();
                            this.updateTimelineDisplay();
                        };
                    });

                    this.timelineList.appendChild(item);
                });

                // Update time display
                const totalDuration = this.getTotalDuration();
                document.getElementById('total-duration').textContent = totalDuration.toFixed(1);
            }

            addControlPoint() {
                if (this.keyframes.length === 0) {
                    alert('Please collect keyframes first');
                    return;
                }

                const maxFrame = this.keyframes.length - 1;
                const lastPoint = this.timeline[this.timeline.length - 1];
                const newTime = lastPoint ? lastPoint.time + 1 : 1;

                this.timeline.push({ time: newTime, frame: Math.min(maxFrame, 0) });
                this.sortTimeline();
                this.updateTimelineDisplay();
                this.updateExportButton();
            }

            removeControlPoint(index) {
                if (this.timeline.length <= 2) {
                    alert('Must have at least 2 control points');
                    return;
                }
                this.timeline.splice(index, 1);
                this.updateTimelineDisplay();
            }

            sortTimeline() {
                this.timeline.sort((a, b) => a.time - b.time);
            }

            getTotalDuration() {
                return this.timeline.length > 0 ? this.timeline[this.timeline.length - 1].time : 0;
            }

            getFrameAtTime(time) {
                if (this.timeline.length === 0) return 0;

                // Clamp time
                const minTime = this.timeline[0].time;
                const maxTime = this.timeline[this.timeline.length - 1].time;
                time = Math.max(minTime, Math.min(maxTime, time));

                // Find surrounding control points
                let before = this.timeline[0];
                let after = this.timeline[this.timeline.length - 1];

                for (let i = 0; i < this.timeline.length - 1; i++) {
                    if (this.timeline[i].time <= time && this.timeline[i + 1].time >= time) {
                        before = this.timeline[i];
                        after = this.timeline[i + 1];
                        break;
                    }
                }

                // Linear interpolation
                if (after.time === before.time) return before.frame;
                const t = (time - before.time) / (after.time - before.time);
                return before.frame + (after.frame - before.frame) * t;
            }

            async renderFrameAt(uiFrameIndex, useCanvas = null) {
                if (this.keyframes.length === 0 || !this.keyframeMetadata) return;

                // UX Mapping: UI 0 = Outermost (Shallow, Index N-1), UI N-1 = Innermost (Deep, Index 0)
                // This makes the timeline naturally progress from defined start to defined end as Zoom In.
                const totalFrames = this.keyframes.length;
                const internalFrameIndex = (totalFrames - 1) - uiFrameIndex;

                const lower = Math.floor(internalFrameIndex);
                const upper = Math.ceil(internalFrameIndex);
                const canvas = useCanvas || this.previewCanvas;
                const ctx = canvas.getContext('2d');
                const w = canvas.width, h = canvas.height, cx = w / 2, cy = h / 2;

                const blend = internalFrameIndex - lower;

                // Clamp indices to be safe
                const idxLower = Math.max(0, Math.min(totalFrames - 1, lower));
                const idxUpper = Math.max(0, Math.min(totalFrames - 1, upper));

                const kfLowerMetadata = this.keyframes[idxLower];
                const diskIdxLower = kfLowerMetadata.index;

                const kfLower = await this.storage.getFrame(diskIdxLower);
                if (!kfLower) return;

                if (idxLower === idxUpper) {
                    // Exact frame
                    ctx.drawImage(kfLower, 0, 0, w, h);
                } else {
                    // Fractional - perform zoom interpolation
                    const kfUpperMetadata = this.keyframes[idxUpper];
                    const diskIdxUpper = kfUpperMetadata.index;
                    const kfUpper = await this.storage.getFrame(diskIdxUpper);

                    if (!kfUpper) {
                        ctx.drawImage(kfLower, 0, 0, w, h);
                    } else {
                        // zoom-based blending (Interpolation)
                        // scale1: 1.0 -> 0.5 (Lower/Deep frame shrinks relative to viewport moving out - or expands moving in)
                        const scale1 = Math.pow(2, -blend);
                        const scale2 = Math.pow(2, 1 - blend);

                        ctx.save();
                        ctx.clearRect(0, 0, w, h);
                        ctx.imageSmoothingEnabled = true;

                        // Lower index frame (Deep/Inside)
                        ctx.drawImage(kfLower, cx - (w * scale1) / 2, cy - (h * scale1) / 2, w * scale1, h * scale1);

                        // Upper index frame (Shallow/Outside)
                        ctx.globalAlpha = Math.max(0, Math.min(1, (blend - 0.1) / 0.8));
                        ctx.drawImage(kfUpper, cx - (w * scale2) / 2, cy - (h * scale2) / 2, w * scale2, h * scale2);
                        ctx.restore();
                    }
                }

                // --- Overlays ---
                ctx.save();
                ctx.imageSmoothingEnabled = true;

                // 1. Zoom Text Overlay (Based on internal Actual Zoom)
                const zoomStart = FloatExp.FOUR.div(this.keyframeMetadata.size);
                const currZoomLog2 = zoomStart.log2Value() - internalFrameIndex;
                const currScale = FloatExp.fromLog2(currZoomLog2);
                const zoomText = `Zoom: ${currScale.exp < 7 ? currScale.doubleValue().toFixed(2) : currScale.base.toFixed(2) + 'E' + currScale.exp}`;

                ctx.font = `${Math.round(w / 60)}px monospace`;
                const zoomMetrics = ctx.measureText(zoomText);
                const zoomPadding = 8;
                const zoomRectW = zoomMetrics.width + zoomPadding * 2;
                const zoomRectH = Math.round(w / 40);

                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(20, 20, zoomRectW, zoomRectH);

                ctx.fillStyle = 'white';
                ctx.textBaseline = 'middle';
                ctx.fillText(zoomText, 20 + zoomPadding, 20 + zoomRectH / 2);

                // 2. Frame Label (Only for editor preview, not export)
                if (!useCanvas) {
                    // Show the UI Frame Index (0 = Start)
                    const frameLabel = `Frame: ${uiFrameIndex.toFixed(2)}`;
                    ctx.font = `${Math.round(w / 60)}px monospace`;
                    const textMetrics = ctx.measureText(frameLabel);
                    const padding = 8;
                    const rectW = textMetrics.width + padding * 2;
                    const rectH = Math.round(w / 40);

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(w - rectW - 20, 20, rectW, rectH);

                    ctx.fillStyle = 'white';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(frameLabel, w - rectW - 20 + padding, 20 + rectH / 2);
                }

                ctx.restore();
            }

            togglePlayPause() {
                if (this.isPlaying) {
                    this.pause();
                } else {
                    this.play();
                }
            }

            play() {
                if (this.keyframes.length === 0) return;

                this.isPlaying = true;
                document.getElementById('play-pause-btn').textContent = '‚è∏';

                this.lastAnimateTime = performance.now();
                const totalDuration = this.getTotalDuration();

                const animate = async (now) => {
                    if (!this.isPlaying) return;

                    const elapsed = (now - this.lastAnimateTime) / 1000;
                    this.lastAnimateTime = now;

                    // If scrubbing, we don't advance the time or update the UI based on playback
                    // The seekTo handler handles the updates
                    if (!this.isScrubbing) {
                        this.currentTime = (this.currentTime + elapsed) % totalDuration;

                        const frameIndex = this.getFrameAtTime(this.currentTime);
                        await this.renderFrameAt(frameIndex);

                        document.getElementById('current-time').textContent = this.currentTime.toFixed(1);
                        document.getElementById('timeline-scrubber').value = (this.currentTime / totalDuration) * 1000;
                    }

                    this.animationId = requestAnimationFrame(animate);
                };

                this.animationId = requestAnimationFrame(animate);
            }

            pause() {
                this.isPlaying = false;
                document.getElementById('play-pause-btn').textContent = '‚ñ∂';
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }

            stop() {
                this.pause();
                this.currentTime = 0;
                document.getElementById('current-time').textContent = '0.0';
                document.getElementById('timeline-scrubber').value = 0;
                if (this.keyframes.length > 0) {
                    this.renderFrameAt(0);
                }
            }

            async seekTo(time) {
                this.currentTime = time;
                const frameIndex = this.getFrameAtTime(time);
                await this.renderFrameAt(frameIndex);
                document.getElementById('current-time').textContent = time.toFixed(1);
            }

            /* 
            recolorize() {
                // Incompatible with FrameStorage (requires raw data)
            }
            */

            toggleFullscreen() {
                const wrapper = document.getElementById('editor-preview-wrapper');
                if (!document.fullscreenElement) {
                    wrapper.requestFullscreen().catch(err => {
                        alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                    });
                } else {
                    document.exitFullscreen();
                }
            }

            updateExportButton() {
                const canExport = this.keyframes.length > 0 && this.timeline.length >= 2;
                document.getElementById('export-video-btn').disabled = !canExport;
            }

            async exportVideo() {
                // File picker
                let fileHandle;
                try {
                    fileHandle = await window.showSaveFilePicker({
                        suggestedName: `mandelbrot-${Date.now()}.webm`,
                        types: [{ description: 'WebM Video', accept: { 'video/webm': ['.webm'] } }]
                    });
                } catch (e) {
                    if (e.name === 'AbortError') return;
                    alert('Error selecting file: ' + e.message);
                    return;
                }

                const fileStream = await fileHandle.createWritable();

                const webmWriter = new WebMWriter({
                    fileWriter: fileStream,
                    codec: 'VP9',
                    width: this.resolution.width,
                    height: this.resolution.height,
                    frameRate: this.fps
                });

                const encoder = new VideoEncoder({
                    output: chunk => webmWriter.addFrame(chunk),
                    error: e => console.error(e)
                });

                encoder.configure({
                    codec: 'vp09.00.10.08',
                    width: this.resolution.width,
                    height: this.resolution.height,
                    bitrate: 12_000_000,
                    framerate: this.fps,
                    latencyMode: 'quality'
                });

                const totalDuration = this.getTotalDuration();
                const totalFrames = Math.ceil(totalDuration * this.fps);
                const exportCanvas = new OffscreenCanvas(this.resolution.width, this.resolution.height);

                // Show progress dialog with preview during export
                const progressDialog = document.getElementById("video-progress-dialog");
                const previewCanvas = document.getElementById("video-preview-canvas");
                const previewCtx = previewCanvas.getContext('2d');
                const totalProgBar = document.getElementById("video-total-progress");
                const frameProgBar = document.getElementById("video-frame-progress");
                const stageText = document.getElementById("video-stage");
                const statusText = document.getElementById("video-status");
                const cancelBtn = document.getElementById("video-cancel");

                this.dialog.close();
                progressDialog.showModal();

                previewCanvas.width = this.resolution.width;
                previewCanvas.height = this.resolution.height;

                let requestCancel = false;
                cancelBtn.onclick = () => {
                    requestCancel = true;
                    statusText.innerText = "Cancelling...";
                };

                const exportBtn = document.getElementById('export-video-btn');
                const originalText = exportBtn.textContent;

                try {
                    for (let i = 0; i < totalFrames; i++) {
                        if (requestCancel) break;
                        const time = i / this.fps;
                        const frameIndex = this.getFrameAtTime(time);

                        await this.renderFrameAt(frameIndex, exportCanvas);

                        const videoFrame = new VideoFrame(exportCanvas, {
                            timestamp: (i * 1_000_000) / this.fps
                        });
                        encoder.encode(videoFrame, { keyFrame: i % 30 === 0 });
                        videoFrame.close();

                        // Update progress dialog
                        if (i % 5 === 0) {
                            const prog = i / totalFrames;
                            totalProgBar.style.width = (prog * 100) + "%";
                            frameProgBar.style.width = "0%";
                            stageText.innerText = "Exporting Phase";
                            statusText.innerText = `Frame ${i + 1}/${totalFrames}`;
                            previewCtx.drawImage(exportCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
                            // Also update editor button text just in case
                            exportBtn.textContent = `Exporting... ${Math.round(prog * 100)}%`;
                            await encoder.flush();
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                    }

                    if (!requestCancel) {
                        await encoder.flush();
                        encoder.close();
                        await webmWriter.complete();
                        await fileStream.close();
                        alert('Video export complete!');
                    } else {
                        encoder.close();
                        await fileStream.close();
                    }
                } catch (err) {
                    alert('Export error: ' + err.message);
                    encoder.close();
                    await fileStream.close();
                } finally {
                    exportBtn.textContent = originalText;
                    progressDialog.close();
                    this.dialog.showModal();
                }
            }
        }

        // Create global video editor instance
        let videoEditor = null;

        function checkVideoAPIs() {
            const missing = [];
            if (typeof VideoEncoder === 'undefined') missing.push('VideoEncoder');
            if (typeof VideoFrame === 'undefined') missing.push('VideoFrame');
            if (typeof window.showSaveFilePicker === 'undefined') missing.push('window.showSaveFilePicker');

            if (missing.length > 0) {
                alert(`Your browser does not support the following APIs required for the video editor:\n${missing.join('\n')}\n\nPlease use a modern browser (e.g., Chrome, Edge, Opera) with these features enabled.`);
                return false;
            }
            return true;
        }

        // Replace makeVideo button handler
        document.getElementById("makeVideo").addEventListener('click', () => {
            // alert("Broken");
            // return;
            if (!checkVideoAPIs()) return;

            if (!videoEditor) {
                videoEditor = new VideoEditor();
            }
            videoEditor.open();
        });

        document.getElementById("video-config-cancel").onclick = () => {
            document.getElementById("video-config-dialog").close();
        };

        document.getElementById("video-config-start").onclick = async () => {
            const configDialog = document.getElementById("video-config-dialog");
            const progressDialog = document.getElementById("video-progress-dialog");
            const vidWidth = parseInt(document.getElementById("video-width").value);
            const vidHeight = parseInt(document.getElementById("video-height").value);
            const vidFps = parseInt(document.getElementById("video-fps").value);

            configDialog.close();
            progressDialog.showModal();

            const previewCanvas = document.getElementById("video-preview-canvas");
            const previewCtx = previewCanvas.getContext('2d');
            const totalProgBar = document.getElementById("video-total-progress");
            const frameProgBar = document.getElementById("video-frame-progress");
            const stageText = document.getElementById("video-stage");
            const statusText = document.getElementById("video-status");
            const cancelBtn = document.getElementById("video-cancel");

            // Create offscreen mandelbrot
            const offCanvas = document.createElement("canvas");
            const offMandel = new Mandelbrot(offCanvas, mandelbrot.center.copy(), mandelbrot.iterations, Math.sqrt(mandelbrot.bailout), true);
            offMandel.resizeCanvas(false, vidWidth, vidHeight);
            offMandel.size = mandelbrot.size.copy();
            offMandel.smooth = mandelbrot.smooth;
            offMandel.refValid = false;

            previewCanvas.width = vidWidth;
            previewCanvas.height = vidHeight;

            let requestCancel = false;
            cancelBtn.onclick = () => {
                requestCancel = true;
                offMandel.requestForCancel = true;
                statusText.innerText = "Cancelling...";
            };

            const updateUI = (total, frame, stage, status) => {
                totalProgBar.style.width = (total * 100) + "%";
                frameProgBar.style.width = (frame * 100) + "%";
                if (stage) stageText.innerText = stage;
                if (status) statusText.innerText = status;

                // Live preview
                previewCtx.drawImage(offCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
            };

            // File System Access API - ask user where to save (MUST be in user gesture context)
            let fileHandle;
            try {
                fileHandle = await window.showSaveFilePicker({
                    suggestedName: `mandelbrot-zoom-${Date.now()}.webm`,
                    types: [{
                        description: 'WebM Video',
                        accept: { 'video/webm': ['.webm'] }
                    }]
                });
            } catch (e) {
                if (e.name === 'AbortError') {
                    console.log('User cancelled file save');
                    progressDialog.close();
                    return;
                }
                alert('Error selecting file: ' + e.message);
                progressDialog.close();
                return;
            }

            try {
                const maxOctaves = Math.ceil(Math.log2(32 / offMandel.size.doubleValue()));
                const keyFrames = await offMandel.renderFrames((frameIdx, frameProg, status) => {
                    const totalProg = Math.min(0.99, (frameIdx - 1 + frameProg) / maxOctaves);
                    updateUI(totalProg, frameProg, "Collection Phase", status);
                });

                if (requestCancel || !keyFrames || keyFrames.length < 2) {
                    progressDialog.close();
                    return;
                }

                const fileWritableStream = await fileHandle.createWritable();

                // WebMWriter setup
                let webmWriter;
                let encoder;

                try {
                    webmWriter = new WebMWriter({
                        fileWriter: fileWritableStream,
                        codec: 'VP9',
                        width: vidWidth,
                        height: vidHeight,
                        frameRate: vidFps
                    });

                    encoder = new VideoEncoder({
                        output: chunk => webmWriter.addFrame(chunk),
                        error: (e) => {
                            console.error('VideoEncoder error:', e);
                            throw e;
                        }
                    });

                    encoder.configure({
                        codec: 'vp09.00.10.08', // VP9, Profile 0, Level 1.0, 8-bit
                        width: vidWidth,
                        height: vidHeight,
                        bitrate: 12_000_000,
                        framerate: vidFps,
                        latencyMode: 'quality'
                    });
                } catch (e) {
                    await fileWritableStream.close();
                    throw new Error('WebCodecs/Writer error: ' + e.message);
                }

                updateUI(1, 0, "Encoding Phase", "Rendering frames...");

                const secondsPerOctave = 1.0;
                const totalDuration = (keyFrames.length - 1) * secondsPerOctave;
                const totalFrames = Math.ceil(totalDuration * vidFps);
                const offCtx = offCanvas.getContext('2d');

                // Render and encode each frame synchronously
                for (let frameIndex = 0; frameIndex < totalFrames; frameIndex++) {
                    if (requestCancel) break;

                    const timestamp = (frameIndex * 1_000_000) / vidFps; // microseconds
                    const elapsedSeconds = frameIndex / vidFps;
                    const indexFl = elapsedSeconds / secondsPerOctave;

                    let i = Math.floor(indexFl);
                    if (i >= keyFrames.length - 1) break;

                    const progress = frameIndex / totalFrames;
                    const currFrameProg = indexFl - i;
                    updateUI(progress, currFrameProg, "Encoding Phase", `Frame ${frameIndex + 1}/${totalFrames}`);

                    const currFrame = keyFrames[i];
                    const nextFrame = keyFrames[i + 1];
                    const scale1 = Math.pow(2, currFrameProg);
                    const scale2 = scale1 * 0.5;

                    const w = offCanvas.width, h = offCanvas.height, cx = w / 2, cy = h / 2;
                    offCtx.save();
                    offCtx.clearRect(0, 0, w, h);
                    offCtx.imageSmoothingEnabled = true;
                    offCtx.drawImage(currFrame.frame, cx - (w * scale1) / 2, cy - (h * scale1) / 2, w * scale1, h * scale1);
                    offCtx.globalAlpha = Math.max(0, Math.min(1, (currFrameProg - 0.1) / 0.8));
                    offCtx.drawImage(nextFrame.frame, cx - (w * scale2) / 2, cy - (h * scale2) / 2, w * scale2, h * scale2);
                    offCtx.globalAlpha = 1.0;

                    // UI Overlay
                    offCtx.font = `bold ${Math.round(w / 40)}px Arial`;
                    offCtx.fillStyle = 'white'; offCtx.strokeStyle = 'black'; offCtx.lineWidth = 1;
                    const scaleBase = FloatExp.FOUR.div(currFrame.scale);
                    const currScale = FloatExp.fromLog2(scaleBase.log2Value() + currFrameProg);
                    const zoomText = `Zoom: ${currScale.exp < 7 ? currScale.doubleValue().toFixed(2) : currScale.base.toFixed(2) + 'E' + currScale.exp}`;
                    offCtx.strokeText(zoomText, w * 0.05, h * 0.05);
                    offCtx.fillText(zoomText, w * 0.05, h * 0.05);
                    offCtx.restore();

                    // Create VideoFrame and encode
                    const videoFrame = new VideoFrame(offCanvas, { timestamp });
                    const keyFrame = frameIndex % 30 === 0;
                    encoder.encode(videoFrame, { keyFrame });
                    videoFrame.close();

                    // Small delay to keep UI responsive
                    if (frameIndex % 10 === 0) {
                        await encoder.flush();
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }

                if (!requestCancel) {
                    updateUI(1, 1, "Finalizing", "Flushing encoder...");
                    await encoder.flush();
                    encoder.close();

                    updateUI(1, 1, "Finalizing", "Finalizing WebM...");
                    await webmWriter.complete();
                    await fileWritableStream.close();
                } else {
                    encoder.close();
                    await fileWritableStream.close();
                }
            } catch (err) {
                console.error("Video error:", err);
                alert("Video error: " + err.message);
            } finally {
                progressDialog.close();
            }
        };

        function generateRandomPalette(size) {
            const palette = [];
            for (let i = 0; i < size; i++) {
                palette.push([
                    Math.floor(Math.random() * 256),
                    Math.floor(Math.random() * 256),
                    Math.floor(Math.random() * 256)
                ]);
            }
            return palette;
        }

        function hsvToRgb(h, s, v) {
            let r, g, b;
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v, g = t, b = p; break;
                case 1: r = q, g = v, b = p; break;
                case 2: r = p, g = v, b = t; break;
                case 3: r = p, g = q, b = v; break;
                case 4: r = t, g = p, b = v; break;
                case 5: r = v, g = p, b = q; break;
            }
            return [Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)];
        }

        function generateRandomBWPalette(size) {
            const palette = [];
            for (let i = 0; i < size; i++) {
                const phase = i % 4;
                let h, s, v;
                switch (phase) {
                    case 0:
                        // Phase 0: full color: 
                        h = Math.random();
                        s = Math.random() * 0.5 + 0.5;
                        v = Math.random() * 0.25 + 0.75;
                        break;
                    case 1:
                        // Phase 1: darker color
                        h = Math.random();
                        s = Math.random() * 0.5 + 0.5;
                        v = Math.random() * 0.25;
                        break;
                    case 2:
                        // Phase 2: full color
                        h = Math.random();
                        s = Math.random() * 0.5 + 0.5;
                        v = Math.random() * 0.25 + 0.75;
                        break;
                    case 3:
                        // Phase 3: lighter color
                        h = Math.random();
                        s = Math.random() * 0.25;
                        v = Math.random() * 0.25 + 0.75;
                }
                palette.push(hsvToRgb(h, s, v));
            }
            return palette;
        }

        function generateWanderingHueBWPalette(size) {
            const palette = [];
            let currentHue = Math.random();
            let targetHue = Math.random();
            const period = 32;

            for (let i = 0; i < size; i++) {
                if (i % period === 0) targetHue = Math.random();
                let diff = targetHue - currentHue;
                if (diff > 0.5) diff -= 1;
                if (diff < -0.5) diff += 1;
                currentHue = (currentHue + diff / period + 1) % 1;

                const phase = i % 4;
                let s, v;
                switch (phase) {
                    case 0: s = Math.random() * 0.4 + 0.6; v = Math.random() * 0.2 + 0.8; break;
                    case 1: s = Math.random() * 0.4 + 0.6; v = Math.random() * 0.2 + 0.1; break;
                    case 2: s = Math.random() * 0.4 + 0.6; v = Math.random() * 0.2 + 0.8; break;
                    case 3: s = Math.random() * 0.2; v = Math.random() * 0.2 + 0.8; break;
                }
                palette.push(hsvToRgb(currentHue, s, v));
            }
            return palette;
        }

        function generateGoldenRatioPalette(size) {
            const palette = [];
            let h = Math.random();
            const goldenRatioConjugate = 0.618033988749895;
            for (let i = 0; i < size; i++) {
                h = (h + goldenRatioConjugate) % 1;
                const phase = i % 4;
                let s, v;
                switch (phase) {
                    case 0: s = 0.8; v = 0.95; break;
                    case 1: s = 0.9; v = 0.2; break;
                    case 2: s = 0.8; v = 0.95; break;
                    case 3: s = 0.2; v = 0.95; break;
                }
                palette.push(hsvToRgb(h, s, v));
            }
            return palette;
        }

        function generateTealOrangePalette(size) {
            const palette = [];
            for (let i = 0; i < size; i++) {
                const isTeal = Math.random() > 0.5;
                let h = isTeal ? 0.48 + Math.random() * 0.1 : 0.05 + Math.random() * 0.08;
                const s = 0.5 + Math.random() * 0.5;
                const v = i % 2 === 0 ? 0.8 + Math.random() * 0.2 : 0.1 + Math.random() * 0.2;
                palette.push(hsvToRgb(h, s, v));
            }
            return palette;
        }

        function generateOrganicSinePalette(size) {
            const palette = [];
            const offsetH = Math.random();
            for (let i = 0; i < size; i++) {
                const h = (offsetH + Math.sin(i * 0.1) * 0.2 + Math.sin(i * 0.031) * 0.5 + 1) % 1;
                const s = 0.6 + Math.sin(i * 0.07) * 0.3;
                const v = 0.5 + Math.sin(i * 0.05) * 0.4;
                palette.push(hsvToRgb(h, Math.abs(s), Math.abs(v)));
            }
            return palette;
        }

        class PaletteEditor {
            constructor() {
                this.dialog = document.getElementById('palette-dialog');
                this.colorList = document.getElementById('color-list');
                this.applyButton = document.getElementById('apply-colors');
                this.randomButton = document.getElementById('random-colors');
                this.resetButton = document.getElementById('reset-colors');
                this.closeButton = document.getElementById('close-dialog');
                this.colorStepInput = document.getElementById('color-step');
                this.init();
            }

            init() {
                this.applyButton.addEventListener('click', () => {
                    this.applyColors();
                });

                this.randomButton.addEventListener('click', () => {
                    const algorithm = this.getAlgorithm();
                    switch (algorithm) {
                        case 'random':
                            palette = generateRandomPalette(palette.length); // Generate a random palette with the same length
                            break;
                        case 'random-bw':
                            palette = generateRandomBWPalette(palette.length); // Generate a random black and white palette
                            break;
                        case 'wandering':
                            palette = generateWanderingHueBWPalette(palette.length);
                            break;
                        case 'golden':
                            palette = generateGoldenRatioPalette(palette.length);
                            break;
                        case 'teal-orange':
                            palette = generateTealOrangePalette(palette.length);
                            break;
                        case 'organic-sine':
                            palette = generateOrganicSinePalette(palette.length);
                            break;

                    }
                    // palette = generateRandomPalette(palette.length); // Generate a random palette with 10 colors
                    this.renderColors();
                });

                this.resetButton.addEventListener('click', () => {
                    palette = defaultPalette; // Reset to the default palette
                    this.renderColors();
                });

                this.closeButton.addEventListener('click', () => {
                    this.dialog.close();
                });

                this.colorStepInput.addEventListener('input', (e) => {
                    colorStep = parseFloat(e.target.value);
                });

                this.renderColors();
            }

            renderColors() {
                this.colorList.innerHTML = ''; // Clear existing colors
                palette.forEach((color, index) => {
                    const li = document.createElement('li');
                    li.classList.add('color-item');
                    const label = document.createElement('label');
                    label.textContent = `${index + 1} `;
                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.value = `#${color.map(c => c.toString(16).padStart(2, '0')).join('')}`;
                    colorInput.dataset.index = index;
                    const removeColorButton = document.createElement('button');
                    removeColorButton.classList.add('icon');
                    removeColorButton.dataset.index = index;
                    removeColorButton.textContent = '-';
                    removeColorButton.addEventListener('click', (e) => {
                        const index = e.target.dataset.index;
                        palette.splice(index, 1); // Remove color from palette
                        this.renderColors(); // Re-render colors
                    });
                    const addColorButton = document.createElement('button');
                    addColorButton.className = 'icon';
                    addColorButton.textContent = '+';
                    addColorButton.dataset.index = index;
                    addColorButton.addEventListener('click', () => {
                        // Add a new black color after the current color
                        palette.splice(index + 1, 0, [0, 0, 0]); // Add black color
                        this.renderColors(); // Re-render colors
                    });
                    li.appendChild(label);
                    li.appendChild(colorInput);
                    li.appendChild(removeColorButton);
                    li.appendChild(addColorButton);
                    this.colorList.appendChild(li);
                });

                this.colorStepInput.value = colorStep; // Set the color step input value
            }

            getAlgorithm() {
                return document.getElementById('algorithm-select').value;
            }

            applyColors() {
                const inputs = this.colorList.querySelectorAll('input[type="color"]');
                palette = Array.from(inputs).map(input => {
                    const color = input.value.slice(1); // Remove the '#' character
                    return [
                        parseInt(color.slice(0, 2), 16),
                        parseInt(color.slice(2, 4), 16),
                        parseInt(color.slice(4, 6), 16)
                    ];
                });
                this.dialog.close();
                mandelbrot.recolorize(); // Recolorize the Mandelbrot set with new colors
                if (window.videoEditor) videoEditor.recolorize();
            }

            show() {
                this.dialog.showModal();
                this.renderColors();
            }
        }

        const paletteEditor = new PaletteEditor();
        document.getElementById('palette').addEventListener('click', () => {
            paletteEditor.show();
        });

        document.getElementById('iteration-button').addEventListener('click', () => {
            const iterDialog = document.getElementById('iteration-dialog');
            const bailoutInput = document.getElementById('bailout');
            const smoothCheckbox = document.getElementById('smooth');

            bailoutInput.value = Math.sqrt(mandelbrot.bailout);
            smoothCheckbox.checked = mandelbrot.smooth;

            iterDialog.showModal();

            document.getElementById('apply-iter').addEventListener('click', () => {
                mandelbrot.bailout = parseFloat(bailoutInput.value) ** 2;
                mandelbrot.smooth = smoothCheckbox.checked;
                iterDialog.close();
                mandelbrot.clear();
                mandelbrot.update();
            });

            document.getElementById('close-iter-dialog').addEventListener('click', () => {
                iterDialog.close();
            });
        });

        async function acquireWakelock() {
            if ('wakeLock' in navigator) {
                try {
                    const lock = await navigator.wakeLock.request('screen');
                    lock.addEventListener('release', e => {
                        console.log("wakelock released");
                    })
                    return lock;
                } catch (error) {
                    console.error(error);
                }
            }
        }
    </script>
</body>

</html>