<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0"> -->
    <title>Mandelbrot Perturbation</title>
    <style>
        :root {
            --theme-color: #ff4081;
            /* Define a theme color */
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #1a1a1a;
            /* Dark background color */
            color: #fff;
            /* Light text color */
            font-family: Arial, sans-serif;
        }

        .container {
            display: flex;
            margin: auto;
        }

        .location {
            display: flex;
            flex-direction: column;
            margin-left: 8px;
        }

        #mandelbrot {
            background: repeating-linear-gradient(45deg, var(--theme-color), var(--theme-color) 8px, #000 8px, #000 16px);
            /* Adjust colors for dark mode */
            cursor: crosshair;
        }

        button {
            margin-top: 8px;
            background-color: #333;
            /* Dark button background color */
            color: #fff;
            /* Light text color for buttons */
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: var(--theme-color);
            /* Change background color on hover */
        }

        button:focus {
            outline: none;
            /* Remove default focus outline */
            box-shadow: 0 0 3px var(--theme-color);
            /* Add custom focus effect */
        }

        textarea {
            background-color: #333;
            /* Dark textarea background color */
            color: #fff;
            /* Light text color for textarea */
            border: 1px solid #666;
            /* Dark border color */
            padding: 4px;
            resize: vertical;
            /* Allow vertical resizing */
            transition: background-color 0.3s;
        }

        textarea:hover,
        textarea:focus {
            background-color: #444;
            border-color: var(--theme-color);
            outline: none;
            /* Change background color on hover/focus */
        }

        textarea.large{
            height: 100px;
        }
    </style>
</head>

<body>
    <div class="container">

        <canvas width="800" height="800" id="mandelbrot"></canvas>

        <div class="location">
            Real:
            <textarea id="re" class="large"></textarea><br>
            Imag:
            <textarea id="im" class="large"></textarea><br>
            Zoom:
            <textarea id="zoom"></textarea><br>
            Iterations:
            <textarea id="it"></textarea>
            <button id="goto">Go</button>
            <button id="home">Home</button>
            <button id="download">Download</button>
        </div>
    </div>
    <div id="stats">
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/decimal.js/10.4.3/decimal.min.js"></script>
    <script>
        const canvas = document.getElementById('mandelbrot');
        const reInput = document.getElementById('re')
        const imInput = document.getElementById('im');
        const zoomInput = document.getElementById('zoom')
        const itInput = document.getElementById('it')
        const statsLabel = document.getElementById('stats')

        class Complex {
            constructor(re, im) {
                this.re = re;
                this.im = im;
            }

            abs() {
                return Math.sqrt(this.re ** 2 + this.im ** 2);
            }

            toNumberArray() {
                return [this.re, this.im];
            }

            mul(other) {
                if (typeof other === 'number') {
                    return new Complex(this.re * other, this.im * other);
                } else {
                    return new Complex(
                        this.re * other.re - this.im * other.im,
                        this.re * other.im + this.im * other.re
                    );
                }
            }

            add(other) {
                return new Complex(this.re + other.re, this.im + other.im);
            }

            sub(other) {
                return new Complex(this.re - other.re, this.im - other.im);
            }
        }


        class DeepComplex {
            constructor(re, im) {
                this.re = re instanceof Decimal ? re : new Decimal(re);
                this.im = im instanceof Decimal ? im : new Decimal(im);
            }

            abs() {
                return this.re.pow(2).plus(this.im.pow(2)).sqrt();
            }

            mul(other) {
                if (other instanceof DeepComplex) {
                    const realPart = this.re.times(other.re).minus(this.im.times(other.im));
                    const imagPart = this.re.times(other.im).plus(this.im.times(other.re));
                    return new DeepComplex(realPart, imagPart);
                }
                else if (other instanceof Complex) {
                    const realPart = this.re.times(other.re).minus(this.im.times(other.im));
                    const imagPart = this.re.times(other.im).plus(this.im.times(other.re));
                    return new DeepComplex(realPart, imagPart);
                } else if (typeof other === 'number') {
                    return new DeepComplex(this.re.times(other), this.im.times(other));
                } else {
                    throw new Error('Invalid type for multiplication');
                }
            }

            add(other) {
                return new DeepComplex(this.re.plus(other.re), this.im.plus(other.im));
            }

            sub(other) {
                return new DeepComplex(this.re.minus(other.re), this.im.minus(other.im));
            }

            downCast() {
                return new Complex(this.re.toNumber(), this.im.toNumber())
            }
        }

        function getReferenceOrbit(c, iterations, bailout = 2) {
            const z = new DeepComplex(0, 0);
            const orbit = [];
            for (let i = 0; i < iterations; i++) {
                if (i % 10000 == 0) console.log(i)
                iterate(z, c);
                if (z.abs() > 1073741824) {
                    console.warn(`${c} is not a valid reference point!`)
                    break
                };
                orbit.push(z.downCast());
            }
            return orbit;
        }

        function getSeriesCoefficients(z, c, iterations, bailout = 2) {
            const coefficients = [
                new Complex(1, 0),
                new Complex(0, 0),
                new Complex(0, 0),
                new Complex(0, 0),
            ];
            for (let i = 0; i < iterations; i++) {
                iterate(z, c);
                if (z.abs() > bailout) console.warn(`${c} is not a valid reference point!`);
                const [A, B, C, D] = coefficients;
                coefficients[0] = A.mul(z.mul(2)).add(new Complex(1, 0));
                coefficients[1] = B.mul(z.mul(2)).add(A.mul(A));
                coefficients[2] = C.mul(z.mul(2)).add(B.mul(A.mul(2)));
                coefficients[3] = D.mul(z.mul(2)).add(C.mul(A.mul(2))).add(B.mul(B));
            }
            return coefficients.flatMap((x) => x.toNumberArray());
        }

        function iterate(z, c) {
            const x = z.mul(z).add(c);
            z.re = x.re;
            z.im = x.im;
        }

        function pt(delta, ref, bailout) {
            let pertR=delta.re;
            let pertI=delta.im;
            let tmp;
            //let pert = delta;
            for (let n = 0; n < ref.length; n++) {
                const Z=ref[n]
                const valR=Z.re+pertR;
                const valI=Z.im+pertI;
                const val=Math.sqrt(valR*valR+valI*valI);
                //const val = ref[n].add(pert).abs();
               // if (val < ref[n].abs() * 1e-4) return -1;
               if (val<Z.abs()*1e-4) return -1;
                else if (val > bailout) return n;

                tmp=2*(Z.re*pertR-Z.im*pertI)+(pertR*pertR-pertI*pertI)+delta.re
                pertI=2*(Z.re*pertI+Z.im*pertR)+2*pertR*pertI+delta.im
                pertR=tmp

               // pert = ref[n].mul(pert).mul(2).add(pert.mul(pert)).add(delta);
            }
            return null;
        }

        function generateRainbowPalette(numColors) {
            const rainbowColors = [];
            const frequency = 0.2; // Adjust the frequency to change the spread of colors

            for (let i = 0; i < numColors; i++) {
                const red = Math.sin(frequency * i) * 127 + 128;
                const green = Math.sin(frequency * 1.1 * i) * 127 + 128;
                const blue = Math.sin(frequency * 1.2 * i) * 127 + 128;
                rainbowColors.push([red | 0, green | 0, blue | 0, 255]);
            }

            return rainbowColors;
        }

        const palette = generateRainbowPalette(1024);

        function getColor(it) {
            if (it == null) return [0, 0, 0, 255];
            else if (it < 0) return [0, 0, 0, 0];
            return palette[it % 1024];
        }

        class Mandelbrot {
            center;
            iterations;
            bailout;
            size;

            canvas;
            context;

            ref;
            rebase;

            stats;

            constructor(canvas, center, iterations, bailout) {
                this.center = center;
                this.iterations = iterations;
                this.bailout = bailout;

                this.size = 4;

                this.canvas = canvas;
                this.context = canvas.getContext('2d');

                canvas.addEventListener('mousedown', e => {
                    e.preventDefault();
                    if (e.button === 0) {
                        // Left click: decrease size
                        console.log(this.getDelta(e.offsetX, e.offsetY));
                        this.goto(this.center.add(this.getDelta(e.offsetX, e.offsetY)));
                        this.zoom(this.size / 4)
                        this.update();
                    } else if (e.button === 2) {
                        // Right click: increase size
                        this.zoom(this.size * 4);
                        this.update();
                    }
                });

                this.stats = {
                    ref: 0,
                    pt: 0,
                    guess: 0
                }
            }

            zoom(size) {
                console.log(Decimal.config({ precision: parseInt(-Math.log10(size)) + 10 }))
                this.size = size;
            }

            goto(c) {
                this.center = c;
            }

            setIterations(it) {
                this.iterations = it;
            }

            home() {
                this.goto(new DeepComplex(new Decimal(0), new Decimal(0)))
                this.size = 4;
            }

            getDelta(x, y, baseX, baseY) {
                if (!baseX) baseX = this.canvas.width / 2;
                if (!baseY) baseY = this.canvas.height / 2;
                return new Complex(
                    (x - baseX) / this.canvas.width * this.size,
                    (baseY - y) / this.canvas.height * this.size
                )
            }

            _rebase(xy) {
                this.rebase = xy;
            }

            getColor(x, y, img) {
                const index = (y * this.canvas.width + x) * 4;
                return [img.data[index], img.data[index + 1], img.data[index + 2], img.data[index + 3]]
            }

            setColor(x, y, img, color) {
                const index = (y * this.canvas.width + x) * 4;
                img.data[index] = color[0]
                img.data[index + 1] = color[1]
                img.data[index + 2] = color[2]
                img.data[index + 3] = color[3]
            }

            update(rebase = false) {
                if (!rebase) {
                    this.stats = {
                        ref: 0,
                        pt: 0,
                        guess: 0
                    }
                }

                reInput.value = this.center.re;
                imInput.value = this.center.im;
                zoomInput.value = (4 / this.size).toExponential(3)
                itInput.value = this.iterations;

                const img = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
                console.log(performance.now() + " computing reference")
                const base = rebase ? this.center.add(this.getDelta(this.rebase[0], this.rebase[1])) : this.center;
                const ref = getReferenceOrbit(base, this.iterations, this.bailout);
                this.stats.ref++;
                console.log("ref it: " + ref.length)
                if (!rebase) this.ref = ref;

                console.log(performance.now() + " perturbation")

                const glitches = [];


                for (let y = 0; y < this.canvas.height; y += 2) {
                    for (let x = 0; x < this.canvas.width; x += 2) {
                        if (!rebase || (rebase && this.getColor(x, y, img)[3] == 0)) {
                            const delta = rebase ? this.getDelta(x, y, this.rebase[0], this.rebase[1]) : this.getDelta(x, y);
                            const newIter = pt(delta, ref, this.bailout);

                            if (newIter < 0) glitches.push([x, y])
                            else this.stats.pt++;

                            const color = getColor(newIter)

                            this.setColor(x, y, img, color);
                        }
                    }
                }


                for (let y = 0; y < this.canvas.height; y += 2) {
                    for (let x = 1; x < this.canvas.width; x += 2) {
                        if (!rebase || (rebase && this.getColor(x, y, img)[3] == 0)) {
                            let leftColor = this.getColor(x - 1, y, img);
                            let rightColor = this.getColor(x + 1, y, img);
                            if (leftColor[0] == rightColor[0] && leftColor[1] == rightColor[1] && leftColor[2] == rightColor[2] && leftColor[3] == 255 && rightColor[3] == 255) {
                                this.setColor(x, y, img, leftColor);
                                this.stats.guess++;
                            } else {
                                const delta = rebase ? this.getDelta(x, y, this.rebase[0], this.rebase[1]) : this.getDelta(x, y);
                                const newIter = pt(delta, ref, this.bailout);

                                if (newIter < 0) glitches.push([x, y])
                                else this.stats.pt++;

                                const color = getColor(newIter)

                                this.setColor(x, y, img, color);
                            }
                        }
                    }
                }

                for (let y = 1; y < this.canvas.height; y += 2) {
                    for (let x = 0; x < this.canvas.width; x++) {
                        if (!rebase || (rebase && this.getColor(x, y, img)[3] == 0)) {
                            let upColor = this.getColor(x, y - 1, img);
                            let downColor = this.getColor(x, y + 1, img);
                            if (upColor[0] == downColor[0] && upColor[1] == downColor[1] && upColor[2] == downColor[2] && upColor[3] == 255 && downColor[3] == 255) {
                                this.setColor(x, y, img, upColor);
                                this.stats.guess++;
                            } else {
                                const delta = rebase ? this.getDelta(x, y, this.rebase[0], this.rebase[1]) : this.getDelta(x, y);
                                const newIter = pt(delta, ref, this.bailout);

                                if (newIter < 0) glitches.push([x, y])
                                else this.stats.pt++;

                                const color = getColor(newIter)

                                this.setColor(x, y, img, color);
                            }
                        }
                    }
                }

                this.context.putImageData(img, 0, 0)

                if (glitches.length > 4) {
                    let i = parseInt(glitches.length / 8);
                    this._rebase(glitches[i])

                    setTimeout(() => {
                        this.update(true)
                    }, 50)
                } else {
                    console.log('done!')
                }
                statsLabel.innerText = `Reference: ${this.stats.ref}\nPerturbation: ${this.stats.pt}\nGuessed: ${this.stats.guess}`
            }

            download() {
                const downloadLink = document.createElement('a');

                downloadLink.href = canvas.toDataURL('image/png');
                downloadLink.download = 'mandelbrot.png';

                downloadLink.click();
            }
        }

        let c = new DeepComplex(
            new Decimal(0), new Decimal(0));

        let size = 4;
        let bailout = 2;
        let iterations = 256;


        const mandelbrot = new Mandelbrot(canvas, c, iterations, bailout)
        mandelbrot.zoom(size)
        mandelbrot.update()


        document.getElementById('goto').addEventListener('click', e => {
            mandelbrot.goto(new DeepComplex(
                new Decimal(reInput.value),
                new Decimal(imInput.value)
            ))

            mandelbrot.zoom(4 / parseFloat(zoomInput.value));
            mandelbrot.setIterations(parseInt(itInput.value));

            mandelbrot.update();
        })

        document.getElementById('home').addEventListener('click', e => {
            mandelbrot.home()
            mandelbrot.setIterations(iterations);
            mandelbrot.update()
        })

        document.getElementById('download').addEventListener('click', e => {
            mandelbrot.download()
        })
    </script>
</body>

</html>