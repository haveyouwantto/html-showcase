<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="description" content="Infinite deep and fast Mandelbrot set explorer">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mandelbrot Perturbation</title>
    <style>
        :root {
            --theme-color: #ff4081;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: hidden;
            /* Prevent scrollbars */
        }

        #mandelbrot {
            position: fixed;
            top: 0;
            left: 0;
            width: 100dvw;
            height: 100dvh;
            cursor: grab;
            background: repeating-linear-gradient(45deg, var(--theme-color), var(--theme-color) 8px, #000 8px, #000 16px);
            /* For smoother transforms */
            transform-origin: 0 0;
            will-change: transform;
        }

        #mandelbrot:active {
            cursor: grabbing;
        }

        .transition {
            transition: transform 0.1s ease-out;
        }

        #menu-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1002;
            font-size: 24px;
            width: 40px;
            height: 40px;
            background-color: rgba(51, 51, 51, 0.8);
            color: #fff;
            border: 1px solid #666;
            border-radius: 5px;
            cursor: pointer;
            line-height: 1;
        }

        #menu-toggle:hover {
            background-color: var(--theme-color);
        }

        #sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: 300px;
            height: 100dvh;
            background-color: #2a2a2a;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.5);
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
            z-index: 1001;
            overflow-y: auto;
            padding: 10px;
            box-sizing: border-box;
        }

        #sidebar.open {
            transform: translateX(0);
        }

        #info-overlay {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 5px;
            font-size: 0.9rem;
            z-index: 1000;
            max-width: 90vw;
            transition: 0.3s ease-in-out;
            margin-top: 10px;
        }

        #info-location {
            margin-bottom: 5px;
            word-break: break-all;
        }

        .info-overlay-collapsed {
            width: 40px !important;
            height: 40px !important;
            padding: 0 !important;
        }

        .info-overlay-collapsed::after {
            content: "‚ÑπÔ∏è";
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        .info-overlay-collapsed * {
            display: none !important;
        }

        .info-overlay-collapsed:hover {
            background-color: var(--theme-color) !important;
            cursor: pointer;
        }

        .progress-container {
            display: flex;
            z-index: 999;
            width: 100%;
            position: fixed;
            height: 4px;
        }

        .progress {
            background-color: white;
            width: 0;
            height: 100%;
        }

        .guessed-progress {
            background-color: rgba(255, 255, 255, 0.5);
        }

        /* Inherited styles for controls inside sidebar */
        .location {
            display: flex;
            flex-direction: column;
        }

        button {
            margin-top: 8px;
            background-color: #333;
            color: #fff;
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: var(--theme-color);
        }

        button:disabled {
            filter: brightness(0.5);
            cursor: not-allowed;
        }

        .icon {
            font-size: 30px;
            font-family: emoji;
            font-weight: bold;
            width: 35px;
            height: 35px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        textarea {
            background-color: #333;
            color: #fff;
            border: 1px solid #666;
            padding: 4px;
            resize: vertical;
            font-size: 0.8rem;
        }

        .shortcut {
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        .running {
            cursor: wait !important;
        }

        hr {
            width: 100%;
            border: 1px solid #444;
            /* Dark color for the horizontal rule */
            margin: 20px 0;
            /* Adjust margin as needed */
        }

        select {
            background-color: #333;
            /* Dark background color for select dropdown */
            color: #fff;
            /* Light text color for select options */
            padding: 8px;
            border: 1px solid #666;
            /* Dark border color */
            border-radius: 4px;
            appearance: none;
            /* Remove default appearance */
            transition: background-color 0.3s;
        }

        select:hover,
        select:focus {
            background-color: #444;
            /* Change background color on hover/focus */
        }

        .shortcut {
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        .running {
            outline: var(--theme-color) 4px solid;
            cursor: wait !important;
        }

        #color-list {
            list-style: none;
            outline: 1px solid var(--theme-color);
            padding: 8px;
            margin: 8px;
            flex-wrap: wrap;
            max-height: 75vh;
            overflow-y: auto;
        }

        dialog {
            width: 400px;
            padding: 20px;
            background-color: #222;
            color: #fff;
            border: none;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            max-width: 90%;
            max-height: 100dvh;
        }

        #palette-dialog h2 {
            margin-top: 0;
        }

        #palette-dialog::backdrop {
            background-color: rgba(0, 0, 0, 0.5);
            /* Semi-transparent backdrop */
        }

        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            padding: 0;
            margin: 0;
            cursor: pointer;
            appearance: none;
            background: none;
        }

        input[type="number"] {
            padding: 4px;
            border: 1px solid #666;
            background-color: #333;
            color: #fff;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
            width: 20px;
            height: 20px;
            accent-color: var(--theme-color);
        }

        .color-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }


        @media (max-width: 600px) {
            .container {
                flex-direction: column;
            }

            #mandelbrot {
                width: 100%;
                height: auto;
            }

            .location {
                margin-left: 0;
            }

            .shortcut {
                justify-content: space-evenly;
            }
        }
    </style>
</head>

<body>
    <canvas id="mandelbrot" width="800" height="800"></canvas>

    <div id="info-overlay" class="info-overlay-collapsed">
        <div id="info-location">
            <div>Re: <span id="info-re"></span></div>
            <div>Im: <span id="info-im"></span></div>
            <div>Zoom: <span id="info-zoom"></span></div>
            <div>Iterations: <span id="info-iter"></span></div>
        </div>
        <div id="stats"></div>
    </div>
    <div class="progress-container">
        <div id="progress" class="progress"></div>
        <div id="guessed-progress" class="progress guessed-progress"></div>
    </div>

    <button id="menu-toggle" title="Toggle Controls">&#9776;</button>

    <aside id="sidebar">
        <!-- ÊâÄÊúâÂéüÂßãÁöÑÊéß‰ª∂ÈÉΩÁßªÂä®Âà∞ËøôÈáå -->
        <div class="location">
            Real:
            <textarea id="re" class="large" rows="10"></textarea><br>
            Imaginary:
            <textarea id="im" class="large" rows="10"></textarea><br>
            Zoom:
            <textarea id="zoom" rows="2"></textarea><br>
            Iterations:
            <textarea id="it" rows="1"></textarea>
            <div class="shortcut">
                <button class="icon control-button" id="zoom-in" title="Zoom in">&#10133;</button>
                <button class="icon control-button" id="zoom-out" title="Zoom out">&#10134;</button>
                <button class="icon control-button" id="increase-iter" title="Iterations x2">&#128314;</button>
                <button class="icon control-button" id="decrease-iter" title="Iterations /2">&#128315;</button>
            </div>
            <div class="shortcut">
                <button class="icon control-button" id="goto" title="Go to location">&#128640;</button>
                <button class="icon control-button" id="home" title="Reset view">&#127968;</button>
                <button class="icon control-button" id="palette" title="Palette Editor">üé®</button>
                <button class="icon control-button" id="download" title="Download PNG">&#128248;</button>
            </div>
            <div class="shortcut">
                <button class="icon control-button" id="iteration-button" title="Iteration Settings">üîß</button>
                <button class="icon control-button" id="kfr" title="Load KFR file">üìÇ</button>
                <button class="icon control-button" id="save-kfr" title="Save KFR file">üíæ</button>
            </div>
            <button id="makeVideo" class="control-button">Make Video</button>
            <hr>
            Samples
            <select id="samples">
                <option value="seahorse">Seahorse</option>
                <option value="snowflake">Snowflake</option>
                <option value="spiral">Spiral</option>
                <option value="luxury">Luxury</option>
                <option value="horizon">Horizon</option>
                <option value="flora">Flora</option>
                <option value="classic">Classic</option>
                <option value="e200">E200</option>
                <option value="radiant">Radiant</option>
                <option value="branches">Branches</option>
            </select>
            <button id="load-sample" class="control-button">Load</button>
        </div>
        <div id="more"></div>
    </aside>

    <!-- Dialogs remain unchanged -->
    <dialog id="palette-dialog">
        <h2>Color Settings</h2>
        <label for="color-step">Color Step:</label>
        <input type="number" id="color-step" value="1" min="1" max="100" step="1"><br>
        <div id="random-group">
            <input type="radio" name="algorithm" id="random-1" value="random" checked>
            <label for="random-1">Algorithm 1</label>
            <input type="radio" name="algorithm" id="random-2" value="random-bw">
            <label for="random-2">Algorithm 2</label>
            <button id="random-colors">Random</button>
        </div>
        <ol id="color-list">
            <!-- Color settings -->
        </ol>
        <button id="apply-colors">Apply</button>
        <button id="reset-colors">Reset</button>
        <button id="close-dialog">Close</button>
    </dialog>
    <dialog id="iteration-dialog">
        <h2>Iteration Settings</h2>
        <label for="bailout">Bailout:</label>
        <input type="number" id="bailout" value="16" min="2" step="1"><br>
        <label for="smooth">Smooth:</label>
        <input type="checkbox" id="smooth" checked><br>
        <button id="apply-iter">Apply</button>
        <button id="close-iter-dialog">Close</button>
    </dialog>

    <script src="lib/decimal.9.0.0.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gmp-wasm"></script>
    <script>
        const canvas = document.getElementById('mandelbrot');
        const reInput = document.getElementById('re')
        const imInput = document.getElementById('im');
        const zoomInput = document.getElementById('zoom')
        const itInput = document.getElementById('it')
        const statsLabel = document.getElementById('stats')
        const progressBar = document.getElementById('progress');
        const guessedProgressBar = document.getElementById('guessed-progress');
        const sampleSelect = document.getElementById('samples')
        const sampleLoadBtn = document.getElementById('load-sample')
        const more = document.getElementById("more");


        const CPU_CORES = Math.max(navigator.hardwareConcurrency ?? 1, 1);

        class FloatExp {
            static expTable = [];
            static LOG2_10 = Math.log2(10);
            static LOG10_2 = Math.log10(2);
            static buffer = new ArrayBuffer(8); // Create an 8-byte buffer
            static floatView = new Float64Array(FloatExp.buffer); // Float64 view for the double
            static int32View = new Int32Array(FloatExp.buffer); // Int32 view to access 64 bits as two 32-bit chunks
            static {
                this.expTable = [];
                for (let i = 0; i < 324 + 308; i++) {
                    this.expTable[i] = Math.pow(10, i - 324);
                }
            }

            static getExp(exp) {
                if (exp < -324) return 0;
                else if (exp > 308) return Infinity;
                return this.expTable[exp + 324];
            }

            static getExpOfDouble(d) {
                if (d === 0) {
                    throw new Error("Exponent of zero is undefined.");
                }

                const LOG10_2 = Math.LOG10E; // log10(2)
                const BIAS = 1023; // Double-precision bias
                FloatExp.floatView[0] = d; // Store the double value

                const highBits = FloatExp.int32View[1]; // Get the higher 32 bits
                const lowBits = FloatExp.int32View[0]; // Get the lower 32 bits

                const rawExp = (highBits >>> 20) & 0x7FF; // Extract the exponent bits (11 bits)

                let actualExp;
                if (rawExp === 0) {
                    // Subnormal number
                    let mantissaHigh = highBits & 0xFFFFF; // Extract the top 20 bits of mantissa
                    const mantissaLow = lowBits; // Lower 32 bits of mantissa

                    // Combine mantissa into a single value for leading zero count
                    let leadingZeros = 0;
                    if (mantissaHigh === 0) {
                        leadingZeros += 32; // All high bits are zero, so count low bits
                        let temp = mantissaLow;
                        while (temp !== 0 && (temp & 0x80000000) === 0) {
                            temp <<= 1;
                            leadingZeros++;
                        }
                    } else {
                        let temp = mantissaHigh;
                        while ((temp & 0x80000) === 0) { // Adjust mask for 20 bits
                            temp <<= 1;
                            leadingZeros++;
                        }
                    }

                    actualExp = -1022 - leadingZeros;
                } else {
                    // Normalized number
                    actualExp = rawExp - BIAS;
                }

                // Convert base-2 exponent to base-10 exponent
                return Math.floor(actualExp * LOG10_2);
            }

            constructor(base, exp = 0) {
                if (isNaN(base) || isNaN(exp) || !isFinite(base) || !isFinite(exp)) {
                    throw new Error("Invalid FloatExp: " + JSON.stringify({ base, exp }));
                }
                this.base = base;
                this.exp = exp;
                this.norm();
            }

            norm() {
                if (this.base == 0) {
                    this.exp = 0;
                    return this;
                }
                if (this.base != 0 && (this.base > 10 || this.base < 1)) {
                    let exp = FloatExp.getExpOfDouble(this.base);
                    if (exp != 0) {
                        this.exp += exp;
                        this.base /= FloatExp.getExp(exp);
                    }
                }
                return this;
            }

            doubleValue() {
                return this.base * FloatExp.getExp(this.exp);
            }

            toString() {
                this.norm();
                return `${this.base}e${this.exp}`
            }

            add(other) {
                if (typeof other == 'number') return this.add(new FloatExp(other));
                if (other.base == 0) return this;
                else if (this.base == 0) return other;
                const expDiff = other.exp - this.exp;
                if (expDiff == 0)
                    return new FloatExp(this.base + other.base, this.exp)
                else if (expDiff > 16) return other;
                else {
                    return new FloatExp(this.base + other.base * FloatExp.getExp(other.exp - this.exp), this.exp)
                }
            }

            addMut(other) {
                if (other.base == 0) return this;
                else if (this.base == 0) {
                    this.base = other.base;
                    this.exp = other.exp;
                    return this;
                }
                const expDiff = other.exp - this.exp;
                if (expDiff == 0) {
                    this.base += other.base;
                    return this.norm();
                } else if (expDiff > 16) {
                    this.base = other.base;
                    this.exp = other.exp;
                    return this;
                } else {
                    this.base += other.base * FloatExp.getExp(expDiff);
                    return this.norm();
                }
            }

            sub(other) {
                if (typeof other == 'number') return this.sub(new FloatExp(other));
                if (other.base == 0) return this;
                else if (this.base == 0) return other.rev();
                const expDiff = other.exp - this.exp;
                if (expDiff == 0)
                    return new FloatExp(this.base - other.base, this.exp)
                else if (expDiff > 16) return other.rev();
                else {
                    return new FloatExp(this.base - other.base * FloatExp.getExp(other.exp - this.exp), this.exp)
                }
            }

            subMut(other) {
                if (other.base == 0) return this;
                else if (this.base == 0) {
                    this.base = -other.base;
                    this.exp = other.exp;
                    return this;
                }
                const expDiff = other.exp - this.exp;
                if (expDiff == 0) {
                    this.base -= other.base;
                    return this.norm();
                } else if (expDiff > 16) {
                    this.base = -other.base;
                    this.exp = other.exp;
                    return this;
                } else {
                    this.base -= other.base * FloatExp.getExp(expDiff);
                    return this.norm();
                }
            }


            mul(other) {
                if (other instanceof FloatExp)
                    return new FloatExp(this.base * other.base, this.exp + other.exp)
                else if (typeof other == 'number')
                    return new FloatExp(this.base * other, this.exp);
            }

            mulMut(other) {
                this.base *= other.base;
                this.exp += other.exp;
                return this.norm();
            }

            div(other) {
                if (other instanceof FloatExp)
                    return new FloatExp(this.base / other.base, this.exp - other.exp)
                else if (typeof other == 'number')
                    return new FloatExp(this.base / other, this.exp);
            }

            divMut(other) {
                this.base /= other.base;
                this.exp -= other.exp;
                return this.norm();
            }

            abs() {
                return new FloatExp(Math.abs(this.base), this.exp);
            }

            sqrt() {
                if (this.base < 0) throw new Error("Cannot take square root of negative number");
                return new FloatExp(Math.sqrt(this.base), this.exp / 2);
            }

            rev() {
                return new FloatExp(-this.base, this.exp);
            }

            copy() {
                return new FloatExp(this.base, this.exp);
            }

            square() {
                return new FloatExp(this.base * this.base, this.exp * 2);
            }

            squareMut() {
                this.base *= this.base;
                this.exp *= 2;
                return this.norm();
            }

            compareTo(o) {
                // 1. Compare sign
                if (this.base > 0 && o.base < 0) return 1;
                if (this.base < 0 && o.base > 0) return -1;

                // 2. Handle zero cases
                if (this.base === 0 && o.base === 0) return 0; // Both are zero
                if (this.base === 0) return o.base > 0 ? -1 : 1; // This is zero
                if (o.base === 0) return this.base > 0 ? 1 : -1; // Other is zero

                // 3. Compare exponents
                if (this.exp > o.exp) return this.base > 0 ? 1 : -1;
                if (this.exp < o.exp) return this.base > 0 ? -1 : 1;

                // 4. Compare bases when exponents are equal
                if (this.base > o.base) return 1;
                if (this.base < o.base) return -1;

                return 0; // Equal
            }

            log2Value() {
                const log2Mantissa = Math.log2(this.base);
                const log2Exponent = this.exp * FloatExp.LOG2_10;

                const log2Result = log2Mantissa + log2Exponent;

                return log2Result;
            }

            static fromLog2(val) {
                const log10 = val * FloatExp.LOG10_2;
                return new FloatExp(Math.pow(10, log10 - Math.trunc(log10)), Math.trunc(log10));
            }
        }

        function parseFloatExp(string) {
            var [b, e] = string.toLowerCase().split("e");
            e = parseInt(e)
            var fp = new FloatExp(parseFloat(b), (isNaN(e) ? 0 : e));
            // fp.norm();
            return fp;
        }

        function doubleToFloatExp(num) {
            if (num === 0) return new FloatExp(0, 0);
            // Get the exponent
            let exponent = Math.floor(Math.log10(Math.abs(num)));
            // Calculate the significand
            let scale = FloatExp.getExp(exponent);
            let significand = scale ? num / scale : 0;
            return new FloatExp(significand, exponent);
        }

        function decimalToFloatExp(num) {
            let base = num.d[0];
            for (let i = 1; i < 3; i++) {
                if (num.d[i]) base = base * 1e8 + num.d[i];
            }
            if (num.e == 0) return new FloatExp(base, 0);
            let off = Math.floor(Math.log10(base));
            let exp = num.e - off;
            return new FloatExp(base, exp);
        }

        function getFloatExp(obj) {
            if (obj instanceof FloatExp) return obj;
            else if (typeof obj === "number") {
                return doubleToFloatExp(obj);
            } else if (obj instanceof Decimal) {
                return decimalToFloatExp(obj);
            } else return parseFloatExp(obj.toString())
        }

        class Complex {
            absValue;
            constructor(re, im) {
                this.re = re;
                this.im = im;
            }

            abs() {
                if (!this.absValue) this.absValue = this.re ** 2 + this.im ** 2;
                return this.absValue
            }

            toNumberArray() {
                return [this.re, this.im];
            }

            mul(other) {
                if (typeof other === 'number') {
                    return new Complex(this.re * other, this.im * other);
                } else {
                    return new Complex(
                        this.re * other.re - this.im * other.im,
                        this.re * other.im + this.im * other.re
                    );
                }
            }

            mulMut(other) {
                if (typeof other === 'number') {
                    this.re *= other;
                    this.im *= other;
                    return this;
                } else {
                    let re = this.re;
                    let im = this.im;
                    this.re = re * other.re - im * other.im
                    this.im = re * other.im + im * other.re;
                    return this;
                }
            }

            add(other) {
                return new Complex(this.re + other.re, this.im + other.im);
            }

            addMut(other) {
                this.re += other.re;
                this.im += other.im;
                return this;
            }

            sub(other) {
                return new Complex(this.re - other.re, this.im - other.im);
            }

            subMut(other) {
                this.re -= other.re;
                this.im -= other.im;
                return this;
            }

            norm() {
                return Math.max(Math.abs(this.re), Math.abs(this.im));
            }

            div(other) {
                if (typeof other === 'number') {
                    return new Complex(this.re / other, this.im / other);
                } else {
                    const denominator = other.re ** 2 + other.im ** 2;
                    return new Complex(
                        (this.re * other.re + this.im * other.im) / denominator,
                        (this.im * other.re - this.re * other.im) / denominator
                    );
                }
            }

            toString() {
                return `(${this.re}, ${this.im})`;
            }
        }

        class DeepComplex {
            constructor(re, im) {
                this.re = re instanceof Decimal ? re : new Decimal(re);
                this.im = im instanceof Decimal ? im : new Decimal(im);
            }

            abs() {
                return this.re.pow(2).plus(this.im.pow(2));
            }

            mul(other) {
                if (other instanceof DeepComplex) {
                    const realPart = this.re.times(other.re).minus(this.im.times(other.im));
                    const imagPart = this.re.times(other.im).plus(this.im.times(other.re));
                    return new DeepComplex(realPart, imagPart);
                } else if (other instanceof Complex) {
                    const realPart = this.re.times(other.re).minus(this.im.times(other.im));
                    const imagPart = this.re.times(other.im).plus(this.im.times(other.re));
                    return new DeepComplex(realPart, imagPart);
                } else if (other instanceof FloatExpComplex) {
                    other = other.toDeepComplex();
                    const realPart = this.re.times(re).minus(this.im.times(im));
                    const imagPart = this.re.times(im).plus(this.im.times(re));
                    return new DeepComplex(realPart, imagPart);
                } else if (typeof other === 'number') {
                    return new DeepComplex(this.re.times(other), this.im.times(other));
                } else {
                    throw new Error('Invalid type for multiplication');
                }
            }

            add(other) {
                if (other instanceof FloatExpComplex) {
                    other = other.toDeepComplex();
                }
                return new DeepComplex(this.re.plus(other.re), this.im.plus(other.im));
            }

            sub(other) {
                if (other instanceof FloatExpComplex) {
                    other = other.toDeepComplex();
                }
                return new DeepComplex(this.re.minus(other.re), this.im.minus(other.im));
            }

            downCast() {
                return new Complex(this.re.toNumber(), this.im.toNumber())
            }

            toFloatExp() {
                return new FloatExpComplex(
                    getFloatExp(this.re.toString()),
                    getFloatExp(this.im.toString())
                )
            }

            square() {
                const realPart = this.re.times(this.re).minus(this.im.times(this.im)); // a^2 - b^2
                const imagPart = this.re.plus(this.re).times(this.im);     // 2ab
                return new DeepComplex(realPart, imagPart);
            }
        }

        class FloatExpComplex {
            constructor(re, im) {
                this.re = getFloatExp(re);
                this.im = getFloatExp(im);
            }

            abs() {
                return this.re.mul(this.re).addMut(this.im.mul(this.im));
            }

            mul(other) {
                if (typeof other === 'number') {
                    return new FloatExpComplex(this.re.mul(new FloatExp(other, 0)), this.im.mul(new FloatExp(other, 0)));
                } else
                    return new FloatExpComplex(
                        this.re.mul(other.re).subMut(this.im.mul(other.im)),
                        this.re.mul(other.im).addMut(this.im.mul(other.re))
                    )
            }

            div(other) {
                if (typeof other === 'number') {
                    return new FloatExpComplex(this.re.div(new FloatExp(other, 0)), this.im.div(new FloatExp(other, 0)));
                } else
                    return new FloatExpComplex(
                        this.re.div(other.re).subMut(this.im.div(other.im)),
                        this.re.div(other.im).addMut(this.im.div(other.re))
                    )
            }

            add(other) {
                return new FloatExpComplex(
                    this.re.add(other.re),
                    this.im.add(other.im)
                )
            }

            sub(other) {
                return new FloatExpComplex(
                    this.re.sub(other.re),
                    this.im.sub(other.im)
                )
            }

            addMut(other) {
                this.re.addMut(other.re);
                this.im.addMut(other.im);
                return this;
            }

            subMut(other) {
                this.re.subMut(other.re);
                this.im.subMut(other.im);
                return this;
            }

            mulMut(other) {
                const x = this.re;
                const y = this.im;
                this.re = x.mul(other.re).subMut(y.mul(other.im));
                this.im = x.mulMut(other.im).addMut(y.mulMut(other.re));
                return this;
            }

            copy() {
                return new FloatExpComplex(this.re.copy(), this.im.copy());
            }

            toComplex() {
                return new Complex(this.re.doubleValue(), this.im.doubleValue());
            }

            toDeepComplex() {
                return new DeepComplex(
                    new Decimal(this.re.toString()),
                    new Decimal(this.im.toString())
                )
            }

            norm() {
                return FEmax(this.re.abs(), this.im.abs());
            }

            square() {
                const realPart = this.re.square().subMut(this.im.square()); // a^2 - b^2
                const imagPart = this.re.mul(this.im).mulMut(new FloatExp(2));     // 2ab
                return new FloatExpComplex(realPart, imagPart);
            }
        }

        function FEmax(a, b) {
            if (a.compareTo(b) > 0) return a;
            else return b;
        }

        function FEmin(a, b) {
            if (a.compareTo(b) < 0) return a;
            else return b;
        }

        const samples = {
            seahorse: {
                re: "-0.74543",
                im: "0.11301",
                zoom: 5e4,
                it: 2048
            },
            snowflake: {
                re: "-0.10109629004872408548585126380133943559",
                im: "0.9562865745329222746947099385459096648",
                zoom: 3.169126e+29,
                it: 2048
            },
            spiral: {
                re: "-1.999993942175717867792242968103527549859576",
                im: "8.6071861910492399703689002138183e-21",
                zoom: 5.192297e+33,
                it: 2048
            },
            luxury: {
                re: "-0.79580869118304321175952779938151856806452507855882",
                im: "0.18469182276676613095841056743436302824144029079562",
                zoom: 1.3e42,
                it: 4096
            },
            horizon: {
                re: "-1.8584343800176784682217288203669595446250882516610855163",
                im: 0,
                zoom: 2.338403e+48,
                it: 8192
            },
            flora: {
                re: "-1.99909599626591118385320862404514647238736998791060410728750271382258617296138194612160227",
                im: "2.7580719798153099801178971305087708486297199751987655897677764832896127755911711978e-7",
                zoom: 1.554135e+85,
                it: 12000
            },
            classic: {
                re: "-1.740062382579339905220844167065825638296641720436171866879862418461182919644153056054840718339483225743450008259172138785492983677915427169",
                im: "0.02817533977921104899241152114431950968753907674299060857040130959588017432409201863854008146585605536156950844867740770006690377105617915918",
                zoom: 3.169127e+129,
                it: 16384
            },
            e200: {
                re: "-1.966802851116594708819298912851462114119985811705618926682822172678211294505900454587066386326486696211109981444987492635874831274786202351721769325471466717092496114767216598301545236111458996508055081585396",
                im: "0.0010977722859744975944199816905137002369183368289711851029920379829671969621655021360812521504061553173015969230096789768757462998082308739346850130554776214016764573717626859656016612926260380492615038665711972",
                zoom: 3.061802e+200,
                it: 2560
            },
            radiant: {
                re: "-1.99999999999999999999999999999999999999999999999999999999999985604992427869224505485316659406169263456244557162707394015035258073628597813990573253878488792954728746460753235734445467801735035140789540329931747966277516467943284583061883624921231436068907582257",
                im: "-8.91471704727989229599363700420508490047745648395754111902776340339365777429490330220597376804879333373511664660430230981300478098523390924266124801444129e-108",
                zoom: 6.190352e+250,
                it: 32768
            },
            branches: {
                re: "-1.6292734442048283318938320396270139993976098667361842769438797568378211896685981215295380430631824444939812959088045104000652511090002918608428367750404559604873908045574737562161798763493882467959347522331334565200535419490490792109572426042012307199142243133244778278658423929305351347449296418283955642234980665610830226069420767708737186375011028341136058680534715563202637094315075646672266222835522732620561624291470918925972479094214439824838059879454955180554531579035878862691173748960700828240715259267985644677355092076437915522889997465324097488586896011539207914088325170690741321143420090542550202239848652811940259393780795046066233233901935939495310855142242101042",
                im: "0.03869400209621531644885884354220643543483856432312340490566021352296232798895918154015224599032404970872042582187369535150768927860463654320654167750197244691011756126324382371624135105468469098307733451525287938447855301549425418319315644599440229040004000393629694918121347776683198213801647169431881760881989559740902877967780796990256450970464951956949842553605553300056814346433987027958609011265495269006410527939833349934593968626122035005120083542187577701148430417027976032242752140056316110069588785859474053819290291277818754134945550976828752797151560991794888216365813883286779093669780620189356923473044461454552716354829377180996852428111452867133487261674235339815",
                zoom: "1.5710523668200003e671",
                it: 22067
            }
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function* getReferenceOrbitMPFR(C, radius, iterations, precisionBits, reportInterval = 10000) {
            console.log(C)

            let Z = new DeepComplex(0, 0),
                z = new Complex(0, 0),
                dzdc = new Complex(1, 0),
                one = new Complex(1, 0);
            const orbit = [new Complex(0, 0)];

            const roundingMode = gmp.FloatRoundingMode.ROUND_DOWN;
            const options = { precisionBits: precisionBits, roundingMode };

            let gmpinit = await gmp.init();
            let ctx = gmpinit.getContext(options);

            let cre = ctx.Float(C.re.toString());
            let cim = ctx.Float(C.im.toString());
            let mpzre = ctx.Float(0);
            let mpzim = ctx.Float(0);

            let updateTimer = performance.now();

            for (let i = 0; i < iterations; i++) {
                dzdc = z.add(z).mulMut(dzdc).addMut(one);

                // Z = Z.square().add(C);
                const re = mpzre;
                const im = mpzim;

                const re2 = re.mul(re);       // re^2
                const im2 = im.mul(im);       // im^2
                const reim = re.mul(im);      // re*im

                mpzre = re2.sub(im2).add(cre);
                mpzim = reim.add(reim).add(cim); // 2*re*im + cim


                z = new Complex(mpzre.toNumber(), mpzim.toNumber());
                orbit.push(z);

                if (dzdc.norm() * radius * 2 > z.norm()) {
                    const predCenter = z.div(dzdc);
                    console.log(predCenter);
                    break;
                };
                if (z.norm() > 16.0) break;

                let currentTime = performance.now();
                if (currentTime - updateTimer > 100) {
                    updateTimer = currentTime;
                    yield i;
                    await delay(5);
                }
            }

            ctx.destroy();
            return orbit;
        }
        function MPFR2FloatExp(num) {
            let n = num.toNumber();
            if (n === 0 || !isFinite(n)) return parseFloatExp(num.toString());
            else if (isNaN(n)) return new FloatExp(0, 0);

            return getFloatExp(n); // Temporary simple conversion
            // console.log(num)
            // if (num.isZero()) return new FloatExp(0, 0);

            // const sign = num.sign();
            // const absNum = num.abs();

            // // Áî® bitLength ‰º∞ÁÆó 10^exponent
            // const log2 = absNum.precisionBits - 1;
            // let exponent = Math.floor(log2 / Math.log2(10));

            // // ËÆ°ÁÆó 10^exponent
            // const pow10 = BigInt("1" + "0".repeat(exponent)); // ÊàñËÄÖÁî® num library Êèê‰æõÁöÑ pow(10, exponent)

            // // ‰øÆÊ≠£ exponentÔºå‰Ωø mantissa ËêΩÂú® [1,10)
            // let mantissaNum = absNum.div(pow10);
            // while (mantissaNum >= 10) {
            //     mantissaNum = mantissaNum / 10;
            //     exponent++;
            // }
            // while (mantissaNum < 1) {
            //     mantissaNum = mantissaNum * 10;
            //     exponent--;
            // }

            // return new FloatExp(Number(mantissaNum) * sign, exponent);
        }

        async function* getReferenceOrbitFEMPFR(C, radius, iterations, precisionBits, reportInterval = 10000) {

            let Z = new DeepComplex(0, 0),
                z = new FloatExpComplex(0, 0),
                dzdc = new FloatExpComplex(1, 0),
                one = new FloatExpComplex(1, 0);
            const orbit = [new FloatExpComplex(0, 0)];


            const roundingMode = gmp.FloatRoundingMode.ROUND_DOWN;
            const options = { precisionBits: precisionBits, roundingMode };

            let gmpinit = await gmp.init();
            let ctx = gmpinit.getContext(options);

            let cre = ctx.Float(C.re.toString());
            let cim = ctx.Float(C.im.toString());
            let mpzre = ctx.Float(0);
            let mpzim = ctx.Float(0);

            let updateTimer = performance.now();

            for (let i = 0; i < iterations; i++) {
                dzdc = z.add(z).mulMut(dzdc).add(one);

                // Z = Z.square().add(C);
                const re = mpzre;
                const im = mpzim;

                const re2 = re.mul(re);       // re^2
                const im2 = im.mul(im);       // im^2
                const reim = re.mul(im);      // re*im

                mpzre = re2.sub(im2).add(cre);
                mpzim = reim.add(reim).add(cim); // 2*re*im + cim

                z = new FloatExpComplex(MPFR2FloatExp(mpzre), MPFR2FloatExp(mpzim));
                orbit.push(z);
                if (dzdc.norm().mul(radius).mul(2).compareTo(z.norm()) > 0) break;
                if (z.norm().doubleValue() > 16.0) break;

                let currentTime = performance.now();
                if (currentTime - updateTimer > 100) {
                    updateTimer = currentTime;
                    yield i;
                    await delay(5);
                }
            }
            ctx.destroy();
            return orbit;


            /*
            let Z = new DeepComplex(0, 0),
                z = new FloatExpComplex(0, 0),
                dzdc = new FloatExpComplex(1, 0),
                one = new FloatExpComplex(1, 0);
            const orbit = [new FloatExpComplex(0, 0)];
            for (let i = 0; i < iterations; i++) {
                dzdc = z.add(z).mulMut(dzdc).add(one);

                Z = Z.mul(Z).add(C);

                z = Z.toFloatExp();
                orbit.push(z);

                if (dzdc.norm().mul(radius).mul(2).compareTo(z.norm()) > 0) break;
                if (z.norm().doubleValue() > 16.0) break;
                if (i % reportInterval == 0) {
                    yield i;
                    await delay(1);
                };
            }
            return orbit;
            */
        }


        async function* getReferenceOrbit(C, radius, iterations, reportInterval = 10000) {
            let Z = new DeepComplex(0, 0),
                z = new Complex(0, 0),
                dzdc = new Complex(1, 0),
                one = new Complex(1, 0);

            let lpc = C.downCast(), lpz = new Complex(0, 0); // low precision
            const orbit = [new Complex(0, 0)];

            const waypoints = {};

            for (let i = 1; i < iterations; i++) {
                dzdc = z.add(z).mulMut(dzdc).addMut(one);

                Z = Z.square().add(C);
                lpz = lpz.mul(lpz).addMut(lpc)

                z = Z.downCast();
                orbit.push(z);

                const error = z.sub(lpz).norm();
                if (error > 1e-13) {
                    lpz = z;
                    waypoints[i] = z;
                }

                if (dzdc.norm() * radius * 2 > z.norm()) {
                    const predCenter = z.div(dzdc);
                    console.log(predCenter);
                    break;
                };
                if (z.norm() > 16.0) break;
                if (i % reportInterval == 0) {
                    yield i;
                    await delay(1);
                };
            }
            console.log("Compressed ref: ", waypoints)
            // // Test decompress and compare with original orbit
            // const orbit2 = decompressRef(C.downCast(), waypoints, iterations);
            // // Print two orbits side by side
            // for (let i = 0; i < Math.min(orbit.length, orbit2.length); i++) {
            //     const original = orbit[i] || new Complex(0, 0);
            //     const decompressed = orbit2[i] || new Complex(0, 0);
            //     console.log(`Iteration ${i} Original: ${original.toString()}, Decompressed: ${decompressed.toString()}, Compression Error: ${original.sub(decompressed).abs()}`);
            // }
            return orbit;
        }

        function decompressRef(c, waypoints, maxIter) {
            let re = 0, im = 0;
            const orbit = [new Complex(0, 0)];

            const waypointKeys = Object.keys(waypoints);

            let iter = 0;
            while (iter < maxIter) {
                // if iter in waypoint, use waypoint value
                if (waypointKeys.includes(iter.toString())) {
                    re = waypoints[iter].re;
                    im = waypoints[iter].im;
                }
                // do standard mandelbrot iteration
                const re2 = re * re;
                const im2 = im * im;
                const re1 = re;
                const im1 = im;
                if (re2 + im2 > 16.0) break;
                im = 2 * re * im + c.im;
                re = re2 - im2 + c.re;
                orbit.push(new Complex(re, im));
                iter++;
            }
            return orbit;
        }

        function floorPowerOfTwo(n) {
            if (n <= 0) return 0;
            return Math.pow(2, Math.floor(Math.log2(n)));
        }

        /**
         * Calculates the reference orbit for a given complex number 'c' using the Mandelbrot iteration.
         * @param {DeepComplex} c - The complex number for which the reference orbit is calculated.
         * @param {number} iterations - The number of iterations to perform.
         * @returns {FloatExpComplex[]} - An array containing the reference orbit.
         */
        async function* getReferenceOrbitFE(C, radius, iterations, reportInterval = 10000) {
            let Z = new DeepComplex(0, 0),
                z = new FloatExpComplex(0, 0),
                dzdc = new FloatExpComplex(1, 0),
                one = new FloatExpComplex(1, 0);
            const orbit = [new FloatExpComplex(0, 0)];
            for (let i = 0; i < iterations; i++) {
                dzdc = z.add(z).mulMut(dzdc).add(one);

                Z = Z.mul(Z).add(C);

                z = Z.toFloatExp();
                orbit.push(z);

                if (dzdc.norm().mul(radius).mul(2).compareTo(z.norm()) > 0) break;
                if (z.norm().doubleValue() > 16.0) break;
                if (i % reportInterval == 0) {
                    yield i;
                    await delay(1);
                };
            }
            return orbit;
        }


        /**
         * Calculates the number of iterations required for a complex number to exceed a given bailout value.
         *
         * @param {number} re - The real part of the complex number.
         * @param {number} im - The imaginary part of the complex number.
         * @param {number} bailout - The bailout value.
         * @param {number} maxiter - The maximum number of iterations to perform.
         * @returns {number} - The number of iterations required for the complex number to exceed the bailout value.
         */
        function getDirect(re, im, bailout, maxiter) {
            let it = 0;
            let re1 = re;
            let im1 = im;

            while (it <= maxiter) {
                let re2 = re * re;
                let im2 = im * im;
                if (re2 + im2 > bailout) return it;
                let temp = re2 - im2 + re1;
                im = 2 * re * im + im1;
                re = temp;
                it++;
            }
            return it;
        }


        /**
         * Generate BLA table
         * @param {Complex[]} ref - The reference orbit
         * @param {number} scale - Current image scale
         * */

        function createBLATable(ref, scale) {
            const lv1 = [];
            const table = [lv1];
            for (let i = 1; i < ref.length; i++) {
                const point = ref[i];

                const A = point.mul(2);
                const B = new Complex(1, 0);
                lv1.push({
                    A: A,
                    B: B,
                    radius: Math.max(0,
                        (point.norm() - B.norm() * scale) / (A.norm() + 1) * 5.96e-8
                    )
                })
            }

            let level = 1;
            while (true) {
                table.push([]);

                for (let i = 0; i < table[level - 1].length; i += 2) {
                    const bla1 = table[level - 1][i];
                    const bla2 = table[level - 1][i + 1];

                    if (bla2 == null) {
                        table[level].push(bla1)
                        continue;
                    };

                    table[level].push({
                        A: bla1.A.mul(bla2.A),
                        B: bla1.B.mul(bla2.A).add(bla2.B),
                        radius: Math.min(
                            bla1.radius, Math.max(
                                0, (bla2.radius - bla1.B.norm() * scale) / bla1.A.norm()
                            )
                        )
                    })

                }
                if (table[level].length <= 1) break;
                level++;
            }

            return table;
        }

        function lookup(table, i, refLen, norm_dz, norm_dc) {
            if (i === 0 || i >= refLen || table.length === 0) {
                return {
                    first: null,
                    second: 0
                };
            }

            let result = {
                first: null,
                second: 0
            }; // { step, length }
            let index = i - 1,
                length = 1;

            for (let level of table) {
                if (norm_dz > level[index].radius) {
                    break;
                }
                result.first = level[index];
                result.second = length;

                if (index % 2) {
                    break;
                }
                index >>= 1; // equivalent to index = Math.floor(index / 2)
                length <<= 1; // equivalent to length *= 2
            }

            result.second = Math.min(result.second, refLen - i);
            return result;
        }

        function createBLATableFE(ref, scale) {
            const lv1 = [];
            const table = [lv1];
            for (let i = 1; i < ref.length; i++) {
                const point = ref[i];

                const A = point.mul(2);
                const B = new FloatExpComplex(1, 0);
                lv1.push({
                    A: A,
                    B: B,
                    radius: FEmax(new FloatExp(0),
                        (point.norm().sub(B.norm().mul(scale))).div(A.norm().add(1)).mul(5.96e-8)
                    )
                })
            }

            let level = 1;
            while (true) {
                table.push([]);

                for (let i = 0; i < table[level - 1].length; i += 2) {
                    const bla1 = table[level - 1][i];
                    const bla2 = table[level - 1][i + 1];

                    if (bla2 == null) {
                        table[level].push(bla1)
                        continue;
                    };

                    table[level].push({
                        A: bla1.A.mul(bla2.A),
                        B: bla1.B.mul(bla2.A).add(bla2.B),
                        radius: FEmin(
                            bla1.radius, FEmax(
                                new FloatExp(0), (bla2.radius.sub(bla1.B.norm().mul(scale))).div(bla1.A.norm())
                            )
                        )
                    })

                }
                if (table[level].length <= 1) break;
                level++;
            }

            return table;
        }

        function lookupFE(table, i, refLen, norm_dz, norm_dc) {
            if (i === 0 || i >= refLen || table.length === 0) {
                return {
                    first: null,
                    second: 0
                };
            }

            let result = {
                first: null,
                second: 0
            }; // { step, length }
            let index = i - 1,
                length = 1;

            for (let level of table) {
                if (norm_dz.compareTo(level[index].radius) > 0) {
                    break;
                }
                result.first = level[index];
                result.second = length;

                if (index % 2) {
                    break;
                }
                index >>= 1; // equivalent to index = Math.floor(index / 2)
                length <<= 1; // equivalent to length *= 2
            }

            result.second = Math.min(result.second, refLen - i);
            return result;
        }


        /**
         * Calculates the escape time for a point in the Mandelbrot set using perturbation theory.
         * @param {Complex} dc - The perturbation applied to the point.
         * @param {Complex[]} ref - The reference orbit.
         * @param {Complex[][]} table - The BLA table.
         * @param {number} maxIter - The maximum iteration.
         * @param {number} bailout - The bailout value used for iteration termination.
         * @returns {number|null} - The escape time for the point or null if it doesn't escape.
         */
        function getPTBLA(dc, ref, table, maxIter, bailout, smooth = false) {
            let dzRe = 0, dzIm = 0, iter = -1, refIter = 0;

            let dcNorm = Math.max(Math.abs(dc.re), Math.abs(dc.im));
            while (iter < maxIter) {
                let dzNorm = Math.max(Math.abs(dzRe), Math.abs(dzIm)); // Chebyshev norm

                let result = lookup(table, refIter, ref.length, dzNorm, dcNorm);

                if (result.first != null) {
                    let aRe = result.first.A.re,
                        aIm = result.first.A.im;
                    let bRe = result.first.B.re,
                        bIm = result.first.B.im;

                    let newDzRe = dzRe * aRe - dzIm * aIm + dc.re * bRe - dc.im * bIm;
                    let newDzIm = dzRe * aIm + dzIm * aRe + dc.re * bIm + dc.im * bRe;

                    dzRe = newDzRe;
                    dzIm = newDzIm;

                    iter += result.second;
                    refIter += result.second;
                } else {
                    const Z = ref[refIter];

                    let tempRe = dzRe,
                        tempIm = dzIm;

                    // dz = dz * 2 * Z + dz^2 + dc
                    dzRe = (2 * Z.re + tempRe) * tempRe - (2 * Z.im + tempIm) * tempIm + dc.re;
                    dzIm = 2 * (Z.re * tempIm + Z.im * tempRe + tempRe * tempIm) + dc.im;

                    iter++;
                    refIter++;
                }

                if (refIter >= ref.length) return iter;
                const Z2 = ref[refIter];
                let valRe = Z2.re + dzRe;
                let valIm = Z2.im + dzIm;

                // Squared Euclidean distance (abs squared)
                let valAbsSq = valRe * valRe + valIm * valIm;
                if (valAbsSq > bailout) {
                    if (smooth) {
                        let fracIter = Math.log(valAbsSq) / 2;
                        fracIter = Math.log(fracIter / Math.LN2) / Math.LN2;
                        iter += 1 - fracIter;
                        return iter;
                    } else {
                        return iter; // If not smooth, just return the iteration count
                    }
                }

                let dzAbsSq = dzRe * dzRe + dzIm * dzIm;
                if (valAbsSq < dzAbsSq || refIter == ref.length - 1) {
                    dzRe = valRe;
                    dzIm = valIm;
                    refIter = 0;
                }
            }
            return iter;
        }

        function getPTBLAFE(dc, ref, table, maxIter, bailout, smooth = false) {
            let dz = new FloatExpComplex(0, 0)

            let iter = -1;
            let refIter = 0;
            let bout = new FloatExp(bailout);
            let zero = new FloatExp(0);
            let dcNorm = dc.norm();

            while (iter < maxIter) {
                let dzNorm = dz.norm();
                let result = lookupFE(table, refIter, ref.length, dzNorm, dcNorm)

                if (result.first != null) {
                    dz.mulMut(result.first.A).addMut(dc.mul(result.first.B));
                    iter += result.second;
                    refIter += result.second;
                } else {
                    const Z = ref[refIter]
                    let dz2 = dz.square();
                    dz.addMut(dz).mulMut(Z).addMut(dz2).addMut(dc)
                    iter++;
                    refIter++;
                }
                if (refIter >= ref.length) return iter;

                const Z2 = ref[refIter]
                const val = Z2.add(dz);
                const valAbs = val.abs();
                if (valAbs.doubleValue() > bailout) {
                    if (smooth) {
                        let fracIter = Math.log(valAbs.doubleValue()) / 2;
                        fracIter = Math.log(fracIter / Math.LN2) / Math.LN2;
                        iter += 1 - fracIter;
                        return iter;
                    } else {
                        return iter; // If not smooth, just return the iteration count
                    }
                };
                if (valAbs.sub(dzNorm).compareTo(zero) < 0 || refIter == ref.length - 1) { // Ê£ÄÊµãÊòØÂê¶ÈúÄË¶ÅÂèòÂü∫
                    dz = val;
                    refIter = 0;
                }
            }
            return iter;
        }

        /**
         * Generates a rainbow palette of colors.
         * @param {number} numColors - The number of colors to generate.
         * @returns {number[][]} - An array containing RGBA values for each color in the palette.
         */
        function generateRainbowPalette(numColors) {
            const rainbowColors = [];
            const frequency = 0.2; // Adjust the frequency to change the spread of colors

            for (let i = 0; i < numColors; i++) {
                const red = Math.sin(frequency * i) * 127 + 128;
                const green = Math.sin(frequency * 1.1 * i) * 127 + 128;
                const blue = Math.sin(frequency * 1.2 * i) * 127 + 128;
                rainbowColors.push([red | 0, green | 0, blue | 0, 255]);
            }

            return rainbowColors;
        }

        let defaultPalette = [[1, 1, 1], [205, 92, 92], [240, 128, 128], [255, 0, 0], [178, 34, 34], [139, 0, 0], [188, 143, 143], [165, 42, 42], [128, 0, 0], [250, 128, 114], [255, 99, 71], [233, 150, 122], [255, 127, 80], [255, 69, 0], [255, 160, 122], [160, 82, 45], [210, 105, 30], [139, 69, 19], [244, 164, 96], [255, 218, 185], [205, 133, 63], [255, 228, 196], [255, 140, 0], [222, 184, 135], [210, 180, 140], [255, 222, 173], [255, 228, 181], [255, 165, 0], [245, 222, 179], [184, 134, 11], [218, 165, 32], [255, 215, 0], [240, 230, 140], [238, 232, 170], [189, 183, 107], [255, 255, 0], [128, 128, 0], [107, 142, 35], [154, 205, 50], [85, 107, 47], [173, 255, 47], [127, 255, 0], [124, 252, 0], [0, 255, 0], [50, 205, 50], [152, 251, 152], [144, 238, 144], [34, 139, 34], [0, 128, 0], [0, 100, 0], [143, 188, 143], [46, 139, 87], [60, 179, 113], [0, 255, 127], [0, 250, 154], [102, 205, 170], [127, 255, 212], [64, 224, 208], [32, 178, 170], [72, 209, 204], [0, 139, 139], [0, 128, 128], [0, 255, 255], [175, 238, 238], [0, 206, 209], [95, 158, 160], [176, 224, 230], [173, 216, 230], [0, 191, 255], [135, 206, 235], [135, 206, 250], [70, 130, 180], [30, 144, 255], [176, 196, 222], [100, 149, 237], [65, 105, 225], [0, 0, 255], [0, 0, 205], [0, 0, 139], [0, 0, 128], [25, 25, 112], [106, 90, 205], [72, 61, 139], [123, 104, 238], [147, 112, 219], [138, 43, 226], [75, 0, 130], [153, 50, 204], [148, 0, 211], [186, 85, 211], [216, 191, 216], [221, 160, 221], [238, 130, 238], [255, 0, 255], [139, 0, 139], [128, 0, 128], [218, 112, 214], [199, 21, 133], [255, 20, 147], [255, 105, 180], [219, 112, 147], [220, 20, 60], [255, 192, 203], [255, 182, 193], [220, 220, 220], [211, 211, 211], [192, 192, 192], [169, 169, 169], [128, 128, 128], [105, 105, 105], [119, 136, 153], [112, 128, 144], [47, 79, 79]]
        let palette = defaultPalette;
        let colorStep = 6;
        /**
         * Calculates the color transition between two colors in a palette based on a percentage.
         * @param {number[][]} pal - The palette containing RGB values for colors.
         * @param {number} it - The percentage of transition between two colors (0 to 1).
         * @returns {number[]} - An array containing RGB values for the interpolated color.
         */
        function colorTrans(pal, it) {
            var percent = it - Math.floor(it);
            var c1 = Math.floor(it) % pal.length;
            var c2 = (c1 + 1) % pal.length;
            var r = (1 - percent) * pal[c1][0] + (percent) * pal[c2][0];
            var g = (1 - percent) * pal[c1][1] + (percent) * pal[c2][1];
            var b = (1 - percent) * pal[c1][2] + (percent) * pal[c2][2];
            return [r, g, b]
        }

        /**
         * Gets the color associated with the escape time 'it'.
         * @param {number|null} it - The escape time for a point or null if it doesn't escape.
         * @returns {number[]} - An array containing RGBA values for the color associated with the escape time.
         */
        function getColor(it, maxIter) {
            if (it == null || it >= maxIter) return [0, 0, 0, 255];
            else if (it < 0) return [palette[0][0], palette[0][1], palette[0][2], 255];
            let color = colorTrans(palette, it / colorStep);
            return [color[0], color[1], color[2], 255];
        }

        function groupArray(arr, groupSize = 3) {
            if (!arr || arr.length === 0 || groupSize <= 0) {
                return [];
            }

            const result = [];
            for (let i = 0; i < arr.length; i += groupSize) {
                result.push(arr.slice(i, i + groupSize));
            }
            return result;
        }

        function sortByProximityToCenterPixel(array, imageWidth, imageHeight) {
            // È¢ÑÂÖàËÆ°ÁÆó‰∏≠ÂøÉÁÇπÂùêÊ†á
            const centerX = imageWidth / 2;
            const centerY = imageHeight / 2;

            // ‰ΩøÁî®mapÂàõÂª∫Â∏¶Ë∑ùÁ¶ªÂπ≥ÊñπÁöÑ‰∏¥Êó∂Êï∞ÁªÑ
            const withDistSq = array.map(item => {
                const centerItemX = item[2];  // ÂÖÉÁ¥†‰∏≠ÂøÉX
                const centerItemY = item[3];  // ÂÖÉÁ¥†‰∏≠ÂøÉY
                const dx = centerItemX - centerX;         // XÊñπÂêëÂ∑ÆÂÄº
                const dy = centerItemY - centerY;         // YÊñπÂêëÂ∑ÆÂÄº
                return {
                    item: item,
                    distSq: dx * dx + dy * dy            // Ë∑ùÁ¶ªÂπ≥ÊñπÔºàÈÅøÂÖçÂºÄÊñπÔºâ
                };
            });

            // ÊåâË∑ùÁ¶ªÂπ≥ÊñπÊéíÂ∫èÔºàÂçáÂ∫èÔºâ
            withDistSq.sort((a, b) => a.distSq - b.distSq);

            // ÊèêÂèñÂéüÂßãÂÖÉÁ¥†
            return withDistSq.map(entry => entry.item);
        }

        function base64ToByteArray(base64String) {
            try {
                // ËøòÂéüÂ≠óÁ¨¶Âπ∂Â∞ÜURLÂÆâÂÖ®ÁöÑBase64ËΩ¨Êç¢‰∏∫Ê†áÂáÜBase64
                let base64 = base64String.replace(/-/g, '+').replace(/_/g, '/');

                // Ê∑ªÂä† padding (Á°Æ‰øùÈïøÂ∫¶ÊòØ4ÁöÑÂÄçÊï∞)
                const padLength = (4 - (base64.length % 4)) % 4;
                base64 += '='.repeat(padLength);

                const binaryString = atob(base64); // Ëß£Á†ÅBase64
                const byteArray = new Uint8Array(binaryString.length);

                for (let i = 0; i < binaryString.length; i++) {
                    byteArray[i] = binaryString.charCodeAt(i);
                }

                return Array.from(byteArray);
            } catch (error) {
                throw new Error("ËæìÂÖ•‰∏çÊòØ‰∏Ä‰∏™ÊúâÊïàÁöÑURLÂÆâÂÖ®Base64Â≠óÁ¨¶‰∏≤„ÄÇ");
            }
        }

        function byteArrayToBase64(byteArray) {
            if (!Array.isArray(byteArray)) {
                throw new Error("ËæìÂÖ•ÂøÖÈ°ªÊòØ‰∏Ä‰∏™Êï∞ÁªÑ„ÄÇ");
            }

            // È™åËØÅÂ≠óËäÇÊï∞ÁªÑ
            if (byteArray.some(v => typeof v !== 'number' || !Number.isInteger(v) || v < 0 || v > 255)) {
                throw new Error("Êï∞ÁªÑ‰∏≠ÁöÑÊØè‰∏™ÂÖÉÁ¥†ÂøÖÈ°ªÊòØ0-255‰πãÈó¥ÁöÑÊï¥Êï∞„ÄÇ");
            }

            // ÊûÑÂª∫‰∫åËøõÂà∂Â≠óÁ¨¶‰∏≤
            const binaryString = String.fromCharCode(...byteArray);

            // ÁºñÁ†ÅÂπ∂ËΩ¨Êç¢‰∏∫URLÂÆâÂÖ®Ê†ºÂºè
            const base64 = btoa(binaryString)
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=+$/, '');

            return base64;
        }
        // ============================

        function fExp2Obj(fExp) {
            return { mant: fExp.base, exp: fExp.exp }
        }
        function fExpComplex2Obj(fExpComplex) {
            return {
                re: fExp2Obj(fExpComplex.re),
                im: fExp2Obj(fExpComplex.im)
            }
        }

        function createWorker() {

            function constructRef(refArray) {
                let ref = [];
                for (let i = 0; i < refArray.length; i++) {
                    ref.push(new Complex(refArray[i][0], refArray[i][1]));
                }
                return ref;
            }

            function constructBla(blaArray) {
                let out = []
                for (let i = 0; i < blaArray.length; i++) {
                    out.push([])
                    for (let j = 0; j < blaArray[i].length; j++) {
                        out[i].push({
                            A: new Complex(blaArray[i][j].A[0], blaArray[i][j].A[1]),
                            B: new Complex(blaArray[i][j].B[0], blaArray[i][j].B[1]),
                            radius: blaArray[i][j].radius
                        })
                    }
                }
                return out
            }

            function obj2FExp(obj) {
                return new FloatExp(obj.mant, obj.exp)
            }

            function obj2FExpComplex(obj) {
                return new FloatExpComplex(obj2FExp(obj.re), obj2FExp(obj.im))
            }
            function constructRefFE(refArray) {
                let ref = [];
                for (let i = 0; i < refArray.length; i++) {
                    ref.push(obj2FExpComplex(refArray[i]));
                }
                return ref;
            }

            function constructBlaFE(blaArray) {
                let out = []
                for (let i = 0; i < blaArray.length; i++) {
                    out.push([])
                    for (let j = 0; j < blaArray[i].length; j++) {
                        out[i].push({
                            A: obj2FExpComplex(blaArray[i][j].A),
                            B: obj2FExpComplex(blaArray[i][j].B),
                            radius: obj2FExp(blaArray[i][j].radius)
                        })
                    }
                }
                return out
            }

            self.onmessage = function (event) {
                let calc = []
                switch (event.data.type) {
                    case 'ref':
                        if (!event.data.deep) {
                            self.refArray = constructRef(event.data.ref);
                            self.blaArray = constructBla(event.data.bla);
                        } else {
                            self.refArray = constructRefFE(event.data.ref);
                            self.blaArray = constructBlaFE(event.data.bla);
                        }
                        self.deep = event.data.deep;
                        break
                    case 'calc':
                        const calc = [];
                        if (!self.deep) {
                            for (let delta of event.data.deltas) {
                                try {
                                    let it = getPTBLA(
                                        // 0: re, 1: im, 2: x, 3: y, 4: w, 5: h
                                        new Complex(delta[0], delta[1]),
                                        self.refArray,
                                        self.blaArray,
                                        event.data.maxIter,
                                        event.data.bailout,
                                        event.data.smooth
                                    );
                                    calc.push([
                                        it,
                                        delta[2],
                                        delta[3]
                                    ]);
                                } catch (e) { }
                            }
                        } else {
                            for (let delta of event.data.deltas) {
                                try {
                                    let it = getPTBLAFE(
                                        new FloatExpComplex(
                                            new FloatExp(delta[0].base, delta[0].exp),
                                            new FloatExp(delta[1].base, delta[1].exp)
                                        ),
                                        self.refArray,
                                        self.blaArray,
                                        event.data.maxIter,
                                        event.data.bailout,
                                        event.data.smooth
                                    );
                                    calc.push([
                                        it,
                                        delta[2],
                                        delta[3]
                                    ]);
                                } catch (e) { }
                            }
                        }
                        self.postMessage(calc);
                }

            };
        }


        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        const code = new TextEncoder().encode(`
    ${Complex.toString()}${lookup.toString()};${getPTBLA.toString()}
    ${FloatExp.toString()}${FloatExpComplex.toString()}${getFloatExp.toString()}
    ${doubleToFloatExp.toString()}${FEmax.toString()}${FEmin.toString()}
    ${getPTBLAFE.toString()}${lookupFE.toString()}
        (
        ${createWorker.toString()}
        )();`);
        const workerData = 'data:application/javascript;base64,' + arrayBufferToBase64(code)

        /**
         * Represents a Mandelbrot set visualization.
         */
        class Mandelbrot {
            center;
            iterations;
            bailout;
            size;

            canvas;
            context;

            ref;

            refValid;

            stats;

            img;

            rendering;

            /**
             * @param {HTMLCanvasElement} canvas - The canvas element to draw the Mandelbrot set.
             * @param {DeepComplex} center - The center point of the Mandelbrot set.
             * @param {number} iterations - The number of iterations to perform for each point.
             * @param {number} bailout - The bailout value used for iteration termination.
             */
            constructor(canvas, center, iterations, bailout) {
                this.center = center;
                this.iterations = iterations;
                this.bailout = bailout * bailout;
                this.smooth = false;

                this.size = new FloatExp(4);
                this.deep = false;

                this.canvas = canvas;
                this.context = canvas.getContext('2d');
                this.rendering = false;
                this.iterMap = [...new Array(this.canvas.height)].map(e => [...new Array(this.canvas.width)].map(e => 0))
                this.videoRendering = false;
                this.drawState = 0;
                this.drawStates = [
                    [2, 2],
                    [1, 2],
                    [1, 1]
                ]

                // NEW: Interaction State
                this.transformState = { scale: 1, tx: 0, ty: 0 };
                this.isInteracting = false;
                this.dragStartPoint = { x: 0, y: 0 };
                this.transformAtDragStart = { scale: 1, tx: 0, ty: 0 };
                this.recalculationTimeout = null;
                this.lastTouchDistance = 0;

                window.addEventListener('resize', () => this.resizeCanvas(true));

                this.canvas.addEventListener('mousedown', e => this.handleStart(e));
                this.canvas.addEventListener('mousemove', e => this.handleMove(e));
                this.canvas.addEventListener('mouseup', e => this.handleEnd(e));
                this.canvas.addEventListener('mouseleave', e => this.handleEnd(e));
                this.canvas.addEventListener('wheel', e => this.handleWheel(e), { passive: false });
                this.canvas.addEventListener('touchstart', e => this.handleStart(e), { passive: false });
                this.canvas.addEventListener('touchmove', e => this.handleMove(e), { passive: false });
                this.canvas.addEventListener('touchend', e => this.handleEnd(e));
                this.canvas.addEventListener('touchcancel', e => this.handleEnd(e));

                this.stats = {
                    ref: 0,
                    calc: 0,
                    guess: 0,
                    approx: 0,
                    time: performance.now()
                }


                this.counter = 0;
                this.workerCounter = 0;
                this.resolveFunc = null;
                this.lastUpdateTime = performance.now();

                // Cancelling state
                this.requestForCancel = false;
                this.cancelling = false;

                // this.workers = []
                // for (let i = 0; i < CPU_CORES; i++) {
                //     this.workers[i] = new Worker(workerData);
                //     this.workers[i].onmessage = event => {
                //         this.stats.calc += event.data.length;
                //         for (let delta of event.data) {
                //             let [w, h] = this.drawStates[this.drawState];
                //             this.setIter(
                //                 delta[1], delta[2],
                //                 delta[0],
                //                 w, h
                //             );
                //         }
                //         this.counter--;
                //         // if (this.counter % CPU_CORES == 0) {
                //         // };
                //         this.showInfo();
                //         this.context.putImageData(this.image, 0, 0)

                //         if (this.counter <= 0) {
                //             this.resolveFunc();
                //         }
                //     }
                // }

                // Initial setup
                this.resizeCanvas(false); // Set initial size without triggering update
            }

            resizeCanvas(triggerUpdate = true) {
                let dpr = window.devicePixelRatio;
                this.canvas.width = window.innerWidth * dpr;
                this.canvas.height = window.innerHeight * dpr;
                this.iterMap = [...new Array(this.canvas.height)].map(() => new Array(this.canvas.width).fill(0));
                if (triggerUpdate) {
                    this.clear();
                    this.update();
                }
            }

            handleStart(e) {
                e.preventDefault();
                this.isInteracting = true;
                this.cancel();

                if (e.touches) {
                    this.dragStartPoint = this.getTouchCenter(e.touches);
                    if (e.touches.length === 2) {
                        this.lastTouchDistance = this.getTouchDistance(e.touches);
                    }
                } else {
                    this.dragStartPoint = { x: e.clientX, y: e.clientY };
                }
                // Store the state at the beginning of the interaction
                this.transformAtDragStart = { ...this.transformState };
            }

            handleMove(e) {
                if (!this.isInteracting) return;
                e.preventDefault();

                if (e.touches) {
                    const currentTouchCenter = this.getTouchCenter(e.touches);
                    // Pan
                    const dx = currentTouchCenter.x - this.dragStartPoint.x;
                    const dy = currentTouchCenter.y - this.dragStartPoint.y;
                    this.transformState.tx = this.transformAtDragStart.tx + dx;
                    this.transformState.ty = this.transformAtDragStart.ty + dy;

                    // Pinch zoom
                    if (e.touches.length === 2) {
                        const currentDist = this.getTouchDistance(e.touches);
                        const scaleFactor = currentDist / this.lastTouchDistance;
                        // Combine with existing scale
                        const newScale = this.transformAtDragStart.scale * scaleFactor;

                        // Zoom towards the original touch center
                        const pivot = this.dragStartPoint;
                        this.transformState.tx = pivot.x - (pivot.x - this.transformAtDragStart.tx) * scaleFactor + dx;
                        this.transformState.ty = pivot.y - (pivot.y - this.transformAtDragStart.ty) * scaleFactor + dy;
                        this.transformState.scale = newScale;
                    }
                } else { // Mouse drag
                    const dx = e.clientX - this.dragStartPoint.x;
                    const dy = e.clientY - this.dragStartPoint.y;
                    this.transformState.tx = this.transformAtDragStart.tx + dx;
                    this.transformState.ty = this.transformAtDragStart.ty + dy;
                }


                console.log(this.transformState)
                this.applyCssTransform();
            }

            handleEnd(e) {
                if (!this.isInteracting) return;
                this.isInteracting = false;
                this.applyTransformAndRecalculate();
            }

            handleWheel(e) {
                this.canvas.classList.add('transition')
                e.preventDefault();

                const scaleFactor = e.deltaY < 0 ? 2 : 0.5;
                const pivotX = e.clientX;
                const pivotY = e.clientY;

                this.transformState.tx = pivotX - (pivotX - this.transformState.tx) * scaleFactor;
                this.transformState.ty = pivotY - (pivotY - this.transformState.ty) * scaleFactor;
                this.transformState.scale *= scaleFactor;

                this.applyCssTransform();
                this.triggerRecalculation();
            }

            // --- Helper functions for touch events ---
            getTouchCenter(touches) {
                let centerX = 0, centerY = 0;
                for (const touch of touches) {
                    centerX += touch.clientX;
                    centerY += touch.clientY;
                }
                return { x: centerX / touches.length, y: centerY / touches.length };
            }

            getTouchDistance(touches) {
                return Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
            }

            applyCssTransform() {
                const { scale, tx, ty } = this.transformState;
                this.canvas.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
            }

            triggerRecalculation() {
                clearTimeout(this.recalculationTimeout);
                this.recalculationTimeout = setTimeout(() => {
                    this.applyTransformAndRecalculate();
                }, 200);
            }

            applyTransformAndRecalculate() {
                const { scale, tx, ty } = this.transformState;

                if (Math.abs(scale - 1) < 1e-9 && Math.abs(tx) < 1 && Math.abs(ty) < 1) {
                    return;
                }

                console.log(`Applying transform: scale=${scale}, tx=${tx}, ty=${ty}`);

                // Map canvas screen delta to canvas coordinate delta
                const canvasX = ((canvas.width * 0.5) - tx / canvas.offsetWidth * canvas.width) / scale;
                const canvasY = ((canvas.height * 0.5) - ty / canvas.offsetHeight * canvas.height) / scale;

                console.log(`Canvas delta: ${canvasX}, ${canvasY}`)

                const delta = this.getDelta(canvasX, canvasY);
                console.log(`Complex delta: ${delta.toString()}`);

                // Update mathematical state
                this.goto(
                    this.center.add(delta), false
                )

                this.zoom(this.size.div(scale));

                // Calculate the source rectangle from the old canvas content that is currently visible.
                const sx = -(tx / canvas.offsetWidth * canvas.width) / scale;
                const sy = -(ty / canvas.offsetHeight * canvas.height) / scale;
                const sWidth = this.canvas.width / scale;
                const sHeight = this.canvas.height / scale;
                console.log(`Source rect: ${sx}, ${sy}, ${sWidth}, ${sHeight}`);

                // The CSS transform is about to be removed. To prevent a flicker,
                // we use drawImage to "bake" the transformed view into the canvas bitmap.
                // This creates an immediate, low-resolution preview.

                // Important: FIRST, reset the CSS transform so the canvas snaps back to its original state.
                // The browser won't render this change until the current script finishes,
                // so the user won't see the "snap".
                this.canvas.style.transform = '';

                // THEN, draw the calculated portion of the (now untransformed) canvas back onto itself,
                // scaled up to fill the whole view. This effectively applies the transform permanently.
                this.context.drawImage(
                    this.canvas,   // Source image is the canvas itself
                    sx, sy, sWidth, sHeight,  // Source rectangle
                    0, 0, this.canvas.width, this.canvas.height // Destination rectangle (the whole canvas)
                );

                // Reset visual transform state for the next render
                this.transformState = { scale: 1, tx: 0, ty: 0 };

                this.canvas.classList.remove('transition')
                this.requestForCancel = false;
                this.cancelling = false;
                this.update(floorPowerOfTwo(Math.max(2, scale)));
            }

            click(x, y) {
                // Calculate the new center and zoom level
                this.goto(this.center.add(this.getDelta(x, y)), false);
                this.zoom(this.size.div(4));

                // Capture the clicked section (a quarter of the canvas size around the click point)
                const zoomWidth = this.canvas.width / 4;
                const zoomHeight = this.canvas.height / 4;
                const startX = x - zoomWidth / 2; // Top-left x of the zoomed region
                const startY = y - zoomHeight / 2; // Top-left y of the zoomed region

                // Scale up the selected region to 4x its size
                this.context.drawImage(
                    this.canvas,
                    startX, startY, zoomWidth, zoomHeight,  // Source region (original size)
                    0, 0, this.canvas.width, this.canvas.height // Destination (scaled to fit canvas)
                );
            }

            zoomOut() {
                let newMap = [...new Array(this.canvas.height)].map(e => [...new Array(this.canvas.width)].map(e => 0))
                for (let y = 0; y < this.canvas.height; y += 2) {
                    for (let x = 0; x < this.canvas.width; x += 2) {
                        newMap
                        [this.canvas.height / 4 + y / 2]
                        [this.canvas.width / 4 + x / 2]
                            =
                            this.iterMap[y][x];
                    }
                }
                this.iterMap = newMap;
                this.size = this.size.mul(2);
            }

            /**
             * Zooms the Mandelbrot set visualization.
             * @param {FloatExp} size - The new size of the visualization.
             */
            zoom(size) {
                Decimal.config({
                    precision: -size.exp + 10
                })
                this.deep = this.size.exp < -300;
                this.size = size;
                this.clear();
            }

            /**
             * Clear iteration map
             */
            clear() {
                this.iterMap.forEach(e => e.fill(0))
            }

            /**
             * Moves the center of the Mandelbrot set visualization.
             * @param {DeepComplex} c - The new center point.
             */
            goto(c, clear = true) {
                this.center = c;
                this.refValid = false;
                if (clear) {
                    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.clear();
                }
            }

            /**
             * Sets the number of iterations for the Mandelbrot set visualization.
             * @param {number} it - The number of iterations.
             */
            setIterations(it) {
                this.iterations = parseInt(it);
            }

            /**
             * Resets the Mandelbrot set visualization to its initial state.
             */
            home() {
                this.goto(new DeepComplex(new Decimal(0), new Decimal(0)))
                this.size = new FloatExp(4);
                this.deep = false;
                this.iterations = 256;
            }

            /**
             * Calculates the delta between a point and the base point on the canvas.
             * @param {number} x - The x-coordinate of the point.
             * @param {number} y - The y-coordinate of the point.
             * @param {number} [baseX] - The x-coordinate of the base point (optional).
             * @param {number} [baseY] - The y-coordinate of the base point (optional).
             * @returns {FloatExpComplex} - The delta as a complex number.
             */
            getDelta(x, y, baseX, baseY) {
                if (!baseX) baseX = this.canvas.width / 2;
                if (!baseY) baseY = this.canvas.height / 2;
                let minStep = Math.min(this.canvas.width, this.canvas.height)
                let deltaPerPixel = this.size.div(minStep);
                return this.deep ? new FloatExpComplex(
                    deltaPerPixel.mul(x - baseX),
                    deltaPerPixel.mul(baseY - y)

                ) : new Complex(
                    (x - baseX) * deltaPerPixel,
                    (baseY - y) * deltaPerPixel
                )

                // return this.deep ? new FloatExpComplex(
                //     this.size.mul((x - baseX) / this.canvas.width),
                //     this.size.mul((baseY - y) / this.canvas.height)
                // ) : new Complex(
                //     (x - baseX) / this.canvas.width * this.size,
                //     (baseY - y) / this.canvas.height * this.size
                // )
            }


            /**
             * Retrieves the iteration of a pixel in the Mandelbrot set visualization.
             * @param {number} x - The x-coordinate of the pixel.
             * @param {number} y - The y-coordinate of the pixel.
             * @returns {number} - The iteration of the given point.
             */
            getIter(x, y) {
                if (x >= this.canvas.width || x < 0 || y >= this.canvas.height || y <= 0) return -1
                return this.iterMap[y][x];
            }

            /**
             * Sets the iteration of a pixel in the Mandelbrot set visualization.
             * @param {number} x - The x-coordinate of the pixel.
             * @param {number} y - The y-coordinate of the pixel.
             * @param {number} it - The iteration
             * @param {number} w - The width of the pixel.
             * @param {number} h - The height of the pixel.
             */
            setIter(x, y, it, w = 1, h = 1) {
                this.iterMap[y][x] = it;

                const color = getColor(it, this.iterations);

                let i = (y * this.canvas.width + x) << 2;
                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        let j = (dy * this.canvas.width + dx) << 2;
                        this.image.data[i + j] = color[0]
                        this.image.data[i + j + 1] = color[1]
                        this.image.data[i + j + 2] = color[2]
                        this.image.data[i + j + 3] = 255
                    }
                }
                // this.context.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`
                // this.context.fillRect(x, y, w, h)
            }

            showInfo() {
                let totalPixels = this.canvas.width * this.canvas.height;
                let elapsedTime = performance.now() - this.stats.time;
                let estimatedTotalTime = (elapsedTime / (this.stats.calc+this.stats.guess)) * totalPixels;
                let estimatedRemainingTime = estimatedTotalTime - elapsedTime;
                let statusText = `Reference: ${this.stats.ref}it\nTime: ${((elapsedTime) / 1000).toFixed(3)}s ETA: ${(estimatedRemainingTime / 1000).toFixed(3)}s\nCalculated: ${this.stats.calc}/${totalPixels} pixels\nGuessed: ${this.stats.guess}/${totalPixels} pixels`;
                if (!this.rendering) {
                    statusText += "\nDone!";
                }
                statsLabel.innerText = statusText;
                this.updateProgress();
            }

            // NEW: Separate function for progress bar to be called by worker callback
            updateProgress() {
                let totalPixels = this.canvas.width * this.canvas.height;
                progressBar.style.width = `${((this.stats.calc) / totalPixels * 100).toFixed(2)}%`;
                guessedProgressBar.style.width = `${((this.stats.guess) / totalPixels * 100).toFixed(2)}%`;
            }

            setLocked(locked) {
                if (locked) {
                    // Lock buttons
                    document.querySelectorAll('.control-button').forEach(button => {
                        button.disabled = true;
                    });
                    canvas.classList.add('running')
                } else {
                    // Unlock buttons
                    document.querySelectorAll('.control-button').forEach(button => {
                        button.disabled = false;
                    });
                    canvas.classList.remove('running')
                }
            }

            /**
             * Updates the Mandelbrot set visualization.
             *
             */
            async update(startBlockSize = 128) {
                if (this.rendering) {
                    await this.cancel()
                };
                this.rendering = true;
                // this.setLocked(true)
                this.stats = {
                    ref: 0,
                    calc: 0,
                    guess: 0,
                    approx: 0,
                    time: performance.now()
                };

                let prevDeep = this.deep;
                this.deep = this.size.exp < -300;
                if (prevDeep && !this.deep) this.ref = this.ref.map(e => e.toComplex());

                updateInfoOverlay(this.center.re, this.center.im, new FloatExp(4).div(this.size), this.iterations);
                reInput.value = this.center.re.toString();
                imInput.value = this.center.im.toString();
                zoomInput.value = new FloatExp(4).div(this.size).toString();
                itInput.value = this.iterations;

                this.image = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);

                let base, ref;
                let refLen = 0;

                base = this.center;
                if (!this.refValid) {
                    console.log(performance.now() + " computing reference")
                    let nextTerm;

                    let reportInterval = Math.max(1, Math.floor(200000 / -this.size.exp));

                    const generator = this.deep ?
                        getReferenceOrbitFEMPFR(base, this.size, this.iterations, Math.ceil((-this.size.exp + 10) * 3.321928094887362), reportInterval) :
                        // getReferenceOrbit(base, this.size.doubleValue(), this.iterations, reportInterval);
                        getReferenceOrbitMPFR(base, this.size.doubleValue(), this.iterations, Math.ceil((-this.size.exp + 10) * 3.321928094887362), reportInterval);
                    while (!(nextTerm = await generator.next()).done) {
                        this.stats.ref = nextTerm.value;
                        this.showInfo(); // Update progress
                    }
                    ref = nextTerm.value;
                    this.stats.ref = ref.length;

                    this.ref = ref;
                    this.refValid = true;
                } else {
                    ref = this.ref;
                    this.stats.ref = ref.length;
                }
                refLen = ref.length;
                console.log("ref iter: " + ref.length)

                console.log(performance.now() + " bla calculation")

                if (this.deep) {
                    this.blaTable = createBLATableFE(ref, this.size);
                }
                else
                    this.blaTable = createBLATable(ref, this.size.doubleValue())


                let autoIter = Math.max((refLen - 1) * 32, this.iterations);
                this.setIterations(autoIter);

                console.log(performance.now() + " perturbation")

                // let workerRef = this.deep ? this.ref.map(e => fExpComplex2Obj(e)) : this.ref.map(e => [e.re, e.im]);
                // let workerBla = this.deep ?
                //     this.blaTable.map(e => e.map(e2 => {
                //         return { A: fExpComplex2Obj(e2.A), B: fExpComplex2Obj(e2.B), radius: fExp2Obj(e2.radius) }
                //     }))
                //     : this.blaTable.map(e => e.map(e2 => {
                //         return { A: [e2.A.re, e2.A.im], B: [e2.B.re, e2.B.im], radius: e2.radius }
                //     }))

                // for (let i = 0; i < this.workers.length; i++) {
                //     this.workers[i].postMessage({
                //         type: 'ref',
                //         ref: workerRef,
                //         bla: workerBla,
                //         deep: this.deep
                //     });
                // }

                // let p1 = () => {
                //     return new Promise(async (r, j) => {
                //         this.counter = 0;
                //         this.workerCounter = 0;
                //         this.resolveFunc = r;
                //         this.drawState = 0;

                //         // Êî∂ÈõÜÊâÄÊúâÈúÄË¶ÅËÆ°ÁÆóÁöÑdeltas
                //         let allDeltas = [];
                //         for (let y = 0; y < this.canvas.height; y += 2) {
                //             for (let x = 0; x < this.canvas.width; x += 2) {
                //                 if (this.iterMap[y][x] > 0) {
                //                     this.setIter(x, y, this.iterMap[y][x]);
                //                     this.stats.guess++;
                //                     continue;
                //                 }
                //                 // ËÆ°ÁÆóÂπ∂Êî∂ÈõÜdelta
                //                 let delta = this.getDelta(x, y);
                //                 allDeltas.push([delta.re, delta.im, x, y]);
                //             }
                //         }

                //         allDeltas = sortByProximityToCenterPixel(allDeltas, this.canvas.width, this.canvas.height); // ÊåâÁÖßË∑ùÁ¶ª‰∏≠ÂøÉÁÇπÊéíÂ∫è

                //         // Â∞ÜdeltasÂùáÂàÜÂà∞ÊØè‰∏™Ê†∏ÂøÉ
                //         const chunkSize = 64 * 64;
                //         const chunks = Math.ceil(allDeltas.length / chunkSize);
                //         for (let i = 0; i < chunks; i++) {
                //             const start = i * chunkSize;
                //             const end = start + chunkSize;
                //             const deltasChunk = allDeltas.slice(start, end);
                //             if (deltasChunk.length === 0) continue; // Ë∑≥ËøáÁ©∫Êï∞ÊçÆ

                //             const data = {
                //                 type: 'calc',
                //                 deltas: deltasChunk,
                //                 maxIter: this.iterations,
                //                 bailout: this.bailout,
                //                 smooth: this.smooth
                //             };

                //             // ËΩÆËØ¢ÂàÜÈÖçWorker
                //             const workerIndex = this.workerCounter % CPU_CORES;
                //             this.workers[workerIndex].postMessage(data);
                //             this.counter++; // ËøΩË∏™ÂèëÈÄÅÁöÑ‰ªªÂä°ÊÄªÊï∞
                //             this.workerCounter++;
                //         }

                //         if (this.counter <= 0) {
                //             this.resolveFunc();
                //         }
                //     });
                // };

                // let p2 = () => {
                //     return new Promise(async (r, j) => {

                //         this.counter = 0;
                //         this.workerCounter = 0;
                //         this.resolveFunc = r;
                //         this.drawState = 1;

                //         // Êî∂ÈõÜÊâÄÊúâÈúÄË¶ÅËÆ°ÁÆóÁöÑdeltas
                //         let allDeltas = [];
                //         for (let y = 0; y < this.canvas.height; y += 2) {
                //             for (let x = 1; x < this.canvas.width; x += 2) {
                //                 if (this.iterMap[y][x] > 0) {
                //                     this.setIter(x, y, this.iterMap[y][x])
                //                     this.stats.guess++;
                //                     continue
                //                 }
                //                 let leftColor = this.getIter(x - 1, y);
                //                 let rightColor = this.getIter(x + 1, y);
                //                 if (Math.floor(leftColor) == Math.floor(rightColor) && leftColor >= 0 && rightColor >= 0) {
                //                     this.setIter(x, y, (leftColor + rightColor) / 2);
                //                     this.stats.guess++;
                //                 } else {
                //                     let delta = this.getDelta(x, y);
                //                     allDeltas.push([delta.re, delta.im, x, y]);
                //                 }
                //             }
                //         }

                //         allDeltas = sortByProximityToCenterPixel(allDeltas, this.canvas.width, this.canvas.height);

                //         // Â∞ÜdeltasÂùáÂàÜÂà∞ÊØè‰∏™Ê†∏ÂøÉ
                //         const chunkSize = 64 * 64;
                //         const chunks = Math.ceil(allDeltas.length / chunkSize);
                //         for (let i = 0; i < chunks; i++) {
                //             const start = i * chunkSize;
                //             const end = start + chunkSize;
                //             const deltasChunk = allDeltas.slice(start, end);
                //             if (deltasChunk.length === 0) continue; // Ë∑≥ËøáÁ©∫Êï∞ÊçÆ

                //             const data = {
                //                 type: 'calc',
                //                 deltas: deltasChunk,
                //                 maxIter: this.iterations,
                //                 bailout: this.bailout,
                //                 smooth: this.smooth
                //             };

                //             // ËΩÆËØ¢ÂàÜÈÖçWorker
                //             const workerIndex = this.workerCounter % CPU_CORES;
                //             this.workers[workerIndex].postMessage(data);
                //             this.counter++; // ËøΩË∏™ÂèëÈÄÅÁöÑ‰ªªÂä°ÊÄªÊï∞
                //             this.workerCounter++;
                //         }

                //         if (this.counter <= 0) {
                //             this.resolveFunc();
                //         }
                //     })
                // }

                // let p3 = () => {
                //     return new Promise(async (r, j) => {
                //         this.counter = 0;
                //         this.workerCounter = 0;
                //         this.resolveFunc = r;
                //         this.drawState = 2;

                //         let allDeltas = [];
                //         for (let y = 1; y < this.canvas.height; y += 2) {
                //             for (let x = 0; x < this.canvas.width; x++) {
                //                 if (this.iterMap[y][x] != 0) {
                //                     this.setIter(x, y, this.iterMap[y][x])
                //                     this.stats.guess++;
                //                     continue
                //                 }

                //                 let upColor = this.getIter(x, y - 1);
                //                 let downColor = this.getIter(x, y + 1);
                //                 if (Math.floor(upColor) == Math.floor(downColor) && upColor >= 0 && downColor >= 0) {
                //                     this.setIter(x, y, (upColor + downColor) / 2);
                //                     this.stats.guess++;
                //                 } else {
                //                     let delta = this.getDelta(x, y);
                //                     allDeltas.push([delta.re, delta.im, x, y]);
                //                 }
                //             }
                //         }

                //         allDeltas = sortByProximityToCenterPixel(allDeltas, this.canvas.width, this.canvas.height);

                //         // Â∞ÜdeltasÂùáÂàÜÂà∞ÊØè‰∏™Ê†∏ÂøÉ
                //         const chunkSize = 64 * 64;
                //         const chunks = Math.ceil(allDeltas.length / chunkSize);
                //         for (let i = 0; i < chunks; i++) {
                //             const start = i * chunkSize;
                //             const end = start + chunkSize;
                //             const deltasChunk = allDeltas.slice(start, end);
                //             if (deltasChunk.length === 0) continue; // Ë∑≥ËøáÁ©∫Êï∞ÊçÆ

                //             const data = {
                //                 type: 'calc',
                //                 deltas: deltasChunk,
                //                 maxIter: this.iterations,
                //                 bailout: this.bailout,
                //                 smooth: this.smooth
                //             };

                //             // ËΩÆËØ¢ÂàÜÈÖçWorker
                //             const workerIndex = this.workerCounter % CPU_CORES;
                //             this.workers[workerIndex].postMessage(data);
                //             this.counter++; // ËøΩË∏™ÂèëÈÄÅÁöÑ‰ªªÂä°ÊÄªÊï∞
                //             this.workerCounter++;
                //         }

                //         if (this.counter <= 0) {
                //             this.resolveFunc();
                //         }
                //     })
                // }

                // await p1();
                // await p2();
                // await p3();

                await this.successiveRefinment(startBlockSize);
                await this.finalPass();

                // Distance estimation
                if (this.distanceEstimation) {
                    for (let y = 0; y < this.canvas.height - 1; y++) {
                        for (let x = 0; x < this.canvas.width - 1; x++) {
                            let gradX = this.iterMap[y][x + 1] - this.iterMap[y][x];
                            let gradY = this.iterMap[y + 1][x] - this.iterMap[y][x];
                            let diff = Math.sqrt(gradX * gradX + gradY * gradY);

                            let j = (y * this.canvas.width + x) << 2;

                            let color = getColor(Math.log1p(diff) * 32 / colorStep, 10000);

                            this.image.data[j] = color[0]
                            this.image.data[j + 1] = color[1]
                            this.image.data[j + 2] = color[2]
                            this.image.data[j + 3] = 255
                        }
                    }
                    this.context.putImageData(this.image, 0, 0)
                }

                console.log('done!')
                this.rendering = false;
                this.showInfo();
                const params = new URLSearchParams(window.location.hash.substring(1));

                // Êõ¥Êñ∞ÊàñÊ∑ªÂä†Êñ∞ÁöÑÂèÇÊï∞
                params.set("rec", compressDecimal(this.center.re.toString()));
                params.set("imc", compressDecimal(this.center.im.toString()));
                params.set("zmc", compressDecimal(new FloatExp(4).div(this.size).toString()));
                params.set("itc", compressDecimal(this.iterations.toString()));
                params.set("bailout", Math.sqrt(this.bailout).toString());
                params.set("colorc", byteArrayToBase64(palette.flat(1)));
                params.set("colorstep", colorStep);
                params.set("smooth", this.smooth ? 1 : 0);

                // ÈáçÂª∫ÂìàÂ∏åÂ≠óÁ¨¶‰∏≤
                window.location.hash = params.toString();

                // this.setLocked(false)
            }

            async successiveRefinment(startSize) {
                let step = startSize;

                // Initial refinement (Center-out applied here too)
                await this.calculateRegion(0, 0, step, step, step, step);

                // Loop to progressively refine
                while (step > 2) {
                    let halfStep = step >> 1;

                    // Refine quadrants
                    // Áî±‰∫é calculateRegion Áé∞Âú®Â∑≤ÁªèÊòØ‰∏≠ÂøÉÊâ©Êï£‰∫ÜÔºåËøôÈáåÁöÑÈ°∫Â∫èÂÖ∂ÂÆû‰∏çÂ§™ÈáçË¶Å‰∫Ü
                    // ‰ΩÜ‰∏∫‰∫Ü‰øùÊåÅÈÄªËæëÔºåÊàë‰ª¨‰æùÁÑ∂Âπ∂Ë°åÂ§ÑÁêÜ‰∏§‰∏™ÂÅèÁßªÂ±Ç
                    await this.calculateRegion(halfStep, 0, step, step, halfStep, step);
                    await this.calculateRegion(0, halfStep, halfStep, step, halfStep, halfStep);

                    step = halfStep;
                }
            }

            /**
             * ‰ºòÂåñÂêéÁöÑÂå∫ÂüüËÆ°ÁÆóÔºö‰ªéÂ±èÂπï‰∏≠ÂøÉÂêëÂ§ñÂëàÊñπÂΩ¢Êâ©Êï£Ê∏≤Êüì
             * Á©∫Èó¥Â§çÊùÇÂ∫¶: O(1) - ‰∏çÈúÄË¶ÅÈ¢ÑÂ≠òÂùêÊ†áÊï∞ÁªÑ
             */
            async calculateRegion(startX, startY, stepX, stepY, drawWidth, drawHeight) {
                if (this.requestForCancel) {
                    this.cancelling = true;
                    return;
                }

                const width = this.canvas.width;
                const height = this.canvas.height;

                // 1. ËÆ°ÁÆóÁõ∏ÂØπ‰∫éÁΩëÊ†ºÁöÑ‰∏≠ÂøÉÁÇπ
                // Êàë‰ª¨ÈúÄË¶ÅÊâæÂà∞ÊúÄÊé•ËøëÂ±èÂπïÁâ©ÁêÜ‰∏≠ÂøÉÁöÑÈÇ£‰∏™ grid ÁÇπ (startX + n * stepX)
                const screenCX = width / 2;
                const screenCY = height / 2;

                // ËÆ°ÁÆó‰∏≠ÂøÉÁÇπÂú® Grid ‰∏≠ÁöÑÁ¥¢ÂºïÂÅèÁßª (Index Offset)
                const centerIdxX = Math.floor((screenCX - startX) / stepX);
                const centerIdxY = Math.floor((screenCY - startY) / stepY);

                // ËÆ°ÁÆó Grid ‰∏≠ÂøÉÁöÑÂÆûÈôÖÂÉèÁ¥†ÂùêÊ†á
                const gridCenterX = startX + centerIdxX * stepX;
                const gridCenterY = startY + centerIdxY * stepY;

                // 2. ËÆ°ÁÆóÊúÄÂ§ßÂçäÂæÑÔºàÊ≠•Êï∞ÔºâÔºåÂè™ÈúÄË¶ÜÁõñÊúÄËøúÁöÑÈÇ£‰∏™ËßíÂç≥ÂèØ
                // ËøôÈáåÁöÑÂçäÂæÑ r ÊòØÊåá‚ÄúË∑ùÁ¶ª‰∏≠ÂøÉÁöÑÊ≠•Êï∞‚Äù
                const maxStepsX = Math.max(centerIdxX, Math.ceil((width - gridCenterX) / stepX));
                const maxStepsY = Math.max(centerIdxY, Math.ceil((height - gridCenterY) / stepY));
                const maxRadius = Math.max(maxStepsX, maxStepsY);

                // ÂÆö‰πâÂ§ÑÁêÜÂçïÁÇπÁöÑÈÄªËæë (ÈÅøÂÖç‰ª£Á†ÅÈáçÂ§ç)
                const processPoint = (x, y) => {
                    if (x < 0 || x >= width || y < 0 || y >= height) return; // Ë∂äÁïåÊ£ÄÊü•

                    if (this.iterMap[y][x] > 0) {
                        this.setIter(x, y, this.iterMap[y][x]);
                        this.stats.guess++;
                    } else {
                        this.calculatePixel(x, y, drawWidth, drawHeight);
                    }
                };

                // 3. Ê†∏ÂøÉÂæ™ÁéØÔºöÊåâÂçäÂæÑ r ‰ªé 0 ÂºÄÂßãÂêëÂ§ñÊâ©Êï£
                for (let r = 0; r <= maxRadius; r++) {

                    if (r === 0) {
                        // ÁâπÊÆäÂ§ÑÁêÜÔºö‰∏≠ÂøÉÁÇπ
                        processPoint(gridCenterX, gridCenterY);
                    } else {
                        // ÊØèÊ¨°Âæ™ÁéØÂ§ÑÁêÜ‰∏Ä‰∏™Áü©ÂΩ¢ÁéØ (Ring)
                        // ‰∏äËæπ (Top Edge) Âíå ‰∏ãËæπ (Bottom Edge)
                        // Â∑¶Âè≥Ëæπ (Left Edge) Âíå Âè≥Ëæπ (Right Edge)

                        const currentStepX = r * stepX;
                        const currentStepY = r * stepY;

                        // È¢ÑËÆ°ÁÆóÂΩìÂúàÁöÑËæπÁïåÂùêÊ†á
                        const topY = gridCenterY - currentStepY;
                        const bottomY = gridCenterY + currentStepY;
                        const leftX = gridCenterX - currentStepX;
                        const rightX = gridCenterX + currentStepX;

                        // --- ÁªòÂà∂‰∏ä‰∏ãËæπ ---
                        // x ËåÉÂõ¥‰ªé leftX Âà∞ rightX
                        // Ê≥®ÊÑèÔºö‰∏∫‰∫Ü‰∏çÈáçÂ§çÁªòÂà∂Âõõ‰∏™ËßíÔºåÊàë‰ª¨ËÆ©‰∏ä‰∏ãËæπÂåÖÂê´ËßíÔºåÂ∑¶Âè≥Ëæπ‰∏çÂåÖÂê´Ëßí
                        for (let x = leftX; x <= rightX; x += stepX) {
                            processPoint(x, topY);    // ‰∏äËæπ
                            processPoint(x, bottomY); // ‰∏ãËæπ
                        }

                        // --- ÁªòÂà∂Â∑¶Âè≥Ëæπ ---
                        // y ËåÉÂõ¥‰ªé topY + stepY Âà∞ bottomY - stepY (ÈÅøÂºÄËßí)
                        for (let y = topY + stepY; y <= bottomY - stepY; y += stepY) {
                            processPoint(leftX, y);   // Â∑¶Ëæπ
                            processPoint(rightX, y);  // Âè≥Ëæπ
                        }
                    }

                    // ÊØè‰∏ÄÂúàÊàñËÄÖÊØèÈöîÂá†ÂúàÂ∞ùËØïÊõ¥Êñ∞‰∏ÄÊ¨°Â±èÂπï
                    // ËøôÊ†∑Áî®Êà∑‰ºöÁúãÂà∞‰∏Ä‰∏™‰ªé‰∏≠ÂøÉÊîæÂ§ßÁöÑÊñπÊ°ÜÂä®Áîª
                    await this.tryUpdateScreen();

                    if (this.requestForCancel) {
                        this.cancelling = true;
                        return;
                    }
                }
            }

            async tryUpdateScreen() {
                let currentTime = performance.now();
                if (currentTime - this.lastUpdateTime < 100) {
                    return; // Skip update if less than 100ms since last update
                }
                this.showInfo();
                this.updateProgress();
                this.context.putImageData(this.image, 0, 0);
                await delay(10); // Allow UI to update
                this.lastUpdateTime = currentTime;
            }

            async finalPass() {
                if (this.requestForCancel) {
                    this.cancelling = true;
                    return;
                }

                for (let y = 0; y < this.canvas.height; y += 2) {
                    for (let x = 1; x < this.canvas.width; x += 2) {
                        if (this.iterMap[y][x] > 0) {
                            this.setIter(x, y, this.iterMap[y][x])
                            this.stats.guess++;
                            continue
                        }
                        let leftColor = this.getIter(x - 1, y);
                        let rightColor = this.getIter(x + 1, y);
                        if (Math.floor(leftColor) == Math.floor(rightColor) && leftColor >= 0 && rightColor >= 0) {
                            this.setIter(x, y, (leftColor + rightColor) / 2);
                            this.stats.guess++;
                        } else {
                            this.calculatePixel(x, y, 1, 2);
                        }
                    }
                    await this.tryUpdateScreen();
                    if (this.requestForCancel) {
                        this.cancelling = true;
                        return;
                    }

                }


                for (let y = 1; y < this.canvas.height; y += 2) {
                    for (let x = 0; x < this.canvas.width; x++) {
                        if (this.iterMap[y][x] != 0) {
                            this.setIter(x, y, this.iterMap[y][x])
                            this.stats.guess++;
                            continue
                        }

                        let upColor = this.getIter(x, y - 1);
                        let downColor = this.getIter(x, y + 1);
                        if (Math.floor(upColor) == Math.floor(downColor) && upColor >= 0 && downColor >= 0) {
                            this.setIter(x, y, (upColor + downColor) / 2);
                            this.stats.guess++;
                        } else {
                            this.calculatePixel(x, y);
                        }
                    }
                    await this.tryUpdateScreen();
                    if (this.requestForCancel) {
                        this.cancelling = true;
                        return;
                    }

                }

            }


            calculatePixel(x, y, drawWidth, drawHeight) {
                let delta = this.getDelta(x, y);
                let iter = this.deep ?
                    getPTBLAFE(
                        delta,
                        this.ref,
                        this.blaTable,
                        this.iterations,
                        this.bailout,
                        this.smooth
                    ) :
                    getPTBLA(
                        delta,
                        this.ref,
                        this.blaTable,
                        this.iterations,
                        this.bailout,
                        this.smooth
                    );

                this.setIter(x, y, iter, drawWidth, drawHeight);
                this.stats.calc++;
            }

            async cancel() {
                this.requestForCancel = true;
                while (true) {
                    if (this.cancelling) break;
                    await delay(100); // wait for cancellation to complete
                }
                this.cancelling = false;
                this.requestForCancel = false;
            }

            /**
             * Recolorize the Mandelbrot set visualization without recalculating.
             */

            recolorize() {
                this.image = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
                for (let y = 0; y < this.canvas.height; y++) {
                    for (let x = 0; x < this.canvas.width; x++) {
                        let it = this.iterMap[y][x];
                        if (it >= 0) {
                            let color = getColor(it, this.iterations);
                            let i = (y * this.canvas.width + x) << 2;
                            this.image.data[i] = color[0];
                            this.image.data[i + 1] = color[1];
                            this.image.data[i + 2] = color[2];
                            this.image.data[i + 3] = 255;
                        }
                    }
                }
                this.context.putImageData(this.image, 0, 0);
            }


            /**
             * Initiates the download of the Mandelbrot set visualization as a PNG image.
             */
            download() {
                const downloadLink = document.createElement('a');

                downloadLink.href = canvas.toDataURL('image/png');
                downloadLink.download = 'mandelbrot.png';

                downloadLink.click();
            }

            /**
             * Increases the number of iterations for the Mandelbrot set visualization.
             * @param {number} mul - The multiplier for increasing the iterations.
             */
            increaseIteration(mul) {
                let prevIter = this.iterations;
                this.setIterations(this.iterations * mul);

                for (let y = 0; y < this.canvas.height; y++) {
                    for (let x = 0; x < this.canvas.width; x++) {
                        if (this.iterMap[y][x] >= prevIter) {
                            this.setIter(x, y, 0)
                        }
                    }
                }
                this.update()
            }

            async renderFrames() {
                let frames = [];
                let refreshRef = false;
                this.videoRendering = true;
                while (this.size.doubleValue() < 32) {
                    await this.update();
                    let url = canvas.toDataURL('image/png');
                    let img = document.createElement('img');
                    img.src = url;
                    frames.push({ frame: img, scale: this.size });
                    this.zoomOut();
                    if (this.size.exp > -20 && !refreshRef) {
                        this.center = new DeepComplex(
                            new Decimal(this.center.re.toPrecision(30)),
                            new Decimal(this.center.im.toPrecision(30))
                        )
                        this.refValid = false;
                        this.iterations = 256;
                        refreshRef = true;
                    }
                }
                this.videoRendering = false;
                return frames.reverse();
            }
        }

        class KFRReader {
            constructor(arrayBuffer) {
                this.buffer = arrayBuffer;
                this.content = new TextDecoder().decode(arrayBuffer); // Decode ArrayBuffer to string
                this.data = this.parseContent(); // Parse key-value pairs
            }

            // Parse content line by line into key-value pairs
            parseContent() {
                const result = {};
                const lines = this.content.split(/\r?\n/); // Split into lines
                lines.forEach(line => {
                    const [key, value] = line.split(":").map(part => part.trim());
                    if (key && value !== undefined) {
                        result[key] = value;
                    }
                });
                return result;
            }

            // Getter for `Re`
            get re() {
                return this.data.Re;
            }

            // Getter for `Im`
            get im() {
                return this.data.Im;
            }

            // Getter for `Zoom`
            get zoom() {
                return this.data.Zoom;
            }

            // Getter for `Iterations`
            get iter() {
                return parseInt(this.data.Iterations, 10);
            }

            // Getter for `IterDiv`
            get iterDiv() {
                return parseFloat(this.data.IterDiv) ?? 1;
            }

            get smooth() {
                return this.data.Smooth !== undefined && this.data.Smooth !== "0";
            }

            // Getter for `Colors`, converts the raw color data into an array of [r, g, b] tuples
            get colors() {
                if (!this.data.Colors) return [];
                const colorValues = this.data.Colors.split(",").slice(0, -1).map(Number);
                const rgbArray = [];
                for (let i = 0; i < colorValues.length; i += 3) {
                    rgbArray.push([colorValues[i + 2], colorValues[i + 1], colorValues[i]]);
                }
                return rgbArray;
            }
        }

        class KFRWriter {
            constructor() {
                this.data = {};
            }

            // Setters for `Re`, `Im`, `Zoom`, `Iterations`, `IterDiv`, and `Colors`
            set re(value) {
                this.data.Re = value;
            }

            set im(value) {
                this.data.Im = value;
            }

            set zoom(value) {
                this.data.Zoom = value;
            }

            set iter(value) {
                this.data.Iterations = value;
            }

            set iterDiv(value) {
                this.data.IterDiv = value;
            }

            set colors(value) {
                this.data.Colors = value.map(color => {
                    // convert each color to BGR format
                    return `${color[2]},${color[1]},${color[0]},`;
                }).join("");
            }

            set smooth(value) {
                this.data.Smooth = value ? "1" : "0";
            }

            // Convert the data to a KFR formatted string
            toString() {
                return Object.entries(this.data)
                    .map(([key, value]) => `${key}: ${value}`)
                    .join("\r\n");
            }

            load(mandelbrot) {
                this.re = mandelbrot.center.re.toString();
                this.im = mandelbrot.center.im.toString();
                let zoom = new FloatExp(4).div(mandelbrot.size);
                this.zoom = `${zoom.base}E${zoom.exp}`;
                this.iter = mandelbrot.iterations.toString();
                this.iterDiv = (colorStep * palette.length) / 1024
                this.colors = palette;
                this.smooth = mandelbrot.smooth;
            }
        }

        const dict = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz123456789'
        function b58Compress(n, pad = true) {
            if (n == 0) return '0'

            // Detect 7 same digits
            let str = n.toString();
            let same = str.split('').every((v, i, a) => v === a[0]) && str.length === 7;
            if (same) {
                let digit = str[0];
                return "I" + digit;
            }

            let b58 = [];
            while (n > 0) {
                b58.push(dict[n % 58]);
                n = Math.floor(n / 58);
            }
            let result = b58.reverse().join("");
            if (pad) result = result.padStart(4, 'A')
            return result;
        }

        function b58Decompress(b58, pad = true) {
            let n = 0;
            let i = 0;
            for (let i = 0; i < b58.length; i++) {
                const char = b58[i];
                n *= 58
                let index = dict.indexOf(char)
                if (index === -1) {
                    throw new Error("Invalid character")
                }
                n += index
            }
            let result = n.toString()
            if (pad) result = result.padStart(7, '0');
            return result
        }

        function compressInteger(str) {
            let hasSign = str[0] === '+' || str[0] === '-';

            let i = 0;
            let builder = []

            if (hasSign) {
                builder.push(str[0] === '+' ? '' : '-');
                i++;
            }

            while (i < str.length) {
                let part = str.slice(i, i + 7);
                let compressed = b58Compress(parseInt(part), part.length === 7)
                builder.push(compressed);
                i += 7;
            }
            return builder.join("")
        }

        function compressDecimal(str) {
            let [mant, exp] = str.toLowerCase().split('e');
            let [dec, frac] = mant.split(".");

            let result = compressInteger(dec)
            if (frac) {
                result += "." + compressInteger(frac);
            }
            if (exp) {
                let expCompressed = compressInteger(exp)
                sign = (expCompressed[0] === '-') ? '' : '_';
                result += sign + expCompressed;
            }

            return result
        }

        function decompressInteger(str) {
            let hasSign = str[0] === '_' || str[0] === '-';

            let i = 0;
            let builder = []

            if (hasSign) {
                builder.push(str[0] === '_' ? '' : '-');
                i++;
            }

            while (i < str.length) {
                if (str[i] === '0') {
                    builder.push("0000000");
                    i++;
                } else if (str[i] === 'I') {
                    let digit = str[i + 1];
                    builder.push(digit.repeat(7));
                    i += 2;
                }
                else {
                    let part = str.slice(i, i + 4);
                    let decompressed = b58Decompress(part, part.length === 4)
                    builder.push(decompressed);
                    i += 4;
                }
            }
            return builder.join("")
        }

        function decompressDecimal(str) {
            let mant, exp;
            let result = '', sign = '';
            str = str.trim();
            if (str.startsWith("_")) {
                mant = str.slice(1)
                sign = ''
            }
            else if (str.startsWith("-")) {
                mant = str.slice(1)
                sign = '-'
            }
            else {
                mant = str;
            }

            let expsign = '';
            if (mant.includes('-')) {
                [mant, exp] = mant.split('-')
                expsign = '-'
            }
            else if (mant.includes('_')) {
                [mant, exp] = mant.split('_')
            }

            let int, frac;
            [int, frac] = mant.split('.')
            result += sign + decompressInteger(int);

            if (frac && frac != '') result += '.' + decompressInteger(frac);

            if (exp && exp != '') {
                result += "e" + expsign + decompressInteger(exp)
            }

            return result;
        }


        function formatLongString(str, len = 40, pre = 20, suf = 20) {
            const s = str.toString();
            if (s.length > len) {
                return s.substring(0, pre) + '...' + s.substring(s.length - suf);
            }
            return s;
        }

        function updateInfoOverlay(re, im, zoom, iter) {
            document.getElementById('info-re').textContent = formatLongString(re);
            document.getElementById('info-im').textContent = formatLongString(im);
            document.getElementById('info-zoom').textContent = formatLongString(zoom.toString());
            document.getElementById('info-iter').textContent = iter;
        }


        let c = new DeepComplex(
            new Decimal(0), new Decimal(0));

        let size = new FloatExp(4);
        let bailout = 2;
        let iterations = 256;
        let smooth = false;

        const params = new URLSearchParams(window.location.hash.substring(1));

        params.forEach((value, key) => {
            switch (key) {

                // readable values
                case "re":
                    c.re = new Decimal(value);
                    params.delete(key);
                    break;
                case "im":
                    c.im = new Decimal(value);
                    params.delete(key);
                    break;
                case "zoom":
                    size = new FloatExp(4).div(getFloatExp(value));
                    params.delete(key);
                    break;
                case "iter":
                    iterations = parseInt(value);
                    params.delete(key);
                    break;
                case "bailout":
                    bailout = parseFloat(value);
                    params.delete(key);
                    break;
                case "colors":
                    palette = groupArray(value.split(",").map(e => parseInt(e)))
                    params.delete(key);
                    break;
                case "colorstep":
                    colorStep = parseFloat(value)
                    break;
                case "smooth":
                    smooth = value === "1" || value === "true";
                    break;

                // compressed values
                case "rec":
                    c.re = new Decimal(decompressDecimal(value));
                    break;
                case "imc":
                    c.im = new Decimal(decompressDecimal(value));
                    break;
                case "zmc":
                    size = new FloatExp(4).div(parseFloatExp(decompressDecimal(value)));
                    break;
                case "itc":
                    iterations = parseInt(decompressDecimal(value));
                    break;
                case "colorc":
                    palette = groupArray(base64ToByteArray(value));
                    break;
            }
        });
        location.hash = params.toString();

        const mandelbrot = new Mandelbrot(canvas, c, iterations, bailout)
        mandelbrot.smooth = smooth;
        mandelbrot.zoom(size)
        mandelbrot.update()


        document.getElementById('menu-toggle').addEventListener('click', () => {
            document.getElementById('sidebar').classList.toggle('open');
        });

        document.getElementById('info-overlay').addEventListener('click', () => {
            document.getElementById('info-overlay').classList.toggle('info-overlay-collapsed');
        });


        document.getElementById('goto').addEventListener('click', e => {
            mandelbrot.goto(new DeepComplex(
                new Decimal(reInput.value),
                new Decimal(imInput.value)
            ))

            mandelbrot.zoom(new FloatExp(4).div(parseFloatExp(zoomInput.value)));
            mandelbrot.setIterations(parseInt(itInput.value));

            mandelbrot.update();
        })

        document.getElementById('home').addEventListener('click', e => {
            mandelbrot.home()
            mandelbrot.update()
        })

        document.getElementById('download').addEventListener('click', e => {
            mandelbrot.download()
        })

        sampleLoadBtn.addEventListener('click', e => {
            const loc = samples[sampleSelect.value]
            mandelbrot.goto(new DeepComplex(
                new Decimal(loc.re), new Decimal(loc.im)
            ))
            mandelbrot.zoom(new FloatExp(4).div(getFloatExp(loc.zoom)));
            mandelbrot.setIterations(loc.it);
            mandelbrot.update()
        })


        document.getElementById('zoom-in').addEventListener('click', function () {
            mandelbrot.zoom(mandelbrot.size.div(2)); // Changed to 2x for consistency with wheel
            mandelbrot.update();
        });

        document.getElementById('zoom-out').addEventListener('click', function () {
            mandelbrot.zoom(mandelbrot.size.mul(2)); // Changed to 2x
            mandelbrot.update();
        });

        document.getElementById('increase-iter').addEventListener('click', function () {
            mandelbrot.increaseIteration(2);
            mandelbrot.update();
        });

        document.getElementById('decrease-iter').addEventListener('click', function () {
            mandelbrot.setIterations(mandelbrot.iterations / 2);
            mandelbrot.clear();
            mandelbrot.update()
        });

        // Dynamically create an input element
        const inputElement = document.createElement("input");
        inputElement.type = "file";
        inputElement.accept = ".kfr"; // Accept only .kfr files
        inputElement.style.display = "none";

        // Append the input element to the document
        document.body.appendChild(inputElement);

        // Trigger file upload when a button is clicked
        document.getElementById("kfr").addEventListener('click', () => {
            inputElement.click(); // Simulate a click on the input element
        });

        document.getElementById("save-kfr").addEventListener('click', () => {
            const writer = new KFRWriter();
            writer.load(mandelbrot);
            const kfrContent = writer.toString();

            // Create a Blob from the KFR content
            const blob = new Blob([kfrContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);

            // Create a link to download the file
            const a = document.createElement('a');
            a.href = url;
            a.download = `mandelbrot-${new Date().toISOString()}.kfr`; // Set the desired file name
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });

        // Handle file selection
        inputElement.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) {
                alert("No file selected!");
                return;
            }

            // Ensure the file is a .kfr file
            if (!file.name.endsWith('.kfr')) {
                alert("Please upload a valid .kfr file.");
                return;
            }

            // Read the file as an ArrayBuffer
            const arrayBuffer = await file.arrayBuffer();

            // Parse the .kfr file using KFRReader
            const reader = new KFRReader(arrayBuffer);

            mandelbrot.goto(new DeepComplex(reader.re, reader.im))
            mandelbrot.zoom(new FloatExp(4).div(parseFloatExp(reader.zoom)));
            mandelbrot.setIterations(reader.iter);
            mandelbrot.smooth = reader.smooth;
            palette = reader.colors;
            colorStep = 1024 / reader.colors.length * reader.iterDiv;
            mandelbrot.update();
        });

        // Trigger file upload when a button is clicked
        document.getElementById("makeVideo").addEventListener('click', async () => {
            const keyFrames = await mandelbrot.renderFrames();
            console.log(keyFrames);

            const stream = canvas.captureStream();
            const recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=h264', videoBitsPerSecond: 10000000 });
            const data = [];
            recorder.ondataavailable = function (event) {
                if (event.data && event.data.size) {
                    data.push(event.data);
                }
            };
            recorder.onstop = () => {
                const url = URL.createObjectURL(new Blob(data, { type: 'video/webm' }));
                console.log('video url', url)
                var a = document.createElement('a');
                a.download = 'file.webm';
                a.href = url;
                a.click();

            };

            let indexFl = 0;
            let ctx = canvas.getContext('2d')

            ctx.font = 'bold 26px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;

            const renderer = () => {
                // Ensure `keyFrames` array is defined and has elements
                if (!keyFrames || keyFrames.length < 2) {
                    console.error("keyFrames array is either undefined or contains fewer than 2 frames.");
                    recorder.stop();
                    return;
                }

                // Calculate indices and verify bounds
                let i = Math.floor(indexFl);
                if (i < 0 || i + 1 >= keyFrames.length) {
                    recorder.stop();
                    return;
                }

                // Get the two images for the transition
                const image1 = keyFrames[i].frame;
                const image2 = keyFrames[i + 1].frame;

                // Calculate scaling factors
                const decimalPart = indexFl - i; // Fractional part of the index
                const scale1 = Math.pow(2, decimalPart); // Scale for image1
                const scale2 = scale1 * .5; // Scale for image2 (fixed at half size)

                // Clear canvas (assuming canvas context is `ctx`)
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw image1 at center with scaling factor `scale1`
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;

                ctx.drawImage(image1,
                    centerX - canvas.width * scale1 / 2,
                    centerY - canvas.height * scale1 / 2,
                    canvas.width * scale1,
                    canvas.width * scale1
                );


                ctx.drawImage(image2,
                    centerX - canvas.width * scale2 / 2,
                    centerY - canvas.height * scale2 / 2,
                    canvas.width * scale2,
                    canvas.width * scale2
                );

                more.innerText = indexFl.toFixed(2);

                const scale = new FloatExp(4).div(keyFrames[i].scale);
                const currScale = FloatExp.fromLog2(scale.log2Value() + decimalPart);

                let zoomText;
                if (currScale.exp < 7) {
                    zoomText = currScale.doubleValue().toFixed(2);
                } else zoomText = `${currScale.base.toFixed(2)}E${currScale.exp}`

                ctx.fillText(zoomText, 8, 8)
                ctx.strokeText(zoomText, 8, 8)

                // Increment index for the next frame
                indexFl += 1 / 60;

                // Loop `renderer` to maintain animation (assuming 60fps rendering)
                requestAnimationFrame(renderer);
            };

            // Start the renderer
            recorder.start();
            requestAnimationFrame(renderer);
        });

        function generateRandomPalette(size) {
            const palette = [];
            for (let i = 0; i < size; i++) {
                palette.push([
                    Math.floor(Math.random() * 256),
                    Math.floor(Math.random() * 256),
                    Math.floor(Math.random() * 256)
                ]);
            }
            return palette;
        }

        function hsvToRgb(h, s, v) {
            let r, g, b;
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v, g = t, b = p; break;
                case 1: r = q, g = v, b = p; break;
                case 2: r = p, g = v, b = t; break;
                case 3: r = p, g = q, b = v; break;
                case 4: r = t, g = p, b = v; break;
                case 5: r = v, g = p, b = q; break;
            }
            return [Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)];
        }

        function generateRandomBWPalette(size) {
            const palette = [];
            for (let i = 0; i < size; i++) {
                const phase = i % 4;
                let h, s, v;
                switch (phase) {
                    case 0:
                        // Phase 0: full color: 
                        h = Math.random();
                        s = Math.random() * 0.5 + 0.5;
                        v = Math.random() * 0.25 + 0.75;
                        break;
                    case 1:
                        // Phase 1: darker color
                        h = Math.random();
                        s = Math.random() * 0.5 + 0.5;
                        v = Math.random() * 0.25;
                        break;
                    case 2:
                        // Phase 2: full color
                        h = Math.random();
                        s = Math.random() * 0.5 + 0.5;
                        v = Math.random() * 0.25 + 0.75;
                        break;
                    case 3:
                        // Phase 3: lighter color
                        h = Math.random();
                        s = Math.random() * 0.25;
                        v = Math.random() * 0.25 + 0.75;
                }
                palette.push(hsvToRgb(h, s, v));
            }
            return palette;
        }

        class PaletteEditor {
            constructor() {
                this.dialog = document.getElementById('palette-dialog');
                this.colorList = document.getElementById('color-list');
                this.applyButton = document.getElementById('apply-colors');
                this.randomButton = document.getElementById('random-colors');
                this.resetButton = document.getElementById('reset-colors');
                this.closeButton = document.getElementById('close-dialog');
                this.colorStepInput = document.getElementById('color-step');
                this.init();
            }

            init() {
                this.applyButton.addEventListener('click', () => {
                    this.applyColors();
                });

                this.randomButton.addEventListener('click', () => {
                    const algorithm = this.getAlgorithm();
                    switch (algorithm) {
                        case 'random':
                            palette = generateRandomPalette(palette.length); // Generate a random palette with the same length
                            break;
                        case 'random-bw':
                            palette = generateRandomBWPalette(palette.length); // Generate a random black and white palette
                            break;

                    }
                    // palette = generateRandomPalette(palette.length); // Generate a random palette with 10 colors
                    this.renderColors();
                });

                this.resetButton.addEventListener('click', () => {
                    palette = defaultPalette; // Reset to the default palette
                    this.renderColors();
                });

                this.closeButton.addEventListener('click', () => {
                    this.dialog.close();
                });

                this.colorStepInput.addEventListener('input', (e) => {
                    colorStep = parseFloat(e.target.value);
                });

                this.renderColors();
            }

            renderColors() {
                this.colorList.innerHTML = ''; // Clear existing colors
                palette.forEach((color, index) => {
                    const li = document.createElement('li');
                    li.classList.add('color-item');
                    const label = document.createElement('label');
                    label.textContent = `${index + 1} `;
                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.value = `#${color.map(c => c.toString(16).padStart(2, '0')).join('')}`;
                    colorInput.dataset.index = index;
                    const removeColorButton = document.createElement('button');
                    removeColorButton.classList.add('icon');
                    removeColorButton.dataset.index = index;
                    removeColorButton.textContent = '-';
                    removeColorButton.addEventListener('click', (e) => {
                        const index = e.target.dataset.index;
                        palette.splice(index, 1); // Remove color from palette
                        this.renderColors(); // Re-render colors
                    });
                    const addColorButton = document.createElement('button');
                    addColorButton.className = 'icon';
                    addColorButton.textContent = '+';
                    addColorButton.dataset.index = index;
                    addColorButton.addEventListener('click', () => {
                        // Add a new black color after the current color
                        palette.splice(index + 1, 0, [0, 0, 0]); // Add black color
                        this.renderColors(); // Re-render colors
                    });
                    li.appendChild(label);
                    li.appendChild(colorInput);
                    li.appendChild(removeColorButton);
                    li.appendChild(addColorButton);
                    this.colorList.appendChild(li);
                });

                this.colorStepInput.value = colorStep; // Set the color step input value
            }

            getAlgorithm() {
                const selectedAlgorithm = document.querySelector('input[name="algorithm"]:checked');
                return selectedAlgorithm ? selectedAlgorithm.value : 'random';
            }

            applyColors() {
                const inputs = this.colorList.querySelectorAll('input[type="color"]');
                palette = Array.from(inputs).map(input => {
                    const color = input.value.slice(1); // Remove the '#' character
                    return [
                        parseInt(color.slice(0, 2), 16),
                        parseInt(color.slice(2, 4), 16),
                        parseInt(color.slice(4, 6), 16)
                    ];
                });
                this.dialog.close();
                mandelbrot.recolorize(); // Recolorize the Mandelbrot set with new colors
            }

            show() {
                this.dialog.showModal();
                this.renderColors();
            }
        }

        const paletteEditor = new PaletteEditor();
        document.getElementById('palette').addEventListener('click', () => {
            paletteEditor.show();
        });

        document.getElementById('iteration-button').addEventListener('click', () => {
            const iterDialog = document.getElementById('iteration-dialog');
            const bailoutInput = document.getElementById('bailout');
            const smoothCheckbox = document.getElementById('smooth');

            bailoutInput.value = Math.sqrt(mandelbrot.bailout);
            smoothCheckbox.checked = mandelbrot.smooth;

            iterDialog.showModal();

            document.getElementById('apply-iter').addEventListener('click', () => {
                mandelbrot.bailout = parseFloat(bailoutInput.value) ** 2;
                mandelbrot.smooth = smoothCheckbox.checked;
                iterDialog.close();
                mandelbrot.clear();
                mandelbrot.update();
            });

            document.getElementById('close-iter-dialog').addEventListener('click', () => {
                iterDialog.close();
            });
        });
    </script>
</body>

</html>