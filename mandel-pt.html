<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="description" content="Infinite deep and fast Mandelbrot set explorer">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mandelbrot Perturbation</title>
    <style>
        :root {
            --theme-color: #ff4081;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: hidden;
            /* Prevent scrollbars */
        }

        #mandelbrot {
            position: fixed;
            top: 0;
            left: 0;
            width: 100dvw;
            height: 100dvh;
            cursor: grab;
            background: repeating-linear-gradient(45deg, var(--theme-color), var(--theme-color) 8px, #000 8px, #000 16px);
            /* For smoother transforms */
            transform-origin: 0 0;
            will-change: transform;
        }

        #mandelbrot:active {
            cursor: grabbing;
        }

        .transition {
            transition: transform 0.1s ease-out;
        }

        .transition-long {
            transition: transform 0.2s ease-in-out;
        }

        #menu-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1002;
            font-size: 24px;
            width: 40px;
            height: 40px;
            background-color: rgba(51, 51, 51, 0.8);
            color: #fff;
            border: 1px solid #666;
            border-radius: 5px;
            cursor: pointer;
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        #menu-toggle:hover {
            background-color: var(--theme-color);
        }

        #sidebar {
            position: fixed;
            top: 0;
            right: 0;
            width: 300px;
            height: 100dvh;
            background-color: #2a2a2a;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.5);
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
            z-index: 1001;
            overflow-y: auto;
            padding: 10px;
            box-sizing: border-box;
        }

        #sidebar.open {
            transform: translateX(0);
        }

        #info-overlay {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 8px;
            border-radius: 5px;
            font-size: 0.9rem;
            z-index: 1000;
            max-width: 90vw;
            transition: 0.3s ease-in-out;
            margin-top: 10px;
        }

        #info-location {
            margin-bottom: 5px;
            word-break: break-all;
        }

        .info-overlay-collapsed {
            width: 40px !important;
            height: 40px !important;
            padding: 0 !important;
        }

        .info-overlay-collapsed::after {
            content: "‚ÑπÔ∏è";
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        .info-overlay-collapsed * {
            display: none !important;
        }

        .info-overlay-collapsed:hover {
            background-color: var(--theme-color) !important;
            cursor: pointer;
        }

        .progress-container {
            display: flex;
            z-index: 999;
            width: 100%;
            position: fixed;
            height: 4px;
        }

        .progress {
            background-color: white;
            width: 0;
            height: 100%;
        }

        .guessed-progress {
            background-color: rgba(255, 255, 255, 0.5);
        }

        /* Inherited styles for controls inside sidebar */
        .location {
            display: flex;
            flex-direction: column;
        }

        button {
            margin-top: 8px;
            background-color: #333;
            color: #fff;
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: var(--theme-color);
        }

        button:disabled {
            filter: brightness(0.5);
            cursor: not-allowed;
        }

        .icon {
            font-size: 30px;
            font-family: emoji;
            font-weight: bold;
            width: 35px;
            height: 35px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        textarea {
            background-color: #333;
            color: #fff;
            border: 1px solid #666;
            padding: 4px;
            resize: vertical;
            font-size: 0.8rem;
        }

        .shortcut {
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        .running {
            cursor: wait !important;
        }

        hr {
            width: 100%;
            border: 1px solid #444;
            /* Dark color for the horizontal rule */
            margin: 20px 0;
            /* Adjust margin as needed */
        }

        select {
            background-color: #333;
            /* Dark background color for select dropdown */
            color: #fff;
            /* Light text color for select options */
            padding: 8px;
            border: 1px solid #666;
            /* Dark border color */
            border-radius: 4px;
            appearance: none;
            /* Remove default appearance */
            transition: background-color 0.3s;
        }

        select:hover,
        select:focus {
            background-color: #444;
            /* Change background color on hover/focus */
        }

        .shortcut {
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        .running {
            outline: var(--theme-color) 4px solid;
            cursor: wait !important;
        }

        #color-list {
            list-style: none;
            outline: 1px solid var(--theme-color);
            padding: 8px;
            margin: 8px;
            flex-wrap: wrap;
            max-height: 60dvh;
            overflow-y: auto;
        }

        dialog {
            width: 400px;
            padding: 20px;
            background-color: #222;
            color: #fff;
            border: none;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            max-width: 90%;
            max-height: 90dvh;
        }

        #palette-dialog h2 {
            margin-top: 0;
        }

        #palette-dialog::backdrop {
            background-color: rgba(0, 0, 0, 0.5);
            /* Semi-transparent backdrop */
        }

        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            padding: 0;
            margin: 0;
            cursor: pointer;
            appearance: none;
            background: none;
        }

        input[type="number"] {
            padding: 4px;
            border: 1px solid #666;
            background-color: #333;
            color: #fff;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
            width: 20px;
            height: 20px;
            accent-color: var(--theme-color);
        }

        .color-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        #smart-zoom {
            position: fixed;
            top: 60px;
            right: 10px;
            z-index: 1002;
            font-size: 24px;
            width: 40px;
            height: 40px;
            background-color: rgba(51, 51, 51, 0.8);
            color: #fff;
            border: 1px solid #666;
            border-radius: 5px;
            cursor: pointer;
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }


        @media (max-width: 600px) {
            .container {
                flex-direction: column;
            }

            #mandelbrot {
                width: 100%;
                height: auto;
            }

            .location {
                margin-left: 0;
            }

            .shortcut {
                justify-content: space-evenly;
            }
        }
    </style>
</head>

<body>
    <canvas id="mandelbrot" width="800" height="800"></canvas>

    <div id="info-overlay" class="info-overlay-collapsed">
        <div id="info-location">
            <div>Re: <span id="info-re"></span></div>
            <div>Im: <span id="info-im"></span></div>
            <div>Zoom: <span id="info-zoom"></span></div>
            <div>Iterations: <span id="info-iter"></span></div>
        </div>
        <div id="stats"></div>
    </div>
    <div class="progress-container">
        <div id="progress" class="progress"></div>
        <div id="guessed-progress" class="progress guessed-progress"></div>
    </div>

    <button id="menu-toggle" title="Toggle Controls">&#9776;</button>
    <button id="smart-zoom" title="Smart Zoom">üîç</button>

    <aside id="sidebar">
        <!-- ÊâÄÊúâÂéüÂßãÁöÑÊéß‰ª∂ÈÉΩÁßªÂä®Âà∞ËøôÈáå -->
        <div class="location">
            Real:
            <textarea id="re" class="large" rows="6"></textarea><br>
            Imaginary:
            <textarea id="im" class="large" rows="6"></textarea><br>
            Zoom:
            <textarea id="zoom" rows="2"></textarea><br>
            Iterations:
            <textarea id="it" rows="1"></textarea>
            <div class="shortcut">
                <button class="icon control-button" id="zoom-in" title="Zoom in">&#10133;</button>
                <button class="icon control-button" id="zoom-out" title="Zoom out">&#10134;</button>
                <button class="icon control-button" id="increase-iter" title="Iterations x2">&#128314;</button>
                <button class="icon control-button" id="decrease-iter" title="Iterations /2">&#128315;</button>
            </div>
            <div class="shortcut">
                <button class="icon control-button" id="goto" title="Go to location">&#128640;</button>
                <button class="icon control-button" id="home" title="Reset view">&#127968;</button>
                <button class="icon control-button" id="palette" title="Palette Editor">üé®</button>
                <button class="icon control-button" id="download" title="Download PNG">&#128248;</button>
            </div>
            <div class="shortcut">
                <button class="icon control-button" id="iteration-button" title="Iteration Settings">üîß</button>
                <button class="icon control-button" id="kfr" title="Load KFR file">üìÇ</button>
                <button class="icon control-button" id="save-kfr" title="Save KFR file">üíæ</button>
                <button class="icon control-button" id="makeVideo" title="Make Video">üé•</button>
            </div>
            <div class="shortcut">
                <button class="icon control-button" id="fullscreen" title="Toggle Fullscreen">‚õ∂</button>
            </div>
            <hr>
            Samples
            <select id="samples">
                <option value="seahorse">Seahorse</option>
                <option value="snowflake">Snowflake</option>
                <option value="spiral">Spiral</option>
                <option value="luxury">Luxury</option>
                <option value="horizon">Horizon</option>
                <option value="flora">Flora</option>
                <option value="classic">Classic</option>
                <option value="e200">E200</option>
                <option value="radiant">Radiant</option>
                <option value="branches">Branches</option>
            </select>
            <button id="load-sample" class="control-button">Load</button>
        </div>
        <div id="more"></div>
    </aside>

    <!-- Dialogs remain unchanged -->
    <dialog id="palette-dialog">
        <h2>Color Settings</h2>
        <label for="color-step">Color Step:</label>
        <input type="number" id="color-step" value="1" min="1" max="100" step="1"><br>
        <div id="random-group">
            <input type="radio" name="algorithm" id="random-1" value="random" checked>
            <label for="random-1">Algorithm 1</label>
            <input type="radio" name="algorithm" id="random-2" value="random-bw">
            <label for="random-2">Algorithm 2</label>
            <button id="random-colors">Random</button>
        </div>
        <ol id="color-list">
            <!-- Color settings -->
        </ol>
        <button id="apply-colors">Apply</button>
        <button id="reset-colors">Reset</button>
        <button id="close-dialog">Close</button>
    </dialog>
    <dialog id="iteration-dialog">
        <h2>Iteration Settings</h2>
        <label for="bailout">Bailout:</label>
        <input type="number" id="bailout" value="16" min="2" step="1"><br>
        <label for="smooth">Smooth:</label>
        <input type="checkbox" id="smooth" checked><br>
        <button id="apply-iter">Apply</button>
        <button id="close-iter-dialog">Close</button>
    </dialog>

    <script src="lib/decimal.9.0.0.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gmp-wasm"></script>
    <script>
        const canvas = document.getElementById('mandelbrot');
        const reInput = document.getElementById('re')
        const imInput = document.getElementById('im');
        const zoomInput = document.getElementById('zoom')
        const itInput = document.getElementById('it')
        const statsLabel = document.getElementById('stats')
        const progressBar = document.getElementById('progress');
        const guessedProgressBar = document.getElementById('guessed-progress');
        const sampleSelect = document.getElementById('samples')
        const sampleLoadBtn = document.getElementById('load-sample')
        const more = document.getElementById("more");


        const CPU_CORES = Math.max(navigator.hardwareConcurrency ?? 1, 1);

        class FloatExp {
            static expTable = [];
            static LOG2_10 = Math.log2(10);
            static LOG10_2 = Math.log10(2);
            static buffer = new ArrayBuffer(8);
            static floatView = new Float64Array(FloatExp.buffer);
            static int32View = new Int32Array(FloatExp.buffer);

            // Pre-allocate standard constants to avoid recreation
            static ZERO = new FloatExp(0, 0);
            static ONE = new FloatExp(1, 0);
            static NEGATIVE_ONE = new FloatExp(-1, 0);
            static TWO = new FloatExp(2, 0);
            static FOUR = new FloatExp(4, 0);
            static INFINITY = new FloatExp(1, Number.MAX_SAFE_INTEGER); // Set a very high exponent to represent infinity
            static NEGATIVE_INFINITY = new FloatExp(-1, Number.MAX_SAFE_INTEGER);

            static {
                this.expTable = [];
                for (let i = 0; i < 324 + 308; i++) {
                    this.expTable[i] = Math.pow(10, i - 324);
                }
            }

            static getExp(exp) {
                if (exp < -324) return 0;
                else if (exp > 308) return Infinity;
                return this.expTable[exp + 324];
            }

            static getExpOfDouble(d) {
                if (d === 0) throw new Error("Exponent of zero is undefined.");

                // Inlining some logic for speed could be done here, 
                // but keeping original logic for safety as provided.
                const LOG10_2 = Math.LOG10E;
                const BIAS = 1023;
                FloatExp.floatView[0] = d;
                const highBits = FloatExp.int32View[1];
                const lowBits = FloatExp.int32View[0];
                const rawExp = (highBits >>> 20) & 0x7FF;

                let actualExp;
                if (rawExp === 0) {
                    let mantissaHigh = highBits & 0xFFFFF;
                    const mantissaLow = lowBits;
                    let leadingZeros = 0;
                    if (mantissaHigh === 0) {
                        leadingZeros += 32;
                        let temp = mantissaLow;
                        while (temp !== 0 && (temp & 0x80000000) === 0) {
                            temp <<= 1;
                            leadingZeros++;
                        }
                    } else {
                        let temp = mantissaHigh;
                        while ((temp & 0x80000) === 0) {
                            temp <<= 1;
                            leadingZeros++;
                        }
                    }
                    actualExp = -1022 - leadingZeros;
                } else {
                    actualExp = rawExp - BIAS;
                }
                return Math.floor(actualExp * LOG10_2);
            }

            constructor(base, exp = 0, normalize = true) {
                // Removed validations for performance in this hot path, 
                // assuming internal usage ensures validity.
                this.base = base;
                this.exp = exp;
                if (normalize) this.norm();
            }

            norm() {
                if (this.base == 0) {
                    this.exp = 0;
                    return this;
                }

                while (Math.abs(this.base) > 10) {
                    this.base /= 10;
                    this.exp++;
                }

                while (Math.abs(this.base) < 1) {
                    this.base *= 10;
                    this.exp--;
                }

                return this;

                // if (this.base != 0 && (Math.abs(this.base) >= 10 || Math.abs(this.base) < 1)) {
                //     let exp = FloatExp.getExpOfDouble(this.base);
                //     if (exp != 0) {
                //         this.exp += exp;
                //         this.base /= FloatExp.getExp(exp);
                //     }
                // }
                // return this;
            }

            /**
             * Copies the value of this FloatExp into the target `store`.
             * @param {FloatExp} store 
             */
            storeTo(store) {
                store.base = this.base;
                store.exp = this.exp;
                return store;
            }

            // --- Optimized Math Operations ---

            add(other) {
                // Create result container once
                return this.addTo(other, new FloatExp(0, 0, false));
            }

            addMut(other) {
                return this.addTo(other, this);
            }

            addTo(other, store) {
                let oBase, oExp;
                if (typeof other === 'number') {
                    oBase = other;
                    oExp = 0;
                } else {
                    oBase = other.base;
                    oExp = other.exp;
                }

                if (oBase === 0) return this.storeTo(store);
                if (this.base === 0) {
                    store.base = oBase;
                    store.exp = oExp;
                    return store;
                }

                const expDiff = oExp - this.exp;

                if (expDiff === 0) {
                    store.base = this.base + oBase;
                    store.exp = this.exp;
                } else if (expDiff > 16) {
                    store.base = oBase;
                    store.exp = oExp;
                    // No normalization needed here usually if 'other' is already norm, but safe to do so
                    return store;
                } else if (expDiff < -16) {
                    // 'other' is too small to affect 'this'
                    store.base = this.base;
                    store.exp = this.exp;
                    return store;
                } else {
                    store.base = this.base + oBase * FloatExp.getExp(expDiff);
                    store.exp = this.exp;
                }
                return store.norm();
            }

            sub(other) {
                return this.subTo(other, new FloatExp(0, 0, false));
            }

            subMut(other) {
                return this.subTo(other, this);
            }

            subTo(other, store) {
                let oBase, oExp;
                if (typeof other === 'number') {
                    oBase = other;
                    oExp = 0;
                } else {
                    oBase = other.base;
                    oExp = other.exp;
                }

                if (oBase === 0) return this.storeTo(store);
                if (this.base === 0) {
                    store.base = -oBase;
                    store.exp = oExp;
                    return store;
                }

                const expDiff = oExp - this.exp;

                if (expDiff === 0) {
                    store.base = this.base - oBase;
                    store.exp = this.exp;
                } else if (expDiff > 16) {
                    // Result is -other
                    store.base = -oBase;
                    store.exp = oExp;
                    return store;
                } else if (expDiff < -16) {
                    // other is insignificant
                    store.base = this.base;
                    store.exp = this.exp;
                    return store;
                } else {
                    store.base = this.base - oBase * FloatExp.getExp(expDiff);
                    store.exp = this.exp;
                }
                return store.norm();
            }

            mul(other) {
                return this.mulTo(other, new FloatExp(0, 0, false));
            }

            mulMut(other) {
                return this.mulTo(other, this);
            }

            mulTo(other, store) {
                if (other instanceof FloatExp) {
                    store.base = this.base * other.base;
                    store.exp = this.exp + other.exp;
                } else {
                    store.base = this.base * other;
                    store.exp = this.exp;
                }
                return store.norm();
            }

            div(other) {
                return this.divTo(other, new FloatExp(0, 0, false));
            }

            divMut(other) {
                return this.divTo(other, this);
            }

            divTo(other, store) {
                if (other instanceof FloatExp) {
                    store.base = this.base / other.base;
                    store.exp = this.exp - other.exp;
                } else {
                    store.base = this.base / other;
                    store.exp = this.exp;
                }
                return store.norm();
            }

            // --- Other Methods ---

            doubleValue() {
                return this.base * FloatExp.getExp(this.exp);
            }

            toString() {
                this.norm();
                return `${this.base}e${this.exp}`;
            }

            abs() {
                return new FloatExp(Math.abs(this.base), this.exp);
            }

            sqrt() {
                if (this.base < 0) throw new Error("Cannot take square root of negative number");
                if (this.base === 0) return FloatExp.ZERO.copy();

                let newBase = this.base;
                let newExp = this.exp;

                // Â¶ÇÊûúÊåáÊï∞ÊòØÂ•áÊï∞ÔºåÂ∞Ü10ÁöÑÂõ†Â≠êËΩ¨ÁßªÂà∞base‰∏≠
                if (newExp % 2 !== 0) {
                    newBase *= 10;
                    newExp -= 1;
                }

                return new FloatExp(Math.sqrt(newBase), newExp >> 1);
            }

            rev() {
                return new FloatExp(-this.base, this.exp);
            }

            copy() {
                return new FloatExp(this.base, this.exp, false);
            }

            square() {
                return new FloatExp(this.base * this.base, this.exp * 2);
            }

            squareMut() {
                this.base *= this.base;
                this.exp *= 2;
                return this.norm();
            }

            equals(o) {
                return this.compareTo(o) === 0;
            }

            compareTo(o) {
                if (this.base > 0 && o.base < 0) return 1;
                if (this.base < 0 && o.base > 0) return -1;
                if (this.base === 0 && o.base === 0) return 0;
                if (this.base === 0) return o.base > 0 ? -1 : 1;
                if (o.base === 0) return this.base > 0 ? 1 : -1;
                if (this.exp > o.exp) return this.base > 0 ? 1 : -1;
                if (this.exp < o.exp) return this.base > 0 ? -1 : 1;
                if (this.base > o.base) return 1;
                if (this.base < o.base) return -1;
                return 0;
            }

            log2Value() {
                const log2Mantissa = Math.log2(this.base);
                const log2Exponent = this.exp * FloatExp.LOG2_10;
                return log2Mantissa + log2Exponent;
            }

            static fromLog2(val) {
                const log10 = val * FloatExp.LOG10_2;
                return new FloatExp(Math.pow(10, log10 - Math.trunc(log10)), Math.trunc(log10));
            }

            static max(...a) {
                let max = a[0];
                for (let i = 1; i < a.length; i++) {
                    if (a[i].compareTo(max) > 0) {
                        max = a[i];
                    }
                }
                return max;
            }

            static min(...a) {
                let min = a[0];
                for (let i = 1; i < a.length; i++) {
                    if (a[i].compareTo(min) < 0) {
                        min = a[i];
                    }
                }
                return min;
            }
        }

        function normalizeScientificNotation(input) {
            // Â§ÑÁêÜËæìÂÖ•‰∏∫Êï∞Â≠óÁ±ªÂûãÁöÑÊÉÖÂÜµ
            let str = typeof input === 'number' ? String(input) : input.trim();

            // Â§ÑÁêÜÁâπÊÆäÊÉÖÂÜµ
            if (str === '' || str === 'NaN' || str === 'Infinity' || str === '-Infinity') {
                return str;
            }

            // Ê£ÄÊü•ÊòØÂê¶‰∏∫0
            if (str === '0' || str === '-0' || str === '+0') {
                return '0e0';
            }

            // ÊèêÂèñÁ¨¶Âè∑
            let sign = '';
            if (str.startsWith('-') || str.startsWith('+')) {
                sign = str[0];
                str = str.slice(1);
            }

            // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÊòØÁßëÂ≠¶ËÆ°Êï∞Ê≥ï
            const eIndex = str.search(/[eE]/);
            let mantissaStr, originalExponent = 0;

            if (eIndex !== -1) {
                // ÂàÜÁ¶ªÂ∞æÊï∞ÂíåÊåáÊï∞
                mantissaStr = str.slice(0, eIndex);
                const exponentStr = str.slice(eIndex + 1);
                originalExponent = parseInt(exponentStr, 10);

                if (isNaN(originalExponent)) {
                    throw new Error('Invalid exponent format');
                }
            } else {
                // ÊôÆÈÄöÊï∞Â≠óÊ†ºÂºè
                mantissaStr = str;
            }

            // Â§ÑÁêÜÂ∞æÊï∞ÈÉ®ÂàÜÁöÑÁ¨¶Âè∑
            if (mantissaStr.startsWith('+') || mantissaStr.startsWith('-')) {
                sign = mantissaStr[0];
                mantissaStr = mantissaStr.slice(1);
            }

            // Êü•ÊâæÂ∞èÊï∞ÁÇπ‰ΩçÁΩÆ
            const dotIndex = mantissaStr.indexOf('.');
            let integerPart, fractionalPart;

            if (dotIndex === -1) {
                // Ê≤°ÊúâÂ∞èÊï∞ÁÇπ
                integerPart = mantissaStr;
                fractionalPart = '';
            } else {
                // ÊúâÂ∞èÊï∞ÁÇπ
                integerPart = mantissaStr.slice(0, dotIndex);
                fractionalPart = mantissaStr.slice(dotIndex + 1);
            }

            // ÂêàÂπ∂ÊâÄÊúâÊï∞Â≠ó
            const allDigits = integerPart + fractionalPart;

            // ÊâæÂà∞Á¨¨‰∏Ä‰∏™ÈùûÈõ∂Êï∞Â≠óÁöÑ‰ΩçÁΩÆ
            let firstNonZeroIndex = -1;
            for (let i = 0; i < allDigits.length; i++) {
                if (allDigits[i] !== '0') {
                    firstNonZeroIndex = i;
                    break;
                }
            }

            if (firstNonZeroIndex === -1) {
                // ÂÖ®ÈÉ®ÊòØÈõ∂
                return '0e0';
            }

            // ÊâæÂà∞ÊúÄÂêé‰∏Ä‰∏™ÈùûÈõ∂Êï∞Â≠óÁöÑ‰ΩçÁΩÆ
            let lastNonZeroIndex = -1;
            for (let i = allDigits.length - 1; i >= 0; i--) {
                if (allDigits[i] !== '0') {
                    lastNonZeroIndex = i;
                    break;
                }
            }

            // ÊèêÂèñÊúâÊïàÊï∞Â≠óÈÉ®ÂàÜ
            const significantDigits = allDigits.slice(firstNonZeroIndex, lastNonZeroIndex + 1);

            // ËÆ°ÁÆóÊåáÊï∞
            let exponent;

            if (dotIndex === -1) {
                // Ê≤°ÊúâÂ∞èÊï∞ÁÇπÔºöÊåáÊï∞ = Êï∞Â≠óÊÄª‰ΩçÊï∞ - 1
                exponent = allDigits.length - 1;
            } else {
                if (firstNonZeroIndex < integerPart.length) {
                    // Á¨¨‰∏Ä‰∏™ÈùûÈõ∂Êï∞Â≠óÂú®Êï¥Êï∞ÈÉ®ÂàÜ
                    exponent = integerPart.length - firstNonZeroIndex - 1;
                } else {
                    // Á¨¨‰∏Ä‰∏™ÈùûÈõ∂Êï∞Â≠óÂú®Â∞èÊï∞ÈÉ®ÂàÜ
                    exponent = -(firstNonZeroIndex - integerPart.length + 1);
                }
            }

            // ÊÄªÊåáÊï∞ = ÂéüÂßãÊåáÊï∞ + ÂΩìÂâçËÆ°ÁÆóÁöÑÊåáÊï∞
            const totalExponent = originalExponent + exponent;

            // ÊûÑÂª∫ËßÑÊ†ºÂåñÁßëÂ≠¶ËÆ°Êï∞Ê≥ï
            let normalizedMantissa;
            if (significantDigits.length === 1) {
                normalizedMantissa = significantDigits[0];
            } else {
                normalizedMantissa = significantDigits[0] + '.' + significantDigits.slice(1);
            }

            // Â§ÑÁêÜÁ¨¶Âè∑
            const signPrefix = sign === '-' ? '-' : '';

            return [signPrefix + normalizedMantissa, totalExponent];
        }

        function parseFloatExp(string) {
            var [b, e] = normalizeScientificNotation(string)
            var fp = new FloatExp(parseFloat(b), (isNaN(e) ? 0 : e));
            // fp.norm();
            return fp;
        }

        function doubleToFloatExp(num) {
            if (num === 0) return FloatExp.ZERO.copy();
            // Get the exponent
            let exponent = Math.floor(Math.log10(Math.abs(num)));
            // Calculate the significand
            let scale = FloatExp.getExp(exponent);
            let significand = scale ? num / scale : 0;
            return new FloatExp(significand, exponent);
        }

        function decimalToFloatExp(num) {
            let base = num.d[0];
            for (let i = 1; i < 3; i++) {
                if (num.d[i]) base = base * 1e8 + num.d[i];
            }
            if (num.e == 0) return new FloatExp(base, 0);
            let off = Math.floor(Math.log10(base));
            let exp = num.e - off;
            return new FloatExp(base, exp);
        }

        function getFloatExp(obj) {
            if (obj instanceof FloatExp) return obj;
            else if (typeof obj === "number") {
                return doubleToFloatExp(obj);
            } else if (obj instanceof Decimal) {
                return decimalToFloatExp(obj);
            } else return parseFloatExp(obj.toString())
        }
        class Complex {
            // Static cache variables to avoid object creation in intermediate calculations
            static CACHE_RE = 0;
            static CACHE_IM = 0;
            static CACHE_RE2 = 0;
            static CACHE_IM2 = 0;

            constructor(re, im) {
                this.re = re;
                this.im = im;
                this.absValue = null; // Cache for absolute value squared
            }

            // Clear cache when values change
            _clearCache() {
                this.absValue = null;
            }

            // --- Addition Operations ---
            add(other) {
                return this.addTo(other, new Complex(0, 0));
            }

            addMut(other) {
                return this.addTo(other, this);
            }

            addTo(other, store) {
                if (typeof other === 'number') {
                    store.re = this.re + other;
                    store.im = this.im;
                } else {
                    store.re = this.re + other.re;
                    store.im = this.im + other.im;
                }
                store._clearCache(); // Clear cache in store
                return store;
            }

            // --- Subtraction Operations ---
            sub(other) {
                return this.subTo(other, new Complex(0, 0));
            }

            subMut(other) {
                return this.subTo(other, this);
            }

            subTo(other, store) {
                if (typeof other === 'number') {
                    store.re = this.re - other;
                    store.im = this.im;
                } else {
                    store.re = this.re - other.re;
                    store.im = this.im - other.im;
                }
                store._clearCache();
                return store;
            }

            // --- Multiplication Operations ---
            mul(other) {
                return this.mulTo(other, new Complex(0, 0));
            }

            mulMut(other) {
                return this.mulTo(other, this);
            }

            /**
             * Optimized multiplication using static cache to avoid object creation
             * (a + bi)(c + di) = (ac - bd) + (ad + bc)i
             */
            mulTo(other, store) {
                if (typeof other === 'number') {
                    store.re = this.re * other;
                    store.im = this.im * other;
                    store._clearCache();
                    return store;
                }

                // Use static cache for intermediate values
                // ac -> CACHE_RE
                Complex.CACHE_RE = this.re * other.re;
                // bd -> CACHE_IM
                Complex.CACHE_IM = this.im * other.im;
                // Real part: ac - bd -> CACHE_RE2 (temporary for real result)
                Complex.CACHE_RE2 = Complex.CACHE_RE - Complex.CACHE_IM;

                // ad -> CACHE_RE (reuse)
                Complex.CACHE_RE = this.re * other.im;
                // bc -> CACHE_IM (reuse)
                Complex.CACHE_IM = this.im * other.re;
                // Imag part: ad + bc -> CACHE_IM2 (temporary for imag result)
                Complex.CACHE_IM2 = Complex.CACHE_RE + Complex.CACHE_IM;

                // Store results
                store.re = Complex.CACHE_RE2;
                store.im = Complex.CACHE_IM2;
                store._clearCache();

                return store;
            }

            // --- Division Operations ---
            div(other) {
                return this.divTo(other, new Complex(0, 0));
            }

            divMut(other) {
                return this.divTo(other, this);
            }

            /**
             * Optimized division
             * (a + bi)/(c + di) = ((ac + bd) + (bc - ad)i) / (c^2 + d^2)
             */
            divTo(other, store) {
                if (typeof other === 'number') {
                    store.re = this.re / other;
                    store.im = this.im / other;
                    store._clearCache();
                    return store;
                }

                // Denominator: c^2 + d^2 -> CACHE_RE
                Complex.CACHE_RE = other.re * other.re + other.im * other.im;

                // Numerator Real: ac + bd -> CACHE_IM
                Complex.CACHE_IM = this.re * other.re + this.im * other.im;

                // Numerator Imag: bc - ad -> CACHE_RE2
                Complex.CACHE_RE2 = this.im * other.re - this.re * other.im;

                // Final division
                store.re = Complex.CACHE_IM / Complex.CACHE_RE;
                store.im = Complex.CACHE_RE2 / Complex.CACHE_RE;
                store._clearCache();

                return store;
            }

            // --- Square Operations ---
            square() {
                return this.squareTo(new Complex(0, 0));
            }

            squareMut() {
                return this.squareTo(this);
            }

            squareTo(store) {
                // (a+bi)^2 = (a^2 - b^2) + 2abi
                Complex.CACHE_RE = this.re * this.re - this.im * this.im; // Real part
                Complex.CACHE_IM = 2 * this.re * this.im; // Imag part

                store.re = Complex.CACHE_RE;
                store.im = Complex.CACHE_IM;
                store._clearCache();

                return store;
            }

            // --- Other Methods (updated) ---
            abs() {
                if (this.absValue === null) {
                    this.absValue = this.re * this.re + this.im * this.im;
                }
                return this.absValue;
            }

            toNumberArray() {
                return [this.re, this.im];
            }

            norm() {
                return Math.max(Math.abs(this.re), Math.abs(this.im));
            }

            equals(other) {
                return this.re === other.re && this.im === other.im;
            }

            copy() {
                return new Complex(this.re, this.im);
            }

            toString() {
                return `(${this.re}, ${this.im})`;
            }

            // Static methods similar to FloatExpComplex
            static ZERO = new Complex(0, 0);
            static ONE = new Complex(1, 0);
            static I = new Complex(0, 1);
            static NEGATIVE_ONE = new Complex(-1, 0);
            static TWO = new Complex(2, 0);
        }

        class DeepComplex {
            constructor(re, im) {
                this.re = re instanceof Decimal ? re : new Decimal(re);
                this.im = im instanceof Decimal ? im : new Decimal(im);
            }

            abs() {
                return this.re.pow(2).plus(this.im.pow(2));
            }

            mul(other) {
                if (other instanceof DeepComplex) {
                    const realPart = this.re.times(other.re).minus(this.im.times(other.im));
                    const imagPart = this.re.times(other.im).plus(this.im.times(other.re));
                    return new DeepComplex(realPart, imagPart);
                } else if (other instanceof Complex) {
                    const realPart = this.re.times(other.re).minus(this.im.times(other.im));
                    const imagPart = this.re.times(other.im).plus(this.im.times(other.re));
                    return new DeepComplex(realPart, imagPart);
                } else if (other instanceof FloatExpComplex) {
                    other = other.toDeepComplex();
                    const realPart = this.re.times(other.re).minus(this.im.times(other.im));
                    const imagPart = this.re.times(other.im).plus(this.im.times(other.re));
                    return new DeepComplex(realPart, imagPart);
                } else if (typeof other === 'number') {
                    return new DeepComplex(this.re.times(other), this.im.times(other));
                } else {
                    throw new Error('Invalid type for multiplication');
                }
            }

            add(other) {
                if (other instanceof FloatExpComplex) {
                    other = other.toDeepComplex();
                }
                return new DeepComplex(this.re.plus(other.re), this.im.plus(other.im));
            }

            sub(other) {
                if (other instanceof FloatExpComplex) {
                    other = other.toDeepComplex();
                }
                return new DeepComplex(this.re.minus(other.re), this.im.minus(other.im));
            }

            downCast() {
                return new Complex(this.re.toNumber(), this.im.toNumber())
            }

            toFloatExp() {
                return new FloatExpComplex(
                    getFloatExp(this.re.toString()),
                    getFloatExp(this.im.toString())
                )
            }

            square() {
                const realPart = this.re.times(this.re).minus(this.im.times(this.im)); // a^2 - b^2
                const imagPart = this.re.plus(this.re).times(this.im);     // 2ab
                return new DeepComplex(realPart, imagPart);
            }
        }

        class FloatExpComplex {
            static ZERO = new FloatExpComplex(FloatExp.ZERO, FloatExp.ZERO);
            static ONE = new FloatExpComplex(FloatExp.ONE, FloatExp.ZERO);
            static NEGATIVE_ONE = new FloatExpComplex(FloatExp.NEGATIVE_ONE, FloatExp.ZERO);
            static TWO = new FloatExpComplex(FloatExp.TWO, FloatExp.ZERO);

            // Static scratchpads (cache) for internal calculations to avoid object creation
            static CACHE_1 = new FloatExp(0, 0);
            static CACHE_2 = new FloatExp(0, 0);
            static CACHE_3 = new FloatExp(0, 0);
            static CACHE_4 = new FloatExp(0, 0);

            constructor(re, im) {
                // Assuming getFloatExp is available globally or users pass FloatExp
                this.re = (re instanceof FloatExp) ? re : new FloatExp(re);
                this.im = (im instanceof FloatExp) ? im : new FloatExp(im);
            }

            storeTo(store) {
                this.re.storeTo(store.re);
                this.im.storeTo(store.im);
                return store;
            }

            copy() {
                return new FloatExpComplex(this.re.copy(), this.im.copy());
            }

            // --- Optimized Math Operations ---

            add(other) {
                return this.addTo(other, new FloatExpComplex(new FloatExp(0), new FloatExp(0)));
            }

            addMut(other) {
                return this.addTo(other, this);
            }

            addTo(other, store) {
                if (typeof other === 'number') {
                    this.re.addTo(other, store.re);
                    this.im.storeTo(store.im);
                } else {
                    this.re.addTo(other.re, store.re);
                    this.im.addTo(other.im, store.im);
                }
                return store;
            }

            sub(other) {
                return this.subTo(other, new FloatExpComplex(new FloatExp(0), new FloatExp(0)));
            }

            subMut(other) {
                return this.subTo(other, this);
            }

            subTo(other, store) {
                if (typeof other === 'number') {
                    this.re.subTo(other, store.re);
                    this.im.storeTo(store.im);
                } else {
                    this.re.subTo(other.re, store.re);
                    this.im.subTo(other.im, store.im);
                }
                return store;
            }

            mul(other) {
                return this.mulTo(other, new FloatExpComplex(new FloatExp(0), new FloatExp(0)));
            }

            mulMut(other) {
                return this.mulTo(other, this);
            }

            /**
             * Optimized multiplication using static scratchpads to ensure 0 allocation for intermediate steps.
             * Formula: (a + bi)(c + di) = (ac - bd) + (ad + bc)i
             */
            mulTo(other, store) {
                if (typeof other === 'number') {
                    this.re.mulTo(other, store.re);
                    this.im.mulTo(other, store.im);
                    return store;
                }

                // Use static cache for intermediate values to avoid 'new FloatExp'
                // This prevents aliasing issues if 'store' is 'this' or 'other'

                // ac -> CACHE_1
                this.re.mulTo(other.re, FloatExpComplex.CACHE_1);
                // bd -> CACHE_2
                this.im.mulTo(other.im, FloatExpComplex.CACHE_2);

                // Real part: ac - bd -> CACHE_3 (Temporary storage for Real Result)
                FloatExpComplex.CACHE_1.subTo(FloatExpComplex.CACHE_2, FloatExpComplex.CACHE_3);

                // ad -> CACHE_1 (reuse)
                this.re.mulTo(other.im, FloatExpComplex.CACHE_1);
                // bc -> CACHE_2 (reuse)
                this.im.mulTo(other.re, FloatExpComplex.CACHE_2);

                // Imag part: ad + bc -> CACHE_4 (Temporary storage for Imag Result)
                FloatExpComplex.CACHE_1.addTo(FloatExpComplex.CACHE_2, FloatExpComplex.CACHE_4);

                // Finally, copy from temp storage to the actual store
                FloatExpComplex.CACHE_3.storeTo(store.re);
                FloatExpComplex.CACHE_4.storeTo(store.im);

                return store;
            }

            div(other) {
                return this.divTo(other, new FloatExpComplex(new FloatExp(0), new FloatExp(0)));
            }

            divMut(other) {
                return this.divTo(other, this);
            }

            /**
             * Optimized division.
             * Formula: (a + bi)/(c + di) = ((ac + bd) + (bc - ad)i) / (c^2 + d^2)
             */
            divTo(other, store) {
                if (typeof other === 'number') {
                    this.re.divTo(other, store.re);
                    this.im.divTo(other, store.im);
                    return store;
                }

                // Denominator: c^2 + d^2 -> CACHE_1
                other.re.mulTo(other.re, FloatExpComplex.CACHE_2); // c^2
                other.im.mulTo(other.im, FloatExpComplex.CACHE_3); // d^2
                FloatExpComplex.CACHE_2.addTo(FloatExpComplex.CACHE_3, FloatExpComplex.CACHE_1); // Denom stored in CACHE_1

                // Numerator Real: ac + bd -> CACHE_2
                this.re.mulTo(other.re, FloatExpComplex.CACHE_3); // ac
                this.im.mulTo(other.im, FloatExpComplex.CACHE_4); // bd
                FloatExpComplex.CACHE_3.addTo(FloatExpComplex.CACHE_4, FloatExpComplex.CACHE_2); // NumReal in CACHE_2

                // Numerator Imag: bc - ad -> CACHE_3
                this.im.mulTo(other.re, FloatExpComplex.CACHE_4); // bc
                // Re-calculate ad locally into CACHE_4 buffer to save slots, using CACHE_4 temporarily
                // Wait, need another buffer. Actually, we can compute ad into store.re temporarily if we are careful,
                // but let's use CACHE_4 for 'ad' then subtract.

                // ad
                this.re.mulTo(other.im, store.re); // Using store.re as temp buffer for 'ad'. Safe because we overwrite store.re later.

                // bc (in CACHE_4) - ad (in store.re) -> CACHE_3
                FloatExpComplex.CACHE_4.subTo(store.re, FloatExpComplex.CACHE_3); // NumImag in CACHE_3

                // Final Division
                // Real: NumReal (CACHE_2) / Denom (CACHE_1) -> store.re
                FloatExpComplex.CACHE_2.divTo(FloatExpComplex.CACHE_1, store.re);

                // Imag: NumImag (CACHE_3) / Denom (CACHE_1) -> store.im
                FloatExpComplex.CACHE_3.divTo(FloatExpComplex.CACHE_1, store.im);

                return store;
            }

            // --- Other Methods ---

            abs2() {
                return this.re.mul(this.re).addMut(this.im.mul(this.im));
            }

            // Chebyshev norm
            norm() {
                return FloatExp.max(this.re.abs(), this.im.abs());
            }

            square() {
                const res = new FloatExpComplex(new FloatExp(0), new FloatExp(0));
                return this.squareTo(res);
            }

            squareMut() {
                return this.squareTo(this);
            }

            squareTo(store) {
                // (a+bi)^2 = (a^2 - b^2) + 2abi

                // a^2 -> CACHE_1
                this.re.mulTo(this.re, FloatExpComplex.CACHE_1);
                // b^2 -> CACHE_2
                this.im.mulTo(this.im, FloatExpComplex.CACHE_2);

                // Real: a^2 - b^2 -> CACHE_3
                FloatExpComplex.CACHE_1.subTo(FloatExpComplex.CACHE_2, FloatExpComplex.CACHE_3);

                // Imag: 2ab -> CACHE_4
                this.re.mulTo(this.im, FloatExpComplex.CACHE_4);
                FloatExpComplex.CACHE_4.mulTo(FloatExp.TWO, FloatExpComplex.CACHE_4);

                FloatExpComplex.CACHE_3.storeTo(store.re);
                FloatExpComplex.CACHE_4.storeTo(store.im);

                return store;
            }

            equals(o) {
                return this.re.equals(o.re) && this.im.equals(o.im);
            }

            toComplex() {
                return new Complex(this.re.doubleValue(), this.im.doubleValue());
            }

            toDeepComplex() {
                return new DeepComplex(
                    new Decimal(this.re.toString()),
                    new Decimal(this.im.toString())
                )
            }
        }

        const samples = {
            seahorse: {
                re: "-0.74543",
                im: "0.11301",
                zoom: 5e4,
                it: 2048
            },
            snowflake: {
                re: "-0.10109629004872408548585126380133943559",
                im: "0.9562865745329222746947099385459096648",
                zoom: 3.169126e+29,
                it: 2048
            },
            spiral: {
                re: "-1.999993942175717867792242968103527549859576",
                im: "8.6071861910492399703689002138183e-21",
                zoom: 5.192297e+33,
                it: 2048
            },
            luxury: {
                re: "-0.79580869118304321175952779938151856806452507855882",
                im: "0.18469182276676613095841056743436302824144029079562",
                zoom: 1.3e42,
                it: 4096
            },
            horizon: {
                re: "-1.8584343800176784682217288203669595446250882516610855163",
                im: 0,
                zoom: 2.338403e+48,
                it: 8192
            },
            flora: {
                re: "-1.99909599626591118385320862404514647238736998791060410728750271382258617296138194612160227",
                im: "2.7580719798153099801178971305087708486297199751987655897677764832896127755911711978e-7",
                zoom: 1.554135e+85,
                it: 12000
            },
            classic: {
                re: "-1.740062382579339905220844167065825638296641720436171866879862418461182919644153056054840718339483225743450008259172138785492983677915427169",
                im: "0.02817533977921104899241152114431950968753907674299060857040130959588017432409201863854008146585605536156950844867740770006690377105617915918",
                zoom: 3.169127e+129,
                it: 16384
            },
            e200: {
                re: "-1.966802851116594708819298912851462114119985811705618926682822172678211294505900454587066386326486696211109981444987492635874831274786202351721769325471466717092496114767216598301545236111458996508055081585396",
                im: "0.0010977722859744975944199816905137002369183368289711851029920379829671969621655021360812521504061553173015969230096789768757462998082308739346850130554776214016764573717626859656016612926260380492615038665711972",
                zoom: 3.061802e+200,
                it: 2560
            },
            radiant: {
                re: "-1.99999999999999999999999999999999999999999999999999999999999985604992427869224505485316659406169263456244557162707394015035258073628597813990573253878488792954728746460753235734445467801735035140789540329931747966277516467943284583061883624921231436068907582257",
                im: "-8.91471704727989229599363700420508490047745648395754111902776340339365777429490330220597376804879333373511664660430230981300478098523390924266124801444129e-108",
                zoom: 6.190352e+250,
                it: 32768
            },
            branches: {
                re: "-1.6292734442048283318938320396270139993976098667361842769438797568378211896685981215295380430631824444939812959088045104000652511090002918608428367750404559604873908045574737562161798763493882467959347522331334565200535419490490792109572426042012307199142243133244778278658423929305351347449296418283955642234980665610830226069420767708737186375011028341136058680534715563202637094315075646672266222835522732620561624291470918925972479094214439824838059879454955180554531579035878862691173748960700828240715259267985644677355092076437915522889997465324097488586896011539207914088325170690741321143420090542550202239848652811940259393780795046066233233901935939495310855142242101042",
                im: "0.03869400209621531644885884354220643543483856432312340490566021352296232798895918154015224599032404970872042582187369535150768927860463654320654167750197244691011756126324382371624135105468469098307733451525287938447855301549425418319315644599440229040004000393629694918121347776683198213801647169431881760881989559740902877967780796990256450970464951956949842553605553300056814346433987027958609011265495269006410527939833349934593968626122035005120083542187577701148430417027976032242752140056316110069588785859474053819290291277818754134945550976828752797151560991794888216365813883286779093669780620189356923473044461454552716354829377180996852428111452867133487261674235339815",
                zoom: "1.5710523668200003e671",
                it: 22067
            }
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function* getReferenceOrbitMPFR(C, radius, iterations, precisionBits) {
            let Z = new DeepComplex(0, 0),
                z = new Complex(0, 0),
                dzdc = new Complex(1, 0),
                one = new Complex(1, 0);
            const orbit = [new Complex(0, 0)];
            let predCenter = null;

            const roundingMode = gmp.FloatRoundingMode.ROUND_DOWN;
            const options = { precisionBits: precisionBits, roundingMode };

            let gmpinit = await gmp.init();
            let ctx = gmpinit.getContext(options);

            let cre = ctx.Float(C.re.toString());
            let cim = ctx.Float(C.im.toString());
            let mpzre = ctx.Float(0);
            let mpzim = ctx.Float(0);


            let updateTimer = performance.now();

            const binding = gmpinit.binding;
            console.log(binding)
            const tempVars = {
                re2: ctx.Float(0), im2: ctx.Float(0), reim: ctx.Float(0),
                temp1: ctx.Float(0), temp2: ctx.Float(0)
            };

            for (let i = 0; i < iterations; i++) {
                dzdc = z.add(z).mulMut(dzdc).addMut(one);

                // Â§çÊï∞Âπ≥ÊñπËÆ°ÁÆó
                binding.mpfr_sqr(tempVars.re2.mpfr_t, mpzre.mpfr_t);
                binding.mpfr_sqr(tempVars.im2.mpfr_t, mpzim.mpfr_t);
                binding.mpfr_mul(tempVars.reim.mpfr_t, mpzre.mpfr_t, mpzim.mpfr_t);

                // Êñ∞ÂÆûÈÉ®: re^2 - im^2 + cre
                binding.mpfr_sub(mpzre.mpfr_t, tempVars.re2.mpfr_t, tempVars.im2.mpfr_t);
                binding.mpfr_add(mpzre.mpfr_t, mpzre.mpfr_t, cre.mpfr_t);

                // Êñ∞ËôöÈÉ®: 2*re*im + cim
                binding.mpfr_mul_2ui(mpzim.mpfr_t, tempVars.reim.mpfr_t, 1);
                binding.mpfr_add(mpzim.mpfr_t, mpzim.mpfr_t, cim.mpfr_t);

                // console.log(1,mpzre.toString(), binding.mpfr_get_exp(mpzre.mpfr_t))
                // binding.mpfr_set_exp(mpzre.mpfr_t, 0)
                // console.log(2,mpzre.toString(), binding.mpfr_get_exp(mpzre.mpfr_t))

                z = new Complex(mpzre.toNumber(), mpzim.toNumber());
                orbit.push(z);

                if (dzdc.norm() * radius * 2 > z.norm()) {
                    predCenter = z.div(dzdc);
                    break;
                };
                if (z.norm() > 16.0) break;

                let currentTime = performance.now();
                if (currentTime - updateTimer > 100) {
                    updateTimer = currentTime;
                    yield i;
                    await delay(0);
                }
            }

            ctx.destroy();
            return {
                orbit: orbit,
                predCenter: predCenter
            };
        }

        function MPFR2FloatExp(ctx, num, binding, unscaled) {
            binding.mpfr_set(unscaled.mpfr_t, num.mpfr_t);
            let exponent = binding.mpfr_get_exp(unscaled.mpfr_t);
            binding.mpfr_set_exp(unscaled.mpfr_t, 0);
            let mantissa = unscaled.toNumber();

            if (mantissa === 0) {
                return FloatExp.ZERO.copy();
            }

            // ËÆ°ÁÆó‰ª•10‰∏∫Â∫ïÁöÑÂØπÊï∞
            let sign = Math.sign(mantissa);
            let absMantissa = Math.abs(mantissa);
            // ËÆ°ÁÆó log10(absMantissa) + exponent * log10(2)
            let log10_x = Math.log10(absMantissa) + exponent * FloatExp.LOG10_2;

            let decimalExponent = Math.floor(log10_x);
            let decimalMantissa = sign * Math.pow(10, log10_x - decimalExponent);

            return new FloatExp(decimalMantissa, decimalExponent);
        }

        async function* getReferenceOrbitFEMPFR(C, radius, iterations, precisionBits) {

            let Z = new DeepComplex(0, 0),
                z = new FloatExpComplex(0, 0),
                dzdc = new FloatExpComplex(1, 0),
                one = new FloatExpComplex(1, 0);
            const orbit = [new FloatExpComplex(0, 0)];
            let predCenter = null;


            const roundingMode = gmp.FloatRoundingMode.ROUND_DOWN;
            const options = { precisionBits: precisionBits, roundingMode };

            let gmpinit = await gmp.init();
            let ctx = gmpinit.getContext(options);

            let cre = ctx.Float(C.re.toString());
            let cim = ctx.Float(C.im.toString());
            let mpzre = ctx.Float(0);
            let mpzim = ctx.Float(0);
            let updateTimer = performance.now();

            const binding = gmpinit.binding;
            const tempVars = {
                re2: ctx.Float(0), im2: ctx.Float(0), reim: ctx.Float(0),
                temp1: ctx.Float(0), temp2: ctx.Float(0), buffer: ctx.Float(0)
            };

            for (let i = 0; i < iterations; i++) {
                dzdc = z.add(z).mulMut(dzdc).add(one);

                // Â§çÊï∞Âπ≥ÊñπËÆ°ÁÆó
                binding.mpfr_sqr(tempVars.re2.mpfr_t, mpzre.mpfr_t);
                binding.mpfr_sqr(tempVars.im2.mpfr_t, mpzim.mpfr_t);
                binding.mpfr_mul(tempVars.reim.mpfr_t, mpzre.mpfr_t, mpzim.mpfr_t);

                // Êñ∞ÂÆûÈÉ®: re^2 - im^2 + cre
                binding.mpfr_sub(mpzre.mpfr_t, tempVars.re2.mpfr_t, tempVars.im2.mpfr_t);
                binding.mpfr_add(mpzre.mpfr_t, mpzre.mpfr_t, cre.mpfr_t);

                // Êñ∞ËôöÈÉ®: 2*re*im + cim
                binding.mpfr_mul_2ui(mpzim.mpfr_t, tempVars.reim.mpfr_t, 1);
                binding.mpfr_add(mpzim.mpfr_t, mpzim.mpfr_t, cim.mpfr_t);

                z = new FloatExpComplex(MPFR2FloatExp(ctx, mpzre, binding, tempVars.buffer), MPFR2FloatExp(ctx, mpzim, binding, tempVars.buffer));
                orbit.push(z);
                if (dzdc.norm().mul(radius).mul(2).compareTo(z.norm()) > 0) {
                    predCenter = z.div(dzdc);
                    break;
                };
                if (z.norm().doubleValue() > 16.0) break;



                let currentTime = performance.now();
                if (currentTime - updateTimer > 100) {
                    updateTimer = currentTime;
                    yield i;
                    await delay(0);
                }
            }
            ctx.destroy();
            return {
                orbit: orbit,
                predCenter: predCenter
            };
        }

        function decompressRef(c, waypoints, maxIter) {
            let re = 0, im = 0;
            const orbit = [new Complex(0, 0)];

            const waypointKeys = Object.keys(waypoints);

            let iter = 0;
            while (iter < maxIter) {
                // if iter in waypoint, use waypoint value
                if (waypointKeys.includes(iter.toString())) {
                    re = waypoints[iter].re;
                    im = waypoints[iter].im;
                }
                // do standard mandelbrot iteration
                const re2 = re * re;
                const im2 = im * im;
                const re1 = re;
                const im1 = im;
                if (re2 + im2 > 16.0) break;
                im = 2 * re * im + c.im;
                re = re2 - im2 + c.re;
                orbit.push(new Complex(re, im));
                iter++;
            }
            return orbit;
        }

        function floorPowerOfTwo(n) {
            if (n <= 0) return 0;
            return Math.pow(2, Math.floor(Math.log2(n)));
        }
        const VAILD_SCALE = 5.960464477539063e-08;
        const DIP_DETECTION_THRESHOLD = 0.0009765625;

        // Complex Á±ªÂÆö‰πâÔºàÂÅáËÆæÂ∑≤Â≠òÂú®Ôºâ
        // class Complex { ... }

        class BLAStep {
            constructor(Z, A, B, radius, radiusC, length, next) {
                this.Z = Z;           // Complex
                this.A = A;           // Complex
                this.B = B;           // Complex
                this.radius = radius; // number
                this.radiusC = radiusC; // number
                this.length = length; // number
                this.next = next;     // number
            }

            /**
             * ÊâßË°å‰∏ÄÊ≠•Ëø≠‰ª£
             * @param {Complex} z - ‰∏ã‰∏Ä‰∏™Ëø≠‰ª£ÁÇπÁöÑÂÄº
             * @returns {[BLAStep, boolean]} - Êñ∞ÁöÑÊ≠•È™§ÂíåÊòØÂê¶Ê£ÄÊµãÂà∞‰∏ãÈôç
             */
            step(z) {
                let radius = z.norm() * VAILD_SCALE;
                let result = new BLAStep(
                    this.Z,
                    this.A.mul(z).mul(2),
                    this.B.mul(z).mul(2).add(1),
                    Math.min(this.radius, radius / this.A.norm()),
                    Math.min(this.radiusC, radius / this.B.norm()),
                    this.length + 1,
                    this.next
                );

                let dipDetected = result.radius < this.radius * DIP_DETECTION_THRESHOLD;
                return [result, dipDetected];
            }

            /**
             * ÂêàÂπ∂‰∏§‰∏™Ê≠•È™§
             * @param {BLAStep} other - Ë¶ÅÂêàÂπ∂ÁöÑÂè¶‰∏Ä‰∏™Ê≠•È™§
             * @returns {[BLAStep, boolean]} - ÂêàÂπ∂ÂêéÁöÑÊ≠•È™§ÂíåÊòØÂê¶Ê£ÄÊµãÂà∞‰∏ãÈôç
             */
            merge(other) {
                let radius = other.Z.norm() * VAILD_SCALE;
                let result = new BLAStep(
                    this.Z,
                    this.A.mul(other.Z).mul(2),
                    this.B.mul(other.Z).mul(2),
                    Math.min(this.radius, radius / this.A.norm()),
                    Math.min(this.radiusC, radius / this.B.norm()),
                    this.length + other.length,
                    this.next
                );

                let dipDetected = result.radius < this.radius * DIP_DETECTION_THRESHOLD;

                result.radius = Math.min(result.radius, other.radius / result.A.norm());
                result.radiusC = Math.min(result.radiusC, other.radius / result.B.norm());
                result.A = result.A.mul(other.A);
                result.B = result.B.mul(other.A).add(other.B);

                return [result, dipDetected];
            }

            /**
             * Ê£ÄÊü•ÊòØÂê¶Ê£ÄÊµãÂà∞‰∏ãÈôç
             * @param {Complex} z - ‰∏ã‰∏Ä‰∏™Ëø≠‰ª£ÁÇπÁöÑÂÄº
             * @returns {boolean} - ÊòØÂê¶Ê£ÄÊµãÂà∞‰∏ãÈôç
             */
            detectDip(z) {
                return z.norm() * VAILD_SCALE / this.A.norm() < this.radius * DIP_DETECTION_THRESHOLD;
            }

            /**
             * ËΩ¨Êç¢‰∏∫ÊôÆÈÄöÂØπË±°ÔºàÁî®‰∫éÂÖºÂÆπÊóßÁöÑAPIÔºâ
             */
            toObject() {
                return {
                    Z: this.Z,
                    A: this.A,
                    B: this.B,
                    radius: this.radius,
                    radiusC: this.radiusC,
                    length: this.length,
                    next: this.next
                };
            }

            /**
             * ÂàõÂª∫Êñ∞ÁöÑBLAÊ≠•È™§
             * @param {number} i - Á¥¢Âºï
             * @param {Complex} z - ZÂÄº
             * @returns {BLAStep} - Êñ∞ÁöÑÊ≠•È™§
             */
            static newBLA(i, z) {
                return new BLAStep(
                    z,
                    new Complex(1, 0),
                    new Complex(1, 0),
                    1,
                    1,
                    1,
                    i
                );
            }

            /**
             * ÂàõÂª∫ÂàùÂßãÁöÑBLAÊ≠•È™§
             * @param {number} i - Á¥¢Âºï
             * @param {Complex} a - AÂÄº
             * @param {Complex} b - BÂÄº
             * @returns {BLAStep} - Êñ∞ÁöÑÊ≠•È™§
             */
            static createBLA(i, a, b) {
                console.log(a);
                return new BLAStep(
                    a,
                    b.mul(2),
                    b.mul(2).add(1),
                    b.norm() * VAILD_SCALE,
                    b.norm() * VAILD_SCALE,
                    2,
                    i
                );
            }
        }

        class BLAStage {
            constructor(begin, end) {
                this.begin = begin; // number
                this.end = end;     // number
            }

            /**
             * Ëé∑ÂèñÊ≠•È™§ËåÉÂõ¥
             * @returns {[number, number]} - [begin, end]
             */
            getRange() {
                return [this.begin, this.end];
            }

            /**
             * ËΩ¨Êç¢‰∏∫Êï∞ÁªÑÊ†ºÂºèÔºàÁî®‰∫éÂÖºÂÆπÊóßÁöÑAPIÔºâ
             */
            toArray() {
                return [this.begin, this.end];
            }
        }

        class BLATable {
            constructor() {
                this.stages = []; // BLAStage[]
                this.steps = [];  // BLAStep[]
                this.hasBLA = false;
            }

            /**
             * ÁîüÊàêBLAË°®
             * @param {Complex[]} ref - ÂèÇËÄÉËΩ®ÈÅì
             * @param {number} scale - ÂΩìÂâçÂõæÂÉèÊØî‰æã
             * @returns {BLATable} - ÂàõÂª∫ÁöÑBLAË°®
             */
            static create(ref, scale) {
                const table = new BLATable();
                let result = table._createBLAStep(ref, scale);

                if (!result.hasBLA || ref.length < 8) {
                    table.hasBLA = false;
                    return table;
                }

                do {
                    result = table._createBLAStage(result.stages, result.steps, ref, scale);
                } while (result.hasBLA);

                table.stages = result.stages;
                table.steps = result.steps;
                table.hasBLA = true;
                return table;
            }

            _createBLAStep(ref, scale) {
                let period = 0;
                let refLen = ref.length - 1;
                console.log(ref);

                let blaStages = [];
                let blaSteps = [];

                let bla = BLAStep.createBLA(0, new Complex(0, 0), ref[1]);
                let i;
                for (i = 2; i < refLen; i++) {
                    const [result, detected] = bla.step(ref[i]);
                    if (detected) {
                        period = i;
                        break;
                    }
                    bla = result;
                }

                blaSteps.push(bla);

                if (!period) {
                    blaStages.push(new BLAStage(0, 1));
                    blaSteps.push(BLAStep.newBLA(0, ref[refLen]));
                    return {
                        hasBLA: false,
                        steps: blaSteps,
                        stages: blaStages
                    };
                }

                if (i + 1 >= refLen) {
                    bla = BLAStep.newBLA(i, ref[i]);
                    i++;
                } else {
                    bla = BLAStep.createBLA(i, ref[i], ref[i + 1]);
                    i += 2;
                }

                for (; i < refLen; i++) {
                    const [result, detected] = bla.step(ref[i]);

                    if (detected || bla.length >= period) {
                        blaSteps.push(bla);

                        if (i + 1 >= refLen || result.detectDip(ref[i + 1])) {
                            bla = BLAStep.newBLA(i, ref[i]);
                        } else {
                            bla = BLAStep.createBLA(i, ref[i], ref[i + 1]);
                            i++;
                        }
                    } else {
                        bla = result;
                    }
                }

                blaSteps.push(bla);
                blaStages.push(new BLAStage(0, blaSteps.length));
                blaSteps.push(BLAStep.newBLA(0, ref[refLen]));

                return {
                    hasBLA: true,
                    steps: blaSteps,
                    stages: blaStages
                };
            }

            _createBLAStage(stages, steps, ref, scale) {
                let prev = stages[stages.length - 1];
                let begin = steps.length;

                let period = 0;
                let i = prev.begin;

                let step = steps[i].merge(steps[i + 1])[0];
                step.next = i;
                i += 2;

                for (; i < prev.end; i++) {
                    const [result, detected] = step.merge(steps[i]);

                    if (detected) {
                        period = step.length;
                        steps.push(step);

                        if (i + 1 >= prev.end || result.detectDip(steps[i + 1].Z)) {
                            step = steps[i];
                            step.next = i;
                            i++;
                        } else {
                            step = steps[i].merge(steps[i + 1])[0];
                            step.next = i;
                            i += 2;
                        }
                        break;
                    }
                    step = result;
                }

                if (!period) {
                    steps.push(step);
                    stages.push(new BLAStage(begin, steps.length));
                    steps.push(steps[prev.end]);
                    return {
                        hasBLA: false,
                        steps: steps,
                        stages: stages
                    };
                }

                for (; i < prev.end; i++) {
                    const [result, detected] = step.merge(steps[i]);

                    if (detected || step.length >= period) {
                        steps.push(step);

                        if (i + 1 >= prev.end || result.detectDip(steps[i + 1].Z)) {
                            step = steps[i];
                            step.next = i;
                        } else {
                            step = steps[i].merge(steps[i + 1])[0];
                            step.next = i;
                            i++;
                        }
                    } else {
                        step = result;
                    }
                }

                steps.push(step);
                stages.push(new BLAStage(begin, steps.length));
                steps.push(steps[prev.end]);

                return {
                    hasBLA: true,
                    steps: steps,
                    stages: stages
                };
            }

            /**
             * Ëé∑ÂèñBLA‰ø°ÊÅØÔºàÁî®‰∫éÂÖºÂÆπÊóßÁöÑAPIÔºâ
             */
            getBLAInfo() {
                return {
                    bla: this.hasBLA,
                    stages: this.stages.map(stage => stage.toArray()),
                    steps: this.steps.map(step => step.toObject())
                };
            }
        }

        /**
         * ÁîüÊàêBLAË°®Ôºà‰øùÊåÅÂéüÊúâÁöÑAPIÁ≠æÂêç‰∏çÂèòÔºâ
         * @param {Complex[]} ref - ÂèÇËÄÉËΩ®ÈÅì
         * @param {number} scale - ÂΩìÂâçÂõæÂÉèÊØî‰æã
         * @returns {object} - BLA‰ø°ÊÅØ
         */
        function createBLATable(ref, scale) {
            const table = BLATable.create(ref, scale);
            return table;
        }


        function lookup(table, i, refLen, norm_dz, norm_dc) {
            if (i === 0 || i >= refLen || table.length === 0) {
                return {
                    first: null,
                    second: 0
                };
            }

            let result = {
                first: null,
                second: 0
            }; // { step, length }
            let index = i - 1,
                length = 1;

            for (let level of table) {
                if (norm_dz > level[index].radius || norm_dc > level[index].radiusC) {
                    break;
                }
                result.first = level[index];
                result.second = length;

                if (index % 2) {
                    break;
                }
                index >>= 1; // equivalent to index = Math.floor(index / 2)
                length <<= 1; // equivalent to length *= 2
            }

            result.second = Math.min(result.second, refLen - i);
            return result;
        }

        function createBLATableFE(ref, scale) {
            const lv1 = [];
            const table = [lv1];
            for (let i = 1; i < ref.length; i++) {
                const point = ref[i];

                const A = point.mul(2);
                const B = FloatExpComplex.ONE.copy();
                lv1.push({
                    A: A,
                    B: B,
                    radius: point.norm().mul(5.96e-8),
                    radiusC: FloatExp.INFINITY.copy()
                })
            }

            let level = 1;
            while (true) {
                table.push([]);

                for (let i = 0; i < table[level - 1].length; i += 2) {
                    const bla1 = table[level - 1][i];
                    const bla2 = table[level - 1][i + 1];

                    if (bla2 == null) {
                        table[level].push(bla1)
                        continue;
                    };

                    table[level].push({
                        A: bla1.A.mul(bla2.A),
                        B: bla1.B.mul(bla2.A).add(bla2.B),
                        radius: FloatExp.min(
                            bla1.radius, bla2.radius.div(bla1.A.norm())
                        ),
                        radiusC: FloatExp.min(
                            bla1.radiusC, bla2.radiusC, bla2.radius.div(bla1.B.norm())
                        )
                    })

                }
                if (table[level].length <= 1) break;
                level++;
            }

            return table;
        }

        function lookupFE(table, i, refLen, norm_dz, norm_dc) {
            if (i === 0 || i >= refLen || table.length === 0) {
                return {
                    first: null,
                    second: 0
                };
            }

            let result = {
                first: null,
                second: 0
            }; // { step, length }
            let index = i - 1,
                length = 1;

            for (let level of table) {
                if (norm_dz.compareTo(level[index].radius) > 0 || norm_dc.compareTo(level[index].radiusC) > 0) {
                    break;
                }
                result.first = level[index];
                result.second = length;

                if (index % 2) {
                    break;
                }
                index >>= 1; // equivalent to index = Math.floor(index / 2)
                length <<= 1; // equivalent to length *= 2
            }

            result.second = Math.min(result.second, refLen - i);
            return result;
        }


        /**
         * Calculates the escape time for a point in the Mandelbrot set using perturbation theory.
         * @param {Complex} dc - The perturbation applied to the point.
         * @param {Complex[]} ref - The reference orbit.
         * @param {number} maxIter - The maximum iteration.
         * @param {number} bailout - The bailout value used for iteration termination.
         * @returns {number|null} - The escape time for the point or null if it doesn't escape.
         */
        function getPTBLA(dc, ref, steps, stages, maxIter, bailout, smooth = false) {
            let dcNorm = dc.norm()

            let dz = new Complex(0, 0);
            let z = new Complex(0, 0);
            let Z = new Complex(0, 0)

            let tempVars = {
                stepZZ: new Complex(0, 0),
                dzA: new Complex(0, 0),
                dcB: new Complex(0, 0),
                newDz: new Complex(0, 0)
            }

            let i = 0, j = 0;
            let stage = stages.length;
            if (stage != 0) j = stages[stage - 1].begin;

            while (stage) {
                stage--;
                let begin = stages[stage].begin;
                let end = stages[stage].end;

                while (i < maxIter) {
                    let step = steps[j];
                    step.Z.addTo(z, tempVars.stepZZ);
                    tempVars.stepZZ.mulTo(dz, tempVars.newDz);
                    // const newDz = dz.mul(step.Z.add(z))
                    if (tempVars.newDz.norm() > step.radius || dcNorm > step.radiusC) {
                        j = step.next;
                        break;
                    }

                    // dz = newDz.mul(step.A).addMut(dc.mul(step.B))
                    tempVars.newDz.mulTo(step.A, tempVars.dzA);
                    dc.mulTo(step.B, tempVars.dcB);
                    tempVars.dzA.addTo(tempVars.dcB, dz);


                    i += step.length;
                    j++;

                    z = dz.add(steps[j].Z);

                    if (j == end || z.norm() < dz.norm()) {
                        j = begin;
                        dz = z;
                    }
                }
            }

            Z = ref[j];


            while (i < maxIter) {
                // dz = dz.mul(Z.add(z)).add(dc);
                Z.addTo(z, tempVars.stepZZ);
                dz.mulTo(tempVars.stepZZ, tempVars.newDz);
                tempVars.newDz.addTo(dc, dz);

                i++; j++;

                Z = ref[j];
                z = Z.add(dz);

                if (z.abs() > bailout) {
                    break
                }

                if (j == ref.length - 1 || z.norm() < dz.norm()) {
                    Z = new Complex(0, 0);
                    dz = z;
                    j = 0;
                }
            }
            return i;
        }

        function getPTBLAFE(dc, ref, table, maxIter, bailout, smooth = false) {
            let dz = FloatExpComplex.ZERO.copy();

            let iter = -1;
            let refIter = 0;
            let bout = new FloatExp(bailout);
            let zero = FloatExp.ZERO;
            let dcNorm = dc.norm();
            let dz2 = FloatExpComplex.ZERO.copy();

            let a = FloatExp.ZERO.copy();
            let val = FloatExpComplex.ZERO.copy();

            while (iter < maxIter) {
                let dzNorm = dz.norm();
                let result = lookupFE(table, refIter, ref.length, dzNorm, dcNorm)

                if (result.first != null) {
                    dz.mulMut(result.first.A).addMut(dc.mul(result.first.B));
                    iter += result.second;
                    refIter += result.second;
                } else {
                    const Z = ref[refIter]
                    dz.squareTo(dz2);
                    // dz = 2*dz*Z + dz^2 + dc
                    dz.addMut(dz).mulMut(Z).addMut(dz2).addMut(dc)
                    iter++;
                    refIter++;
                }
                if (refIter >= ref.length) refIter = 0;

                const Z2 = ref[refIter]
                Z2.addTo(dz, val);
                const valAbs = val.abs2();
                if (valAbs.doubleValue() > bailout) {
                    if (smooth) {
                        let fracIter = Math.log(valAbs.doubleValue()) / 2;
                        fracIter = Math.log(fracIter / Math.LN2) / Math.LN2;
                        iter += 1 - fracIter;
                        return iter;
                    } else {
                        return iter; // If not smooth, just return the iteration count
                    }
                };
                valAbs.subTo(dzNorm, a);

                if (a.compareTo(zero) < 0 || refIter == ref.length - 1) { // Ê£ÄÊµãÊòØÂê¶ÈúÄË¶ÅÂèòÂü∫
                    val.storeTo(dz);
                    refIter = 0;
                }
            }
            return iter;
        }

        /**
         * Generates a rainbow palette of colors.
         * @param {number} numColors - The number of colors to generate.
         * @returns {number[][]} - An array containing RGBA values for each color in the palette.
         */
        function generateRainbowPalette(numColors) {
            const rainbowColors = [];
            const frequency = 0.2; // Adjust the frequency to change the spread of colors

            for (let i = 0; i < numColors; i++) {
                const red = Math.sin(frequency * i) * 127 + 128;
                const green = Math.sin(frequency * 1.1 * i) * 127 + 128;
                const blue = Math.sin(frequency * 1.2 * i) * 127 + 128;
                rainbowColors.push([red | 0, green | 0, blue | 0, 255]);
            }

            return rainbowColors;
        }

        let defaultPalette = [[1, 1, 1], [205, 92, 92], [240, 128, 128], [255, 0, 0], [178, 34, 34], [139, 0, 0], [188, 143, 143], [165, 42, 42], [128, 0, 0], [250, 128, 114], [255, 99, 71], [233, 150, 122], [255, 127, 80], [255, 69, 0], [255, 160, 122], [160, 82, 45], [210, 105, 30], [139, 69, 19], [244, 164, 96], [255, 218, 185], [205, 133, 63], [255, 228, 196], [255, 140, 0], [222, 184, 135], [210, 180, 140], [255, 222, 173], [255, 228, 181], [255, 165, 0], [245, 222, 179], [184, 134, 11], [218, 165, 32], [255, 215, 0], [240, 230, 140], [238, 232, 170], [189, 183, 107], [255, 255, 0], [128, 128, 0], [107, 142, 35], [154, 205, 50], [85, 107, 47], [173, 255, 47], [127, 255, 0], [124, 252, 0], [0, 255, 0], [50, 205, 50], [152, 251, 152], [144, 238, 144], [34, 139, 34], [0, 128, 0], [0, 100, 0], [143, 188, 143], [46, 139, 87], [60, 179, 113], [0, 255, 127], [0, 250, 154], [102, 205, 170], [127, 255, 212], [64, 224, 208], [32, 178, 170], [72, 209, 204], [0, 139, 139], [0, 128, 128], [0, 255, 255], [175, 238, 238], [0, 206, 209], [95, 158, 160], [176, 224, 230], [173, 216, 230], [0, 191, 255], [135, 206, 235], [135, 206, 250], [70, 130, 180], [30, 144, 255], [176, 196, 222], [100, 149, 237], [65, 105, 225], [0, 0, 255], [0, 0, 205], [0, 0, 139], [0, 0, 128], [25, 25, 112], [106, 90, 205], [72, 61, 139], [123, 104, 238], [147, 112, 219], [138, 43, 226], [75, 0, 130], [153, 50, 204], [148, 0, 211], [186, 85, 211], [216, 191, 216], [221, 160, 221], [238, 130, 238], [255, 0, 255], [139, 0, 139], [128, 0, 128], [218, 112, 214], [199, 21, 133], [255, 20, 147], [255, 105, 180], [219, 112, 147], [220, 20, 60], [255, 192, 203], [255, 182, 193], [220, 220, 220], [211, 211, 211], [192, 192, 192], [169, 169, 169], [128, 128, 128], [105, 105, 105], [119, 136, 153], [112, 128, 144], [47, 79, 79]]
        let palette = defaultPalette;
        let colorStep = 6;
        /**
         * Calculates the color transition between two colors in a palette based on a percentage.
         * @param {number[][]} pal - The palette containing RGB values for colors.
         * @param {number} it - The percentage of transition between two colors (0 to 1).
         * @returns {number[]} - An array containing RGB values for the interpolated color.
         */
        function colorTrans(pal, it) {
            var percent = it - Math.floor(it);
            var c1 = Math.floor(it) % pal.length;
            var c2 = (c1 + 1) % pal.length;
            var r = (1 - percent) * pal[c1][0] + (percent) * pal[c2][0];
            var g = (1 - percent) * pal[c1][1] + (percent) * pal[c2][1];
            var b = (1 - percent) * pal[c1][2] + (percent) * pal[c2][2];
            return [r, g, b]
        }

        /**
         * Gets the color associated with the escape time 'it'.
         * @param {number|null} it - The escape time for a point or null if it doesn't escape.
         * @returns {number[]} - An array containing RGBA values for the color associated with the escape time.
         */
        function getColor(it, maxIter) {
            if (it == null || it >= maxIter) return [0, 0, 0, 255];
            else if (it < 0) return [palette[0][0], palette[0][1], palette[0][2], 255];
            let color = colorTrans(palette, it / colorStep);
            return [color[0], color[1], color[2], 255];
        }

        function groupArray(arr, groupSize = 3) {
            if (!arr || arr.length === 0 || groupSize <= 0) {
                return [];
            }

            const result = [];
            for (let i = 0; i < arr.length; i += groupSize) {
                result.push(arr.slice(i, i + groupSize));
            }
            return result;
        }

        function base64ToByteArray(base64String) {
            try {
                // ËøòÂéüÂ≠óÁ¨¶Âπ∂Â∞ÜURLÂÆâÂÖ®ÁöÑBase64ËΩ¨Êç¢‰∏∫Ê†áÂáÜBase64
                let base64 = base64String.replace(/-/g, '+').replace(/_/g, '/');

                // Ê∑ªÂä† padding (Á°Æ‰øùÈïøÂ∫¶ÊòØ4ÁöÑÂÄçÊï∞)
                const padLength = (4 - (base64.length % 4)) % 4;
                base64 += '='.repeat(padLength);

                const binaryString = atob(base64); // Ëß£Á†ÅBase64
                const byteArray = new Uint8Array(binaryString.length);

                for (let i = 0; i < binaryString.length; i++) {
                    byteArray[i] = binaryString.charCodeAt(i);
                }

                return Array.from(byteArray);
            } catch (error) {
                throw new Error("ËæìÂÖ•‰∏çÊòØ‰∏Ä‰∏™ÊúâÊïàÁöÑURLÂÆâÂÖ®Base64Â≠óÁ¨¶‰∏≤„ÄÇ");
            }
        }

        function byteArrayToBase64(byteArray) {
            if (!Array.isArray(byteArray)) {
                throw new Error("ËæìÂÖ•ÂøÖÈ°ªÊòØ‰∏Ä‰∏™Êï∞ÁªÑ„ÄÇ");
            }

            // È™åËØÅÂ≠óËäÇÊï∞ÁªÑ
            if (byteArray.some(v => typeof v !== 'number' || !Number.isInteger(v) || v < 0 || v > 255)) {
                throw new Error("Êï∞ÁªÑ‰∏≠ÁöÑÊØè‰∏™ÂÖÉÁ¥†ÂøÖÈ°ªÊòØ0-255‰πãÈó¥ÁöÑÊï¥Êï∞„ÄÇ");
            }

            // ÊûÑÂª∫‰∫åËøõÂà∂Â≠óÁ¨¶‰∏≤
            const binaryString = String.fromCharCode(...byteArray);

            // ÁºñÁ†ÅÂπ∂ËΩ¨Êç¢‰∏∫URLÂÆâÂÖ®Ê†ºÂºè
            const base64 = btoa(binaryString)
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=+$/, '');

            return base64;
        }

        /**
         * Represents a Mandelbrot set visualization.
         */
        class Mandelbrot {
            center;
            iterations;
            bailout;
            size;

            canvas;
            context;

            ref;

            refValid;

            stats;

            img;

            rendering;

            /**
             * @param {HTMLCanvasElement} canvas - The canvas element to draw the Mandelbrot set.
             * @param {DeepComplex} center - The center point of the Mandelbrot set.
             * @param {number} iterations - The number of iterations to perform for each point.
             * @param {number} bailout - The bailout value used for iteration termination.
             */
            constructor(canvas, center, iterations, bailout) {
                this.center = center;
                this.iterations = iterations;
                this.bailout = bailout * bailout;
                this.smooth = false;

                this.size = FloatExp.FOUR.copy();
                this.deep = false;

                this.canvas = canvas;
                this.context = canvas.getContext('2d');
                this.rendering = false;
                this.iterMap = null;
                this.videoRendering = false;

                // NEW: Interaction State
                this.transformState = { scale: 1, tx: 0, ty: 0 };
                this.isInteracting = false;
                this.dragStartPoint = { x: 0, y: 0 };
                this.transformAtDragStart = { scale: 1, tx: 0, ty: 0 };
                this.recalculationTimeout = null;
                this.lastTouchDistance = 0;

                this.canvas.addEventListener('mousedown', e => this.handleStart(e));
                this.canvas.addEventListener('mousemove', e => this.handleMove(e));
                this.canvas.addEventListener('mouseup', e => this.handleEnd(e));
                this.canvas.addEventListener('mouseleave', e => this.handleEnd(e));
                this.canvas.addEventListener('wheel', e => this.handleWheel(e), { passive: false });
                this.canvas.addEventListener('touchstart', e => this.handleStart(e), { passive: false });
                this.canvas.addEventListener('touchmove', e => this.handleMove(e), { passive: false });
                this.canvas.addEventListener('touchend', e => this.handleEnd(e));
                this.canvas.addEventListener('touchcancel', e => this.handleEnd(e));

                const resizeObserver = new ResizeObserver(() => {
                    this.resizeCanvas();
                });

                resizeObserver.observe(this.canvas);

                this.stats = {
                    ref: 0,
                    calc: 0,
                    guess: 0,
                    approx: 0,
                    time: performance.now(),
                    statusText: ''
                }

                this.lastUpdateTime = performance.now();

                // Cancelling state
                this.requestForCancel = false;
                this.cancelling = false;

                // Initial setup
                this.resizeCanvas(false); // Set initial size without triggering update
            }

            resizeCanvas(triggerUpdate = true) {
                let dpr = window.devicePixelRatio;
                this.canvas.width = window.innerWidth * dpr;
                this.canvas.height = window.innerHeight * dpr;
                this.iterMap = [...new Array(this.canvas.height)].map(e => new Float64Array(this.canvas.width));
                if (triggerUpdate) {
                    this.clear();
                    this.update();
                }
                this.minStep = Math.min(this.canvas.width, this.canvas.height);
                this.halfWidth = this.canvas.width / 2;
                this.halfHeight = this.canvas.height / 2;
            }

            handleStart(e) {
                e.preventDefault();
                this.isInteracting = true;
                this.cancel();

                if (e.touches) {
                    this.dragStartPoint = this.getTouchCenter(e.touches);
                    if (e.touches.length === 2) {
                        this.lastTouchDistance = this.getTouchDistance(e.touches);
                    }
                } else {
                    this.dragStartPoint = { x: e.clientX, y: e.clientY };
                }
                // Store the state at the beginning of the interaction
                this.transformAtDragStart = { ...this.transformState };
            }

            handleMove(e) {
                if (!this.isInteracting) return;
                e.preventDefault();

                if (e.touches) {
                    const currentTouchCenter = this.getTouchCenter(e.touches);
                    // Pan
                    const dx = currentTouchCenter.x - this.dragStartPoint.x;
                    const dy = currentTouchCenter.y - this.dragStartPoint.y;
                    this.transformState.tx = this.transformAtDragStart.tx + dx;
                    this.transformState.ty = this.transformAtDragStart.ty + dy;

                    // Pinch zoom
                    if (e.touches.length === 2) {
                        const currentDist = this.getTouchDistance(e.touches);
                        const scaleFactor = currentDist / this.lastTouchDistance;
                        // Combine with existing scale
                        const newScale = this.transformAtDragStart.scale * scaleFactor;

                        // Zoom towards the original touch center
                        const pivot = this.dragStartPoint;
                        this.transformState.tx = pivot.x - (pivot.x - this.transformAtDragStart.tx) * scaleFactor + dx;
                        this.transformState.ty = pivot.y - (pivot.y - this.transformAtDragStart.ty) * scaleFactor + dy;
                        this.transformState.scale = newScale;
                    }
                } else { // Mouse drag
                    const dx = e.clientX - this.dragStartPoint.x;
                    const dy = e.clientY - this.dragStartPoint.y;
                    this.transformState.tx = this.transformAtDragStart.tx + dx;
                    this.transformState.ty = this.transformAtDragStart.ty + dy;
                }

                // Update overlay info during interaction, if not in deep mode for performance
                if (!this.deep) {
                    const delta = this.getCurrentUIDelta();
                    const newCenter = this.center.add(delta);
                    updateInfoOverlay(
                        newCenter.re,
                        newCenter.im,
                        FloatExp.FOUR.div(this.size.div(this.transformState.scale)),
                        this.iterations
                    )
                }
                this.applyCssTransform();
            }

            handleEnd(e) {
                if (!this.isInteracting) return;
                this.isInteracting = false;
                this.applyTransformAndRecalculate();
            }

            handleWheel(e) {
                this.canvas.classList.add(e.fake ? 'transition-long' : 'transition')
                e.preventDefault();

                const scaleFactor = e.fake ? 4 : e.deltaY < 0 ? 2 : 0.5;
                const pivotX = e.clientX;
                const pivotY = e.clientY;

                this.transformState.tx = pivotX - (pivotX - this.transformState.tx) * scaleFactor;
                this.transformState.ty = pivotY - (pivotY - this.transformState.ty) * scaleFactor;
                this.transformState.scale *= scaleFactor;

                this.applyCssTransform();
                this.triggerRecalculation(e.fake ? 200 : 100);
            }

            // --- Helper functions for touch events ---
            getTouchCenter(touches) {
                let centerX = 0, centerY = 0;
                for (const touch of touches) {
                    centerX += touch.clientX;
                    centerY += touch.clientY;
                }
                return { x: centerX / touches.length, y: centerY / touches.length };
            }

            getTouchDistance(touches) {
                return Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
            }

            applyCssTransform() {
                const { scale, tx, ty } = this.transformState;
                this.canvas.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
            }

            triggerRecalculation(delay = 100) {
                clearTimeout(this.recalculationTimeout);
                this.recalculationTimeout = setTimeout(() => {
                    this.applyTransformAndRecalculate();
                }, delay);
            }

            getCurrentUIDelta() {
                const { scale, tx, ty } = this.transformState;
                const canvasX = ((canvas.width * 0.5) - tx / canvas.offsetWidth * canvas.width) / scale;
                const canvasY = ((canvas.height * 0.5) - ty / canvas.offsetHeight * canvas.height) / scale;
                const delta = this.getDelta(canvasX, canvasY);
                return delta
            }

            applyTransformAndRecalculate() {
                const { scale, tx, ty } = this.transformState;

                if (Math.abs(scale - 1) < 1e-9 && Math.abs(tx) < 1 && Math.abs(ty) < 1) {
                    return;
                }

                console.log(`Applying transform: scale=${scale}, tx=${tx}, ty=${ty}`);

                // Map canvas screen delta to canvas coordinate delta
                const delta = this.getCurrentUIDelta();

                // Update mathematical state
                this.goto(
                    this.center.add(delta), false
                )

                // Only zoom if scale is changed, otherwise just translate
                // Use 1e-9 as threshold to avoid floating point issues
                if (Math.abs(scale - 1) > 1e-9) {
                    this.zoom(this.size.div(scale));
                } else {
                    const translateX = tx / canvas.offsetWidth * canvas.width;
                    const translateY = ty / canvas.offsetHeight * canvas.height;
                    this.translate(translateX, translateY);
                }
                // Calculate the source rectangle from the old canvas content that is currently visible.
                const sx = -(tx / canvas.offsetWidth * canvas.width) / scale;
                const sy = -(ty / canvas.offsetHeight * canvas.height) / scale;
                const sWidth = this.canvas.width / scale;
                const sHeight = this.canvas.height / scale;

                // The CSS transform is about to be removed. To prevent a flicker,
                // we use drawImage to "bake" the transformed view into the canvas bitmap.
                // This creates an immediate, low-resolution preview.

                // Important: FIRST, reset the CSS transform so the canvas snaps back to its original state.
                // The browser won't render this change until the current script finishes,
                // so the user won't see the "snap".
                this.canvas.style.transform = '';
                this.context.globalCompositeOperation = 'copy';

                // THEN, draw the calculated portion of the (now untransformed) canvas back onto itself,
                // scaled up to fill the whole view. This effectively applies the transform permanently.
                this.context.drawImage(
                    this.canvas,   // Source image is the canvas itself
                    sx, sy, sWidth, sHeight,  // Source rectangle
                    0, 0, this.canvas.width, this.canvas.height // Destination rectangle (the whole canvas)
                );

                // Reset visual transform state for the next render
                this.transformState = { scale: 1, tx: 0, ty: 0 };

                this.canvas.classList.remove('transition')
                this.canvas.classList.remove('transition-long')
                this.requestForCancel = false;
                this.cancelling = false;
                this.update(floorPowerOfTwo(Math.max(2, scale)));
            }

            zoomOut() {
                let newMap = [...new Array(this.canvas.height)].map(e => [...new Array(this.canvas.width)].map(e => 0))
                for (let y = 0; y < this.canvas.height; y += 2) {
                    for (let x = 0; x < this.canvas.width; x += 2) {
                        newMap
                        [this.canvas.height / 4 + y / 2]
                        [this.canvas.width / 4 + x / 2]
                            =
                            this.iterMap[y][x];
                    }
                }
                this.iterMap = newMap;
                this.size = this.size.mul(2);
            }

            /**
             * Zooms the Mandelbrot set visualization.
             * @param {FloatExp} size - The new size of the visualization.
             */
            zoom(size) {
                Decimal.config({
                    precision: -size.exp + 10
                })
                this.deep = this.size.exp < -300;
                this.size = size;
                this.clear();
                this.stats.predCenter = null;
            }

            /**
             * Clear iteration map
             */
            clear() {
                this.iterMap.forEach(e => e.fill(-1))
            }

            /**
             * Moves the center of the Mandelbrot set visualization.
             * @param {DeepComplex} c - The new center point.
             */
            goto(c, clear = true) {
                this.center = c;
                this.refValid = false;
                this.stats.predCenter = null;
                if (clear) {
                    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.clear();
                }
            }

            /**
             * Sets the number of iterations for the Mandelbrot set visualization.
             * @param {number} it - The number of iterations.
             */
            setIterations(it) {
                this.iterations = parseInt(it);
            }

            /**
             * Resets the Mandelbrot set visualization to its initial state.
             */
            home() {
                this.goto(new DeepComplex(new Decimal(0), new Decimal(0)))
                this.size = FloatExp.FOUR.copy();
                this.deep = false;
                this.iterations = 256;
            }

            /**
             * Calculates the delta between a point and the base point on the canvas.
             * @param {number} x - The x-coordinate of the point.
             * @param {number} y - The y-coordinate of the point.
             * @param {number} [baseX] - The x-coordinate of the base point (optional).
             * @param {number} [baseY] - The y-coordinate of the base point (optional).
             * @returns {FloatExpComplex} - The delta as a complex number.
             */
            getDelta(x, y, baseX, baseY) {
                if (!baseX) baseX = this.halfWidth;
                if (!baseY) baseY = this.halfHeight;
                let deltaPerPixel = this.size.div(this.minStep);
                return this.deep ? new FloatExpComplex(
                    deltaPerPixel.mul(x - baseX),
                    deltaPerPixel.mul(baseY - y)

                ) : new Complex(
                    (x - baseX) * deltaPerPixel,
                    (baseY - y) * deltaPerPixel
                )
            }

            /**
             * Converts a delta relative to the this.center to screen coordinates.
             **/
            deltaToScreen(delta) {
                let deltaPerPixel = this.size.div(this.minStep);
                if (this.deep) {
                    return {
                        x: delta.re.div(deltaPerPixel).doubleValue() + this.halfWidth,
                        y: this.halfHeight - delta.im.div(deltaPerPixel).doubleValue()
                    }
                } else {
                    return {
                        x: delta.re / deltaPerPixel + this.halfWidth,
                        y: this.halfHeight - delta.im / deltaPerPixel
                    }
                }
            }


            /**
             * Retrieves the iteration of a pixel in the Mandelbrot set visualization.
             * @param {number} x - The x-coordinate of the pixel.
             * @param {number} y - The y-coordinate of the pixel.
             * @returns {number} - The iteration of the given point.
             */
            getIter(x, y) {
                if (x >= this.canvas.width || x < 0 || y >= this.canvas.height || y <= 0) return -1
                return this.iterMap[y][x];
            }

            /**
             * Sets the iteration of a pixel in the Mandelbrot set visualization.
             * @param {number} x - The x-coordinate of the pixel.
             * @param {number} y - The y-coordinate of the pixel.
             * @param {number} it - The iteration
             * @param {number} w - The width of the pixel.
             * @param {number} h - The height of the pixel.
             */
            setIter(x, y, it, w = 1, h = 1) {
                this.iterMap[y][x] = it;

                const color = getColor(it, this.iterations);

                let i = (y * this.canvas.width + x) << 2;
                if (w == 1 && h == 1) {
                    this.image.data[i] = color[0]
                    this.image.data[i + 1] = color[1]
                    this.image.data[i + 2] = color[2]
                    this.image.data[i + 3] = 255
                } else {
                    for (let dy = 0; dy < h; dy++) {
                        for (let dx = 0; dx < w; dx++) {
                            let j = (dy * this.canvas.width + dx) << 2;
                            this.image.data[i + j] = color[0]
                            this.image.data[i + j + 1] = color[1]
                            this.image.data[i + j + 2] = color[2]
                            this.image.data[i + j + 3] = 255
                        }
                    }
                }
            }

            showInfo() {
                let totalPixels = this.canvas.width * this.canvas.height;
                let elapsedTime = performance.now() - this.stats.time;
                let estimatedTotalTime = (elapsedTime / (this.stats.calc + this.stats.guess)) * totalPixels;
                let estimatedRemainingTime = estimatedTotalTime - elapsedTime;
                let statusText = `Ref: ${this.stats.ref.toLocaleString()}it\nRes: ${this.canvas.width}x${this.canvas.height}\nCalc/Guess/Total: ${this.stats.calc.toLocaleString()}/${this.stats.guess.toLocaleString()}/${totalPixels.toLocaleString()} px\nTime: ${((elapsedTime) / 1000).toFixed(3)}s ETA: ${(estimatedRemainingTime / 1000).toFixed(3)}s`;
                statusText += "\n" + this.stats.statusText;
                statsLabel.innerText = statusText;
                this.updateProgress();
            }

            // NEW: Separate function for progress bar to be called by worker callback
            updateProgress() {
                let totalPixels = this.canvas.width * this.canvas.height;
                progressBar.style.width = `${((this.stats.calc) / totalPixels * 100).toFixed(2)}%`;
                guessedProgressBar.style.width = `${((this.stats.guess) / totalPixels * 100).toFixed(2)}%`;
            }

            /**
             * Updates the Mandelbrot set visualization.
             *
             */
            async update(startBlockSize = 128) {
                if (this.rendering) {
                    await this.cancel()
                };
                this.rendering = true;
                this.stats = {
                    ref: 0,
                    calc: 0,
                    guess: 0,
                    approx: 0,
                    time: performance.now()
                };

                let prevDeep = this.deep;
                this.deep = this.size.exp < -300;
                if (prevDeep && !this.deep) this.ref = this.ref.map(e => e.toComplex());

                updateInfoOverlay(this.center.re, this.center.im, FloatExp.FOUR.div(this.size), this.iterations);
                reInput.value = this.center.re.toString();
                imInput.value = this.center.im.toString();
                zoomInput.value = FloatExp.FOUR.div(this.size).toString();
                itInput.value = this.iterations;

                this.image = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);

                let base, ref;
                let refLen = 0;

                base = this.center;
                if (!this.refValid) {
                    console.log(performance.now() + " computing reference")
                    this.stats.statusText = 'Computing reference'
                    let nextTerm;

                    let precisionInBits = Math.ceil((-this.size.exp) * 3.321928094887362) + 52; // Add extra double precision bits

                    const generator = this.deep ?
                        getReferenceOrbitFEMPFR(base, this.size, this.iterations, precisionInBits) :
                        getReferenceOrbitMPFR(base, this.size.doubleValue(), this.iterations, precisionInBits);
                    while (!(nextTerm = await generator.next()).done) {
                        this.stats.ref = nextTerm.value;
                        this.showInfo(); // Update progress
                        if (this.requestForCancel) {
                            this.cancelling = true;
                            return;
                        }
                    }
                    ref = nextTerm.value.orbit;
                    let predCenter = nextTerm.value.predCenter;
                    if (predCenter) {
                        console.log("Predicted center: ", predCenter)
                        // predCenter.x = -predCenter.x;
                        this.stats.predCenter = predCenter;
                    }

                    this.stats.ref = ref.length;

                    this.ref = ref;
                    this.refValid = true;
                } else {
                    ref = this.ref;
                    this.stats.ref = ref.length;
                }
                refLen = ref.length;
                console.log("ref iter: " + ref.length)

                console.log(performance.now() + " bla calculation")
                this.stats.statusText = 'BLA table construction'

                if (this.deep) {
                    this.blaTable = createBLATableFE(ref, this.size.div(10));
                }
                else
                    this.blaTable = createBLATable(ref, this.size.doubleValue())

                console.log(this.blaTable)


                let autoIter = Math.max((refLen - 1) * 32, this.iterations);
                this.setIterations(autoIter);

                console.log(performance.now() + " perturbation")
                this.stats.statusText = 'Perturbation'

                await this.successiveRefinment(startBlockSize);

                // Distance estimation
                if (this.distanceEstimation) {
                    for (let y = 0; y < this.canvas.height - 1; y++) {
                        for (let x = 0; x < this.canvas.width - 1; x++) {
                            let gradX = this.iterMap[y][x + 1] - this.iterMap[y][x];
                            let gradY = this.iterMap[y + 1][x] - this.iterMap[y][x];
                            let diff = Math.sqrt(gradX * gradX + gradY * gradY);

                            let j = (y * this.canvas.width + x) << 2;

                            let color = getColor(Math.log1p(diff) * 32 / colorStep, 10000);

                            this.image.data[j] = color[0]
                            this.image.data[j + 1] = color[1]
                            this.image.data[j + 2] = color[2]
                            this.image.data[j + 3] = 255
                        }
                    }
                    this.context.putImageData(this.image, 0, 0)
                }

                console.log('done!')
                this.stats.statusText = 'Finished'
                this.rendering = false;
                this.showInfo();
                const params = new URLSearchParams(window.location.hash.substring(1));

                // Êõ¥Êñ∞ÊàñÊ∑ªÂä†Êñ∞ÁöÑÂèÇÊï∞
                params.set("rec", compressDecimal(this.center.re.toString()));
                params.set("imc", compressDecimal(this.center.im.toString()));
                params.set("zmc", compressDecimal(FloatExp.FOUR.div(this.size).toString()));
                params.set("itc", compressDecimal(this.iterations.toString()));
                params.set("bailout", Math.sqrt(this.bailout).toString());
                params.set("colorc", byteArrayToBase64(palette.flat(1)));
                params.set("colorstep", colorStep);
                params.set("smooth", this.smooth ? 1 : 0);

                // ÈáçÂª∫ÂìàÂ∏åÂ≠óÁ¨¶‰∏≤
                window.location.hash = params.toString();
            }

            async successiveRefinment(startSize) {
                // 1. ÂàùÂßãÂåñÈÖçÁΩÆ
                const TILE_SIZE = 64;
                const width = this.canvas.width;
                const height = this.canvas.height;
                const cx = width / 2;
                const cy = height / 2;
                // È¢ÑËÆ°ÁÆóÊúÄÂ§ßË∑ùÁ¶ªÂπ≥ÊñπÔºåÈÅøÂÖçÂºÄÊñπÔºåÊèêÂçáÂ∞ëËÆ∏ÊÄßËÉΩ
                const maxDistSq = cx * cx + cy * cy;

                // ËÅöÁÑ¶Âº∫Â∫¶ÔºöË∂äÂ§ß‰∏≠ÂøÉË∂ä‰ºòÂÖà„ÄÇ5.0 Â∑¶Âè≥ÊïàÊûúÂæàÊ£í„ÄÇ
                const FOCUS_STRENGTH = 5.0;
                const initialLog2 = Math.log2(startSize);

                let priorityQueue = [];

                // 2. Â°´ÂÖÖÂàùÂßã‰ªªÂä°
                for (let y = 0; y < height; y += TILE_SIZE) {
                    for (let x = 0; x < width; x += TILE_SIZE) {
                        let tcx = x + TILE_SIZE / 2;
                        let tcy = y + TILE_SIZE / 2;
                        // ÂΩí‰∏ÄÂåñË∑ùÁ¶ª (0~1)
                        let dist = Math.sqrt((tcx - cx) ** 2 + (tcy - cy) ** 2) / Math.sqrt(maxDistSq);

                        priorityQueue.push({
                            x: x, y: y, w: TILE_SIZE, h: TILE_SIZE,
                            step: startSize,
                            dist: dist
                        });
                    }
                }

                // 3. Â§ÑÁêÜÈòüÂàó
                while (priorityQueue.length > 0) {
                    if (this.requestForCancel) {
                        this.cancelling = true;
                        return;
                    }

                    // --- ‰ºòÂÖàÁ∫ßÊéíÂ∫è ---
                    // Score = Level + (Distance * Strength)
                    // step=1 ÁöÑ‰ªªÂä° level ÂæàÂ§ßÔºåÈÄöÂ∏∏ÊéíÂêéÈù¢Ôºå‰ΩÜÂ¶ÇÊûú Distance ÂæàÂ∞è(Âú®‰∏≠ÂøÉ)Ôºå
                    // ÂÆÉÁöÑ Score ‰ºöÊØîËæπÁºòÁöÑ step=8 ËøòÂ∞èÔºå‰ªéËÄåÂÆûÁé∞"‰∏≠ÂøÉÂÖàÂπ≥Êªë"ÁöÑÊïàÊûú„ÄÇ
                    priorityQueue.sort((a, b) => {
                        let levelA = initialLog2 - Math.log2(a.step);
                        let levelB = initialLog2 - Math.log2(b.step);

                        // ËøôÈáåÁªô step=1 (Final Pass) È¢ùÂ§ñÂä†‰∏ÄÁÇπÁÇπÊÉ©ÁΩöÊùÉÈáçÔºå
                        // Á°Æ‰øùÂú®Âêå‰∏ÄÂå∫ÂüüÂÜÖÔºåÂÖàÊää step=2 Èì∫ÂÆåÂÜçÂÅö step=1ÔºåÈÅøÂÖçÊï∞ÊçÆ‰æùËµñÁº∫Â§±
                        if (a.step === 1) levelA += 0.1;
                        if (b.step === 1) levelB += 0.1;

                        let scoreA = levelA + (a.dist * FOCUS_STRENGTH);
                        let scoreB = levelB + (b.dist * FOCUS_STRENGTH);
                        return scoreA - scoreB;
                    });

                    // ÂèñÂá∫‰ªªÂä°
                    const task = priorityQueue.shift();

                    // --- Ê†∏ÂøÉÊ∏≤ÊüìÈÄªËæë ---
                    if (task.step > 1) {
                        // > 1: Á≤óÁ≥ôÊ∏≤ÊüìÊ®°Âºè (Âè™ÁÆóÁΩëÊ†ºÔºåÁîªÊñπÂùó)
                        await this.renderCoarseTile(task);

                        // ÂàÜË£Ç‰ªªÂä°: ÊîæÂÖ•‰∏ã‰∏ÄÁ∫ß step
                        task.step >>= 1; // Èô§‰ª• 2
                        priorityQueue.push(task);
                    } else {
                        // = 1: Êô∫ËÉΩÁåúÊµãÊ®°Âºè (Final PassÔºåÂ∏¶ÊèíÂÄº)
                        await this.renderFinalTile(task);
                        // step 1 ÊòØÁªàÁÇπÔºå‰∏çÈúÄË¶ÅÂÜç push ÂõûÈòüÂàó
                    }

                    // await this.tryUpdateScreen();
                }

                // ÁªìÊùü
                await this.tryUpdateScreen();
                this.rendering = false;
            }

            /**
             * Ê®°Âºè A: Á≤óÁ≥ôÊ∏≤Êüì (Step > 1)
             * Âø´ÈÄüÂ°´ÂÖÖÁΩëÊ†ºÔºåÁªòÂà∂Â§ßÂÉèÁ¥†
             */
            async renderCoarseTile(task) {
                const { x: startX, y: startY, w, h, step } = task;
                const endX = Math.min(startX + w, this.canvas.width);
                const endY = Math.min(startY + h, this.canvas.height);

                // ÁΩëÊ†ºÂØπÈΩê
                const firstX = startX + (step - (startX % step)) % step;
                const firstY = startY + (step - (startY % step)) % step;

                for (let y = firstY; y < endY; y += step) {
                    for (let x = firstX; x < endX; x += step) {
                        // Â¶ÇÊûúÂ∑≤ÁªèË¢´ÁÆóËøá‰∫Ü(ÊØîÂ¶Ç‰∏ä‰∏ÄËΩÆ step*2 Áïô‰∏ãÁöÑÁÇπ)ÔºåÁõ¥Êé•Ë∑≥Ëøá
                        // Ê≥®ÊÑèÔºöËøôÈáåÈúÄË¶Å ensure iterMap ÊúâÂÄº„ÄÇ
                        // Â¶ÇÊûúÊòØÁ¨¨‰∏ÄËΩÆÔºåiterMap ÂèØËÉΩÊòØ -1„ÄÇ
                        if (this.iterMap[y][x] > -1) {
                            // Âè™ÊòØ‰∏∫‰∫ÜÂà∑Êñ∞ visualsÔºåÈáçÁªò‰∏Ä‰∏ã(ÂèØÈÄâÔºåÂ¶ÇÊûúËßâÂæóÈó™ÁÉÅÂèØ‰ª•ÂéªÊéâ)
                            // this.setIter(x, y, this.iterMap[y][x], step, step);
                        } else {
                            // ÁúüÊ≠£ÁöÑËÆ°ÁÆóÔºåÁîª‰∏Ä‰∏™ step x step ÁöÑÁü©ÂΩ¢
                            this.calculatePixel(x, y, step, step);
                        }
                    }
                    await this.tryUpdateScreen();
                }
            }

            /**
             * Ê®°Âºè B: Á≤æÁªÜÊ∏≤Êüì (Step = 1)
             * ÂåÖÂê´‚ÄúÁåúÊµã‚ÄùÈÄªËæëÔºåÂ°´Ë°• 1x1 ÁöÑÁ©∫Èöô
             */
            async renderFinalTile(task) {
                const { x: startX, y: startY, w, h } = task;
                const endX = Math.min(startX + w, this.canvas.width);
                const endY = Math.min(startY + h, this.canvas.height);

                for (let pass = 0; pass < 3; pass++) {
                    for (let y = startY; y < endY; y++) {
                        for (let x = startX; x < endX; x++) {
                            // 1. Â¶ÇÊûúËøô‰∏™ÁÇπÂ∑≤ÁªèÊúâÂÄº (Êù•Ëá™‰∫é step=2,4,8...)ÔºåË∑≥Ëøá
                            if (this.iterMap[y][x] > -1) {
                                // ÈáçÁªò‰∏Ä‰∏ãÊàê 1x1 (Ê∂àÈô§‰πãÂâçÁöÑÂ§ßÊñπÂùóÊÆãÁïô)
                                this.setIter(x, y, this.iterMap[y][x], 1, 1);
                                continue;
                            }

                            // 2. Â∞ùËØïÁåúÊµã (Guessing)
                            // Ê£ÄÊü•Ê∞¥Âπ≥ÈÇªÂ±Ö (Left & Right)
                            // Ê≥®ÊÑèÔºöÂõ†‰∏∫Êàë‰ª¨ÊòØ Tiled Â§ÑÁêÜÔºåËæπÁïåÂÉèÁ¥†ÂèØËÉΩÈúÄË¶ÅÂéª getIter ÊãøÂÖ∂‰ªñ Tile ÁöÑÊï∞ÊçÆ
                            // this.getIter Â∫îËØ•Â§ÑÁêÜË∂äÁïåËøîÂõû 0 Êàñ null
                            let left = this.getIter(x - 1, y);
                            let right = this.getIter(x + 1, y);

                            let guessed = false;

                            // Ê∞¥Âπ≥ÊèíÂÄºÁ≠ñÁï•
                            if (left > -1 && right > -1 && Math.floor(left) === Math.floor(right)) {
                                this.setIter(x, y, (left + right) / 2, 1, 1);
                                this.stats.guess++;
                                guessed = true;
                            }

                            // Â¶ÇÊûúÊ∞¥Âπ≥Áåú‰∏çÂá∫Êù•ÔºåËØïÂûÇÁõ¥ÊèíÂÄº (Top & Bottom)
                            if (!guessed) {
                                let up = this.getIter(x, y - 1);
                                let down = this.getIter(x, y + 1);

                                if (up > -1 && down > -1 && Math.floor(up) === Math.floor(down)) {
                                    this.setIter(x, y, (up + down) / 2, 1, 1);
                                    this.stats.guess++;
                                    guessed = true;
                                }
                            }

                            // 3. ÂÆûÂú®Áåú‰∏çÂá∫Êù•ÔºåÊö¥ÂäõËÆ°ÁÆó
                            if (pass === 2 && !guessed) {
                                this.calculatePixel(x, y, 1, 1); // drawWidth=1
                            }
                        }
                        await this.tryUpdateScreen();
                    }
                }
            }

            // ÈÖçÂêà‰∏äËø∞ÈÄªËæëÔºåtryUpdateScreen ÂèØ‰ª•Á®çÂæÆÈôç‰Ωé‰∏ÄÁÇπÂº∫Âà∂Èó¥ÈöîÔºåÂõ†‰∏∫Êàë‰ª¨Â∑≤ÁªèÂú®Â§ßÂæ™ÁéØÈáåÂÅö‰∫ÜÊµÅÊéß
            async tryUpdateScreen() {
                let currentTime = performance.now();
                if (currentTime - this.lastUpdateTime < 100) {
                    return;
                }
                this.showInfo();
                this.updateProgress();
                this.context.putImageData(this.image, 0, 0);
                // ‰ΩøÁî® requestAnimationFrame ÁöÑËøôÁßç await ÂÜôÊ≥ïÂèØ‰ª•ËÆ© UI Á∫øÁ®ãÂëºÂê∏
                await delay(0);
                this.lastUpdateTime = currentTime;
            }

            calculatePixel(x, y, drawWidth, drawHeight) {
                let delta = this.getDelta(x, y);
                let iter = this.deep ?
                    getPTBLAFE(
                        delta,
                        this.ref,
                        this.blaTable,
                        this.iterations,
                        this.bailout,
                        this.smooth
                    ) :
                    getPTBLA(
                        delta,
                        this.ref,
                        this.blaTable.steps,
                        this.blaTable.stages,
                        this.iterations,
                        this.bailout,
                        this.smooth
                    );

                this.setIter(x, y, iter, drawWidth, drawHeight);
                this.stats.calc++;
            }

            async cancel() {
                this.requestForCancel = true;
                while (true) {
                    if (this.cancelling) break;
                    await delay(100); // wait for cancellation to complete
                }
                this.cancelling = false;
                this.requestForCancel = false;
                this.rendering = false;
            }

            /**
             * Recolorize the Mandelbrot set visualization without recalculating.
             */

            recolorize() {
                this.image = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
                for (let y = 0; y < this.canvas.height; y++) {
                    for (let x = 0; x < this.canvas.width; x++) {
                        let it = this.iterMap[y][x];
                        if (it >= 0) {
                            let color = getColor(it, this.iterations);
                            let i = (y * this.canvas.width + x) << 2;
                            this.image.data[i] = color[0];
                            this.image.data[i + 1] = color[1];
                            this.image.data[i + 2] = color[2];
                            this.image.data[i + 3] = 255;
                        } else {
                            let i = (y * this.canvas.width + x) << 2;
                            this.image.data[i] = 0;
                            this.image.data[i + 1] = 0;
                            this.image.data[i + 2] = 0;
                            this.image.data[i + 3] = 0;
                        }
                    }
                }
                this.context.putImageData(this.image, 0, 0);
            }


            /**
             * Initiates the download of the Mandelbrot set visualization as a PNG image.
             */
            download() {
                const downloadLink = document.createElement('a');

                downloadLink.href = canvas.toDataURL('image/png');
                downloadLink.download = 'mandelbrot.png';

                downloadLink.click();
            }

            /**
             * Increases the number of iterations for the Mandelbrot set visualization.
             * @param {number} mul - The multiplier for increasing the iterations.
             */
            increaseIteration(mul) {
                let prevIter = this.iterations;
                this.setIterations(this.iterations * mul);

                for (let y = 0; y < this.canvas.height; y++) {
                    for (let x = 0; x < this.canvas.width; x++) {
                        if (this.iterMap[y][x] >= prevIter) {
                            this.setIter(x, y, -1)
                        }
                    }
                }
                this.update()
            }

            /** 
             * Translates the iteration map by the specified delta values. Fill -1 for new areas.
             * This is to move the view when panning without recalculating everything.
             * @param {number} deltaX - The delta in the x direction.
             * @param {number} deltaY - The delta in the y direction.
            */
            translate(deltaX, deltaY) {
                // Use inplace translation to avoid extra memory allocation
                let xStart, xEnd, yStart, yEnd;
                let xStep, yStep;
                if (deltaX > 0) {
                    xStart = this.canvas.width - 1;
                    xEnd = -1;
                    xStep = -1;
                } else {
                    xStart = 0;
                    xEnd = this.canvas.width;
                    xStep = 1;
                }
                if (deltaY > 0) {
                    yStart = this.canvas.height - 1;
                    yEnd = -1;
                    yStep = -1;
                } else {
                    yStart = 0;
                    yEnd = this.canvas.height;
                    yStep = 1;
                }
                for (let y = yStart; y != yEnd; y += yStep) {
                    for (let x = xStart; x != xEnd; x += xStep) {
                        let srcX = x - deltaX;
                        let srcY = y - deltaY;
                        if (srcX >= 0 && srcX < this.canvas.width && srcY >= 0 && srcY < this.canvas.height) {
                            this.iterMap[y][x] = this.iterMap[srcY]?.[srcX] ?? -1;
                        } else {
                            this.iterMap[y][x] = -1;
                        }
                    }
                }

            }

            async renderFrames() {
                let frames = [];
                let refreshRef = false;
                this.videoRendering = true;
                while (this.size.doubleValue() < 32) {
                    await this.update();
                    let url = canvas.toDataURL('image/png');
                    let img = document.createElement('img');
                    img.src = url;
                    frames.push({ frame: img, scale: this.size });
                    this.zoomOut();
                    if (this.size.exp > -20 && !refreshRef) {
                        this.center = new DeepComplex(
                            new Decimal(this.center.re.toPrecision(30)),
                            new Decimal(this.center.im.toPrecision(30))
                        )
                        this.refValid = false;
                        this.iterations = 256;
                        refreshRef = true;
                    }
                }
                this.videoRendering = false;
                return frames.reverse();
            }
        }

        class KFRReader {
            constructor(arrayBuffer) {
                this.buffer = arrayBuffer;
                this.content = new TextDecoder().decode(arrayBuffer); // Decode ArrayBuffer to string
                this.data = this.parseContent(); // Parse key-value pairs
            }

            // Parse content line by line into key-value pairs
            parseContent() {
                const result = {};
                const lines = this.content.split(/\r?\n/); // Split into lines
                lines.forEach(line => {
                    const [key, value] = line.split(":").map(part => part.trim());
                    if (key && value !== undefined) {
                        result[key] = value;
                    }
                });
                return result;
            }

            // Getter for `Re`
            get re() {
                return this.data.Re;
            }

            // Getter for `Im`
            get im() {
                return this.data.Im;
            }

            // Getter for `Zoom`
            get zoom() {
                return this.data.Zoom;
            }

            // Getter for `Iterations`
            get iter() {
                return parseInt(this.data.Iterations, 10);
            }

            // Getter for `IterDiv`
            get iterDiv() {
                return parseFloat(this.data.IterDiv) ?? 8;
            }

            get smooth() {
                return this.data.Smooth !== undefined && this.data.Smooth !== "0";
            }

            // Getter for `Colors`, converts the raw color data into an array of [r, g, b] tuples
            get colors() {
                if (!this.data.Colors) return defaultPalette;
                const colorValues = this.data.Colors.split(",").slice(0, -1).map(Number);
                const rgbArray = [];
                for (let i = 0; i < colorValues.length; i += 3) {
                    rgbArray.push([colorValues[i + 2], colorValues[i + 1], colorValues[i]]);
                }
                return rgbArray;
            }
        }

        class KFRWriter {
            constructor() {
                this.data = {};
            }

            // Setters for `Re`, `Im`, `Zoom`, `Iterations`, `IterDiv`, and `Colors`
            set re(value) {
                this.data.Re = value;
            }

            set im(value) {
                this.data.Im = value;
            }

            set zoom(value) {
                this.data.Zoom = value;
            }

            set iter(value) {
                this.data.Iterations = value;
            }

            set iterDiv(value) {
                this.data.IterDiv = value;
            }

            set colors(value) {
                this.data.Colors = value.map(color => {
                    // convert each color to BGR format
                    return `${color[2]},${color[1]},${color[0]},`;
                }).join("");
            }

            set smooth(value) {
                this.data.Smooth = value ? "1" : "0";
            }

            // Convert the data to a KFR formatted string
            toString() {
                return Object.entries(this.data)
                    .map(([key, value]) => `${key}: ${value}`)
                    .join("\r\n");
            }

            load(mandelbrot) {
                this.re = mandelbrot.center.re.toString();
                this.im = mandelbrot.center.im.toString();
                let zoom = FloatExp.FOUR.div(mandelbrot.size);
                this.zoom = `${zoom.base}E${zoom.exp}`;
                this.iter = mandelbrot.iterations.toString();
                this.iterDiv = (colorStep * palette.length) / 1024
                this.colors = palette;
                this.smooth = mandelbrot.smooth;
            }
        }

        const dict = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz123456789'
        function b58Compress(n, pad = true) {
            if (n == 0) return '0'

            // Detect 7 same digits
            let str = n.toString();
            let same = str.split('').every((v, i, a) => v === a[0]) && str.length === 7;
            if (same) {
                let digit = str[0];
                return "I" + digit;
            }

            let b58 = [];
            while (n > 0) {
                b58.push(dict[n % 58]);
                n = Math.floor(n / 58);
            }
            let result = b58.reverse().join("");
            if (pad) result = result.padStart(4, 'A')
            return result;
        }

        function b58Decompress(b58, pad = true) {
            let n = 0;
            let i = 0;
            for (let i = 0; i < b58.length; i++) {
                const char = b58[i];
                n *= 58
                let index = dict.indexOf(char)
                if (index === -1) {
                    throw new Error("Invalid character")
                }
                n += index
            }
            let result = n.toString()
            if (pad) result = result.padStart(7, '0');
            return result
        }

        function compressInteger(str) {
            let hasSign = str[0] === '+' || str[0] === '-';

            let i = 0;
            let builder = []

            if (hasSign) {
                builder.push(str[0] === '+' ? '' : '-');
                i++;
            }

            while (i < str.length) {
                let part = str.slice(i, i + 7);
                let compressed = b58Compress(parseInt(part), part.length === 7)
                builder.push(compressed);
                i += 7;
            }
            return builder.join("")
        }

        function compressDecimal(str) {
            let [mant, exp] = str.toLowerCase().split('e');
            let [dec, frac] = mant.split(".");

            let result = compressInteger(dec)
            if (frac) {
                result += "." + compressInteger(frac);
            }
            if (exp) {
                let expCompressed = compressInteger(exp)
                sign = (expCompressed[0] === '-') ? '' : '_';
                result += sign + expCompressed;
            }

            return result
        }

        function decompressInteger(str) {
            let hasSign = str[0] === '_' || str[0] === '-';

            let i = 0;
            let builder = []

            if (hasSign) {
                builder.push(str[0] === '_' ? '' : '-');
                i++;
            }

            while (i < str.length) {
                if (str[i] === '0') {
                    builder.push("0000000");
                    i++;
                } else if (str[i] === 'I') {
                    let digit = str[i + 1];
                    builder.push(digit.repeat(7));
                    i += 2;
                }
                else {
                    let part = str.slice(i, i + 4);
                    let decompressed = b58Decompress(part, part.length === 4)
                    builder.push(decompressed);
                    i += 4;
                }
            }
            return builder.join("")
        }

        function decompressDecimal(str) {
            let mant, exp;
            let result = '', sign = '';
            str = str.trim();
            if (str.startsWith("_")) {
                mant = str.slice(1)
                sign = ''
            }
            else if (str.startsWith("-")) {
                mant = str.slice(1)
                sign = '-'
            }
            else {
                mant = str;
            }

            let expsign = '';
            if (mant.includes('-')) {
                [mant, exp] = mant.split('-')
                expsign = '-'
            }
            else if (mant.includes('_')) {
                [mant, exp] = mant.split('_')
            }

            let int, frac;
            [int, frac] = mant.split('.')
            result += sign + decompressInteger(int);

            if (frac && frac != '') result += '.' + decompressInteger(frac);

            if (exp && exp != '') {
                result += "e" + expsign + decompressInteger(exp)
            }

            return result;
        }


        function formatLongString(str, len = 30, pre = 15, suf = 15) {
            const s = str.toString();
            if (s.length > len) {
                return s.substring(0, pre) + '...' + s.substring(s.length - suf);
            }
            return s;
        }

        function updateInfoOverlay(re, im, zoom, iter) {
            document.getElementById('info-re').textContent = formatLongString(re);
            document.getElementById('info-im').textContent = formatLongString(im);
            document.getElementById('info-zoom').textContent = formatLongString(zoom.toString());
            document.getElementById('info-iter').textContent = iter.toLocaleString();
        }


        let c = new DeepComplex(
            new Decimal(0), new Decimal(0));

        let size = FloatExp.FOUR.copy();
        let bailout = 2;
        let iterations = 256;
        let smooth = false;

        const params = new URLSearchParams(window.location.hash.substring(1));

        params.forEach((value, key) => {
            switch (key) {

                // readable values
                case "re":
                    c.re = new Decimal(value);
                    params.delete(key);
                    break;
                case "im":
                    c.im = new Decimal(value);
                    params.delete(key);
                    break;
                case "zoom":
                    size = FloatExp.FOUR.div(getFloatExp(value));
                    params.delete(key);
                    break;
                case "iter":
                    iterations = parseInt(value);
                    params.delete(key);
                    break;
                case "bailout":
                    bailout = parseFloat(value);
                    params.delete(key);
                    break;
                case "colors":
                    palette = groupArray(value.split(",").map(e => parseInt(e)))
                    params.delete(key);
                    break;
                case "colorstep":
                    colorStep = parseFloat(value)
                    break;
                case "smooth":
                    smooth = value === "1" || value === "true";
                    break;

                // compressed values
                case "rec":
                    c.re = new Decimal(decompressDecimal(value));
                    break;
                case "imc":
                    c.im = new Decimal(decompressDecimal(value));
                    break;
                case "zmc":
                    size = FloatExp.FOUR.div(parseFloatExp(decompressDecimal(value)));
                    break;
                case "itc":
                    iterations = parseInt(decompressDecimal(value));
                    break;
                case "colorc":
                    palette = groupArray(base64ToByteArray(value));
                    break;
            }
        });
        location.hash = params.toString();

        const mandelbrot = new Mandelbrot(canvas, c, iterations, bailout)
        mandelbrot.smooth = smooth;
        mandelbrot.zoom(size)
        mandelbrot.update()


        document.getElementById('menu-toggle').addEventListener('click', () => {
            document.getElementById('sidebar').classList.toggle('open');
        });

        document.getElementById('info-overlay').addEventListener('click', () => {
            document.getElementById('info-overlay').classList.toggle('info-overlay-collapsed');
        });

        document.getElementById('smart-zoom').addEventListener('click', (e) => {
            if (mandelbrot.stats.predCenter) {

                const screenCoord = mandelbrot.deltaToScreen(mandelbrot.stats.predCenter);
                const fakeEvent = {
                    clientX: (1 - screenCoord.x / canvas.width) * window.innerWidth,
                    clientY: (1 - screenCoord.y / canvas.height) * window.innerHeight,
                    deltaY: -1, // zoom in
                    preventDefault: () => { },
                    fake: true
                };
                mandelbrot.cancel();
                mandelbrot.handleWheel(fakeEvent);
            }
        });

        document.getElementById('goto').addEventListener('click', e => {
            mandelbrot.goto(new DeepComplex(
                new Decimal(reInput.value),
                new Decimal(imInput.value)
            ))

            mandelbrot.zoom(FloatExp.FOUR.div(parseFloatExp(zoomInput.value)));
            mandelbrot.setIterations(parseInt(itInput.value));

            mandelbrot.update();
        })

        document.getElementById('home').addEventListener('click', e => {
            mandelbrot.home()
            mandelbrot.update()
        })

        document.getElementById('download').addEventListener('click', e => {
            mandelbrot.download()
        })

        sampleLoadBtn.addEventListener('click', e => {
            const loc = samples[sampleSelect.value]
            mandelbrot.goto(new DeepComplex(
                new Decimal(loc.re), new Decimal(loc.im)
            ))
            mandelbrot.zoom(FloatExp.FOUR.div(getFloatExp(loc.zoom)));
            mandelbrot.setIterations(loc.it);
            mandelbrot.update()
        })


        document.getElementById('zoom-in').addEventListener('click', function () {
            mandelbrot.zoom(mandelbrot.size.div(2)); // Changed to 2x for consistency with wheel
            mandelbrot.update();
        });

        document.getElementById('zoom-out').addEventListener('click', function () {
            mandelbrot.zoom(mandelbrot.size.mul(2)); // Changed to 2x
            mandelbrot.update();
        });

        document.getElementById('increase-iter').addEventListener('click', function () {
            mandelbrot.increaseIteration(2);
            mandelbrot.update();
        });

        document.getElementById('decrease-iter').addEventListener('click', function () {
            mandelbrot.setIterations(mandelbrot.iterations / 2);
            mandelbrot.clear();
            mandelbrot.update()
        });

        const fullscreenBtn = document.getElementById('fullscreen');
        fullscreenBtn.addEventListener('click', function () {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else {
                document.exitFullscreen();
            }
        });

        // Dynamically create an input element
        const inputElement = document.createElement("input");
        inputElement.type = "file";
        inputElement.accept = ".kfr"; // Accept only .kfr files
        inputElement.style.display = "none";

        // Append the input element to the document
        document.body.appendChild(inputElement);

        // Trigger file upload when a button is clicked
        document.getElementById("kfr").addEventListener('click', () => {
            inputElement.click(); // Simulate a click on the input element
        });

        document.getElementById("save-kfr").addEventListener('click', () => {
            const writer = new KFRWriter();
            writer.load(mandelbrot);
            const kfrContent = writer.toString();

            // Create a Blob from the KFR content
            const blob = new Blob([kfrContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);

            // Create a link to download the file
            const a = document.createElement('a');
            a.href = url;
            a.download = `mandelbrot-${new Date().toISOString()}.kfr`; // Set the desired file name
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });

        // Handle file selection
        inputElement.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) {
                alert("No file selected!");
                return;
            }

            // Ensure the file is a .kfr file
            if (!file.name.endsWith('.kfr')) {
                alert("Please upload a valid .kfr file.");
                return;
            }

            // Read the file as an ArrayBuffer
            const arrayBuffer = await file.arrayBuffer();

            // Parse the .kfr file using KFRReader
            const reader = new KFRReader(arrayBuffer);

            mandelbrot.goto(new DeepComplex(reader.re, reader.im))
            mandelbrot.zoom(FloatExp.FOUR.div(parseFloatExp(reader.zoom)));
            mandelbrot.setIterations(reader.iter);
            mandelbrot.smooth = reader.smooth;
            palette = reader.colors;
            colorStep = 1024 / reader.colors.length * reader.iterDiv;
            mandelbrot.update();
        });

        // Trigger file upload when a button is clicked
        document.getElementById("makeVideo").addEventListener('click', async () => {
            const keyFrames = await mandelbrot.renderFrames();
            console.log(keyFrames);

            const stream = canvas.captureStream();
            const recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=h264', videoBitsPerSecond: 10000000 });
            const data = [];
            recorder.ondataavailable = function (event) {
                if (event.data && event.data.size) {
                    data.push(event.data);
                }
            };
            recorder.onstop = () => {
                const url = URL.createObjectURL(new Blob(data, { type: 'video/webm' }));
                console.log('video url', url)
                var a = document.createElement('a');
                a.download = 'file.webm';
                a.href = url;
                a.click();

            };

            let indexFl = 0;
            let ctx = canvas.getContext('2d')

            ctx.font = 'bold 26px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;

            const renderer = () => {
                // Ensure `keyFrames` array is defined and has elements
                if (!keyFrames || keyFrames.length < 2) {
                    console.error("keyFrames array is either undefined or contains fewer than 2 frames.");
                    recorder.stop();
                    return;
                }

                // Calculate indices and verify bounds
                let i = Math.floor(indexFl);
                if (i < 0 || i + 1 >= keyFrames.length) {
                    recorder.stop();
                    return;
                }

                // Get the two images for the transition
                const image1 = keyFrames[i].frame;
                const image2 = keyFrames[i + 1].frame;

                // Calculate scaling factors
                const decimalPart = indexFl - i; // Fractional part of the index
                const scale1 = Math.pow(2, decimalPart); // Scale for image1
                const scale2 = scale1 * .5; // Scale for image2 (fixed at half size)

                // Clear canvas (assuming canvas context is `ctx`)
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw image1 at center with scaling factor `scale1`
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;

                ctx.drawImage(image1,
                    centerX - canvas.width * scale1 / 2,
                    centerY - canvas.height * scale1 / 2,
                    canvas.width * scale1,
                    canvas.width * scale1
                );


                ctx.drawImage(image2,
                    centerX - canvas.width * scale2 / 2,
                    centerY - canvas.height * scale2 / 2,
                    canvas.width * scale2,
                    canvas.width * scale2
                );

                more.innerText = indexFl.toFixed(2);

                const scale = FloatExp.FOUR.div(keyFrames[i].scale);
                const currScale = FloatExp.fromLog2(scale.log2Value() + decimalPart);

                let zoomText;
                if (currScale.exp < 7) {
                    zoomText = currScale.doubleValue().toFixed(2);
                } else zoomText = `${currScale.base.toFixed(2)}E${currScale.exp}`

                ctx.fillText(zoomText, 8, 8)
                ctx.strokeText(zoomText, 8, 8)

                // Increment index for the next frame
                indexFl += 1 / 60;

                // Loop `renderer` to maintain animation (assuming 60fps rendering)
                requestAnimationFrame(renderer);
            };

            // Start the renderer
            recorder.start();
            requestAnimationFrame(renderer);
        });

        function generateRandomPalette(size) {
            const palette = [];
            for (let i = 0; i < size; i++) {
                palette.push([
                    Math.floor(Math.random() * 256),
                    Math.floor(Math.random() * 256),
                    Math.floor(Math.random() * 256)
                ]);
            }
            return palette;
        }

        function hsvToRgb(h, s, v) {
            let r, g, b;
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v, g = t, b = p; break;
                case 1: r = q, g = v, b = p; break;
                case 2: r = p, g = v, b = t; break;
                case 3: r = p, g = q, b = v; break;
                case 4: r = t, g = p, b = v; break;
                case 5: r = v, g = p, b = q; break;
            }
            return [Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)];
        }

        function generateRandomBWPalette(size) {
            const palette = [];
            for (let i = 0; i < size; i++) {
                const phase = i % 4;
                let h, s, v;
                switch (phase) {
                    case 0:
                        // Phase 0: full color: 
                        h = Math.random();
                        s = Math.random() * 0.5 + 0.5;
                        v = Math.random() * 0.25 + 0.75;
                        break;
                    case 1:
                        // Phase 1: darker color
                        h = Math.random();
                        s = Math.random() * 0.5 + 0.5;
                        v = Math.random() * 0.25;
                        break;
                    case 2:
                        // Phase 2: full color
                        h = Math.random();
                        s = Math.random() * 0.5 + 0.5;
                        v = Math.random() * 0.25 + 0.75;
                        break;
                    case 3:
                        // Phase 3: lighter color
                        h = Math.random();
                        s = Math.random() * 0.25;
                        v = Math.random() * 0.25 + 0.75;
                }
                palette.push(hsvToRgb(h, s, v));
            }
            return palette;
        }

        class PaletteEditor {
            constructor() {
                this.dialog = document.getElementById('palette-dialog');
                this.colorList = document.getElementById('color-list');
                this.applyButton = document.getElementById('apply-colors');
                this.randomButton = document.getElementById('random-colors');
                this.resetButton = document.getElementById('reset-colors');
                this.closeButton = document.getElementById('close-dialog');
                this.colorStepInput = document.getElementById('color-step');
                this.init();
            }

            init() {
                this.applyButton.addEventListener('click', () => {
                    this.applyColors();
                });

                this.randomButton.addEventListener('click', () => {
                    const algorithm = this.getAlgorithm();
                    switch (algorithm) {
                        case 'random':
                            palette = generateRandomPalette(palette.length); // Generate a random palette with the same length
                            break;
                        case 'random-bw':
                            palette = generateRandomBWPalette(palette.length); // Generate a random black and white palette
                            break;

                    }
                    // palette = generateRandomPalette(palette.length); // Generate a random palette with 10 colors
                    this.renderColors();
                });

                this.resetButton.addEventListener('click', () => {
                    palette = defaultPalette; // Reset to the default palette
                    this.renderColors();
                });

                this.closeButton.addEventListener('click', () => {
                    this.dialog.close();
                });

                this.colorStepInput.addEventListener('input', (e) => {
                    colorStep = parseFloat(e.target.value);
                });

                this.renderColors();
            }

            renderColors() {
                this.colorList.innerHTML = ''; // Clear existing colors
                palette.forEach((color, index) => {
                    const li = document.createElement('li');
                    li.classList.add('color-item');
                    const label = document.createElement('label');
                    label.textContent = `${index + 1} `;
                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.value = `#${color.map(c => c.toString(16).padStart(2, '0')).join('')}`;
                    colorInput.dataset.index = index;
                    const removeColorButton = document.createElement('button');
                    removeColorButton.classList.add('icon');
                    removeColorButton.dataset.index = index;
                    removeColorButton.textContent = '-';
                    removeColorButton.addEventListener('click', (e) => {
                        const index = e.target.dataset.index;
                        palette.splice(index, 1); // Remove color from palette
                        this.renderColors(); // Re-render colors
                    });
                    const addColorButton = document.createElement('button');
                    addColorButton.className = 'icon';
                    addColorButton.textContent = '+';
                    addColorButton.dataset.index = index;
                    addColorButton.addEventListener('click', () => {
                        // Add a new black color after the current color
                        palette.splice(index + 1, 0, [0, 0, 0]); // Add black color
                        this.renderColors(); // Re-render colors
                    });
                    li.appendChild(label);
                    li.appendChild(colorInput);
                    li.appendChild(removeColorButton);
                    li.appendChild(addColorButton);
                    this.colorList.appendChild(li);
                });

                this.colorStepInput.value = colorStep; // Set the color step input value
            }

            getAlgorithm() {
                const selectedAlgorithm = document.querySelector('input[name="algorithm"]:checked');
                return selectedAlgorithm ? selectedAlgorithm.value : 'random';
            }

            applyColors() {
                const inputs = this.colorList.querySelectorAll('input[type="color"]');
                palette = Array.from(inputs).map(input => {
                    const color = input.value.slice(1); // Remove the '#' character
                    return [
                        parseInt(color.slice(0, 2), 16),
                        parseInt(color.slice(2, 4), 16),
                        parseInt(color.slice(4, 6), 16)
                    ];
                });
                this.dialog.close();
                mandelbrot.recolorize(); // Recolorize the Mandelbrot set with new colors
            }

            show() {
                this.dialog.showModal();
                this.renderColors();
            }
        }

        const paletteEditor = new PaletteEditor();
        document.getElementById('palette').addEventListener('click', () => {
            paletteEditor.show();
        });

        document.getElementById('iteration-button').addEventListener('click', () => {
            const iterDialog = document.getElementById('iteration-dialog');
            const bailoutInput = document.getElementById('bailout');
            const smoothCheckbox = document.getElementById('smooth');

            bailoutInput.value = Math.sqrt(mandelbrot.bailout);
            smoothCheckbox.checked = mandelbrot.smooth;

            iterDialog.showModal();

            document.getElementById('apply-iter').addEventListener('click', () => {
                mandelbrot.bailout = parseFloat(bailoutInput.value) ** 2;
                mandelbrot.smooth = smoothCheckbox.checked;
                iterDialog.close();
                mandelbrot.clear();
                mandelbrot.update();
            });

            document.getElementById('close-iter-dialog').addEventListener('click', () => {
                iterDialog.close();
            });
        });
    </script>
</body>

</html>