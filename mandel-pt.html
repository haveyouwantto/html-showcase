<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="description" content="Infinite deep and fast Mandelbrot set explorer">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mandelbrot Perturbation</title>
    <style>
        :root {
            --theme-color: #ff4081;
            /* Define a theme color */
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #1a1a1a;
            /* Dark background color */
            color: #fff;
            /* Light text color */
            font-family: Arial, sans-serif;
        }

        .container {
            display: flex;
            margin: auto;
        }

        .canvas-container {
            position: relative;
        }

        .progress-container {
            display: flex;
        }

        .progress {
            background-color: white;
            width: 0;
            height: 8px;
        }

        .guessed-progress {
            background-color: rgba(255, 255, 255, 0.5);
        }

        .location {
            display: flex;
            flex-direction: column;
            margin-left: 8px;
        }

        #mandelbrot {
            background: repeating-linear-gradient(45deg, var(--theme-color), var(--theme-color) 8px, #000 8px, #000 16px);
            /* Adjust colors for dark mode */
            cursor: crosshair;
            width: 800px;
            height: 800px;
        }

        button {
            margin-top: 8px;
            background-color: #333;
            /* Dark button background color */
            color: #fff;
            /* Light text color for buttons */
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: var(--theme-color);
            /* Change background color on hover */
        }

        button:focus {
            outline: none;
            /* Remove default focus outline */
            box-shadow: 0 0 3px var(--theme-color);
            /* Add custom focus effect */
        }

        button:disabled {
            filter: brightness(0.5);
            /* Darker color for disabled buttons */
            cursor: not-allowed;
            /* Change cursor to indicate disabled state */
        }

        button.icon {
            font-size: 30px;
            font-family: emoji;
            font-weight: bold;
            width: 35px;
            height: 35px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        textarea {
            background-color: #333;
            /* Dark textarea background color */
            color: #fff;
            /* Light text color for textarea */
            border: 1px solid #666;
            /* Dark border color */
            padding: 4px;
            resize: vertical;
            /* Allow vertical resizing */
            transition: background-color 0.3s;
            font-size: 0.8rem;
        }

        textarea:hover,
        textarea:focus {
            background-color: #444;
            border-color: var(--theme-color);
            outline: none;
            /* Change background color on hover/focus */
        }

        hr {
            width: 100%;
            border: 1px solid #444;
            /* Dark color for the horizontal rule */
            margin: 20px 0;
            /* Adjust margin as needed */
        }

        select {
            background-color: #333;
            /* Dark background color for select dropdown */
            color: #fff;
            /* Light text color for select options */
            padding: 8px;
            border: 1px solid #666;
            /* Dark border color */
            border-radius: 4px;
            appearance: none;
            /* Remove default appearance */
            transition: background-color 0.3s;
        }

        select:hover,
        select:focus {
            background-color: #444;
            /* Change background color on hover/focus */
        }

        .shortcut {
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        .running {
            outline: var(--theme-color) 4px solid;
            cursor: wait !important;
        }

        #color-list {
            list-style: none;
            outline: 1px solid var(--theme-color);
            padding: 8px;
            margin: 8px;
            flex-wrap: wrap;
            max-height: 75vh;
            overflow-y: auto;
        }

        #palette-dialog {
            width: 400px;
            padding: 20px;
            background-color: #222;
            color: #fff;
            border: none;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            max-width: 90%;
            max-height: 100dvh;
        }

        #palette-dialog h2 {
            margin-top: 0;
        }

        #palette-dialog::backdrop {
            background-color: rgba(0, 0, 0, 0.5);
            /* Semi-transparent backdrop */
        }

        input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            padding: 0;
            margin: 0;
            cursor: pointer;
            appearance: none;
            background: none;
        }

        input[type="number"] {
            padding: 4px;
            border: 1px solid #666;
            background-color: #333;
            color: #fff;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        .color-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }


        @media (max-width: 600px) {
            .container {
                flex-direction: column;
            }

            #mandelbrot {
                width: 100%;
                height: auto;
            }

            .location {
                margin-left: 0;
            }

            .shortcut {
                justify-content: space-evenly;
            }
        }
    </style>
</head>

<body>
    <div class="container">

        <div class="canvas-container">
            <canvas id="mandelbrot" width="800" height="800"></canvas>
            <div class="progress-container">
                <div id="progress" class="progress"></div>
                <div id="guessed-progress" class="progress guessed-progress"></div>
            </div>
            <div>
                Iterations: <span id="iter-count"></span>
            </div>
            <div id="stats">
            </div>
        </div>

        <div class="location">
            Real:
            <textarea id="re" class="large" rows="10"></textarea><br>
            Imaginary:
            <textarea id="im" class="large" rows="10"></textarea><br>
            Zoom:
            <textarea id="zoom" rows="2"></textarea><br>
            Iterations:
            <textarea id="it" rows="1"></textarea>
            <div class="shortcut">
                <button class="icon control-button" id="zoom-in" title="Zoom in">&#10133;</button>
                <button class="icon control-button" id="zoom-out" title="Zoom out">&#10134;</button>
                <button class="icon control-button" id="increase-iter" title="Iterations x2">&#128314;</button>
                <button class="icon control-button" id="decrease-iter" title="Iterations /2">&#128315;</button>
            </div>
            <div class="shortcut">
                <button class="icon control-button" id="goto" title="Go to location">&#128640;</button>
                <button class="icon control-button" id="home" title="Reset view">&#127968;</button>
                <button class="icon control-button" id="palette" title="Palette Editor">ðŸŽ¨</button>
                <button class="icon control-button" id="download" title="Download PNG">&#128248;</button>
            </div>
            <div class="shortcut">
                <button class="icon control-button" id="kfr" title="Load KFR file">ðŸ“‚</button>
                <button class="icon control-button" id="save-kfr" title="Save KFR file">ðŸ’¾</button>
            </div>
            <button id="makeVideo" class="control-button">Make Video</button>
            <hr>
            Samples
            <select id="samples">
                <option value="seahorse">Seahorse</option>
                <option value="snowflake">Snowflake</option>
                <option value="spiral">Spiral</option>
                <option value="luxury">Luxury</option>
                <option value="horizon">Horizon</option>
                <option value="flora">Flora</option>
                <option value="classic">Classic</option>
                <option value="e200">E200</option>
                <option value="radiant">Radiant</option>
                <option value="branches">Branches</option>
            </select>
            <button id="load-sample" class="control-button">Load</button>
        </div>
    </div>
    <div id="more"></div>
    <dialog id="palette-dialog">
        <h2>Color Settings</h2>
        <label for="color-step">Color Step:</label>
        <input type="number" id="color-step" value="1" min="1" max="100" step="1"><br>
        <ol id="color-list">
            <!-- Color settings -->
        </ol>
        <button id="apply-colors">Apply</button>
        <button id="random-colors">Random</button>
        <button id="reset-colors">Reset</button>
        <button id="close-dialog">Close</button>
    </dialog>
    <script src="lib/decimal.9.0.0.js"></script>
    <script>
        const canvas = document.getElementById('mandelbrot');
        const reInput = document.getElementById('re')
        const imInput = document.getElementById('im');
        const zoomInput = document.getElementById('zoom')
        const itInput = document.getElementById('it')
        const statsLabel = document.getElementById('stats')
        const progressBar = document.getElementById('progress');
        const guessedProgressBar = document.getElementById('guessed-progress');
        const sampleSelect = document.getElementById('samples')
        const sampleLoadBtn = document.getElementById('load-sample')
        const more = document.getElementById("more");


        const CPU_CORES = Math.max(navigator.hardwareConcurrency ?? 1, 1);

        class FloatExp {
            static expTable = [];
            static LOG2_10 = Math.log2(10);
            static LOG10_2 = Math.log10(2);
            static buffer = new ArrayBuffer(8); // Create an 8-byte buffer
            static floatView = new Float64Array(FloatExp.buffer); // Float64 view for the double
            static int32View = new Int32Array(FloatExp.buffer); // Int32 view to access 64 bits as two 32-bit chunks
            static {
                this.expTable = [];
                for (let i = 0; i < 324 + 308; i++) {
                    this.expTable[i] = Math.pow(10, i - 324);
                }
            }

            static getExp(exp) {
                if (exp < -324) return 0;
                else if (exp > 308) return Infinity;
                return this.expTable[exp + 324];
            }

            static getExpOfDouble(d) {
                if (d === 0) {
                    throw new Error("Exponent of zero is undefined.");
                }

                const LOG10_2 = Math.LOG10E; // log10(2)
                const BIAS = 1023; // Double-precision bias
                FloatExp.floatView[0] = d; // Store the double value

                const highBits = FloatExp.int32View[1]; // Get the higher 32 bits
                const lowBits = FloatExp.int32View[0]; // Get the lower 32 bits

                const rawExp = (highBits >>> 20) & 0x7FF; // Extract the exponent bits (11 bits)

                let actualExp;
                if (rawExp === 0) {
                    // Subnormal number
                    let mantissaHigh = highBits & 0xFFFFF; // Extract the top 20 bits of mantissa
                    const mantissaLow = lowBits; // Lower 32 bits of mantissa

                    // Combine mantissa into a single value for leading zero count
                    let leadingZeros = 0;
                    if (mantissaHigh === 0) {
                        leadingZeros += 32; // All high bits are zero, so count low bits
                        let temp = mantissaLow;
                        while (temp !== 0 && (temp & 0x80000000) === 0) {
                            temp <<= 1;
                            leadingZeros++;
                        }
                    } else {
                        let temp = mantissaHigh;
                        while ((temp & 0x80000) === 0) { // Adjust mask for 20 bits
                            temp <<= 1;
                            leadingZeros++;
                        }
                    }

                    actualExp = -1022 - leadingZeros;
                } else {
                    // Normalized number
                    actualExp = rawExp - BIAS;
                }

                // Convert base-2 exponent to base-10 exponent
                return Math.floor(actualExp * LOG10_2);
            }

            constructor(base, exp = 0) {
                if (isNaN(base) || isNaN(exp) || !isFinite(base) || !isFinite(exp)) {
                    throw new Error("Invalid FloatExp");
                }
                this.base = base;
                this.exp = exp;
                this.norm();
            }

            norm() {
                if (this.base == 0) {
                    this.exp = 0;
                    return this;
                }
                if (this.base != 0 && (this.base > 10 || this.base < 1)) {
                    let exp = FloatExp.getExpOfDouble(this.base);
                    if (exp != 0) {
                        this.exp += exp;
                        this.base /= FloatExp.getExp(exp);
                    }
                }
                return this;
            }

            doubleValue() {
                return this.base * FloatExp.getExp(this.exp);
            }

            toString() {
                this.norm();
                return `${this.base}e${this.exp}`
            }

            add(other) {
                if (typeof other == 'number') return this.add(new FloatExp(other));
                if (other.base == 0) return this;
                else if (this.base == 0) return other;
                const expDiff = other.exp - this.exp;
                if (expDiff == 0)
                    return new FloatExp(this.base + other.base, this.exp)
                else if (expDiff > 16) return other;
                else {
                    return new FloatExp(this.base + other.base * FloatExp.getExp(other.exp - this.exp), this.exp)
                }
            }

            addMut(other) {
                if (other.base == 0) return this;
                else if (this.base == 0) {
                    this.base = other.base;
                    this.exp = other.exp;
                    return this;
                }
                const expDiff = other.exp - this.exp;
                if (expDiff == 0) {
                    this.base += other.base;
                    return this.norm();
                } else if (expDiff > 16) {
                    this.base = other.base;
                    this.exp = other.exp;
                    return this;
                } else {
                    this.base += other.base * FloatExp.getExp(expDiff);
                    return this.norm();
                }
            }

            sub(other) {
                if (typeof other == 'number') return this.sub(new FloatExp(other));
                if (other.base == 0) return this;
                else if (this.base == 0) return other.rev();
                const expDiff = other.exp - this.exp;
                if (expDiff == 0)
                    return new FloatExp(this.base - other.base, this.exp)
                else if (expDiff > 16) return other.rev();
                else {
                    return new FloatExp(this.base - other.base * FloatExp.getExp(other.exp - this.exp), this.exp)
                }
            }

            subMut(other) {
                if (other.base == 0) return this;
                else if (this.base == 0) {
                    this.base = -other.base;
                    this.exp = other.exp;
                    return this;
                }
                const expDiff = other.exp - this.exp;
                if (expDiff == 0) {
                    this.base -= other.base;
                    return this.norm();
                } else if (expDiff > 16) {
                    this.base = -other.base;
                    this.exp = other.exp;
                    return this;
                } else {
                    this.base -= other.base * FloatExp.getExp(expDiff);
                    return this.norm();
                }
            }


            mul(other) {
                if (other instanceof FloatExp)
                    return new FloatExp(this.base * other.base, this.exp + other.exp)
                else if (typeof other == 'number')
                    return new FloatExp(this.base * other, this.exp);
            }

            mulMut(other) {
                this.base *= other.base;
                this.exp += other.exp;
                return this.norm();
            }

            div(other) {
                if (other instanceof FloatExp)
                    return new FloatExp(this.base / other.base, this.exp - other.exp)
                else if (typeof other == 'number')
                    return new FloatExp(this.base / other, this.exp);
            }

            divMut(other) {
                this.base /= other.base;
                this.exp -= other.exp;
                return this.norm();
            }

            abs() {
                return new FloatExp(Math.abs(this.base), this.exp);
            }

            sqrt() {
                if (this.base < 0) throw new Error("Cannot take square root of negative number");
                return new FloatExp(Math.sqrt(this.base), this.exp / 2);
            }

            rev() {
                return new FloatExp(-this.base, this.exp);
            }

            copy() {
                return new FloatExp(this.base, this.exp);
            }

            square() {
                return new FloatExp(this.base * this.base, this.exp * 2);
            }

            squareMut() {
                this.base *= this.base;
                this.exp *= 2;
                return this.norm();
            }

            compareTo(o) {
                // 1. Compare sign
                if (this.base > 0 && o.base < 0) return 1;
                if (this.base < 0 && o.base > 0) return -1;

                // 2. Handle zero cases
                if (this.base === 0 && o.base === 0) return 0; // Both are zero
                if (this.base === 0) return o.base > 0 ? -1 : 1; // This is zero
                if (o.base === 0) return this.base > 0 ? 1 : -1; // Other is zero

                // 3. Compare exponents
                if (this.exp > o.exp) return this.base > 0 ? 1 : -1;
                if (this.exp < o.exp) return this.base > 0 ? -1 : 1;

                // 4. Compare bases when exponents are equal
                if (this.base > o.base) return 1;
                if (this.base < o.base) return -1;

                return 0; // Equal
            }

            log2Value() {
                const log2Mantissa = Math.log2(this.base);
                const log2Exponent = this.exp * FloatExp.LOG2_10;

                const log2Result = log2Mantissa + log2Exponent;

                return log2Result;
            }

            static fromLog2(val) {
                const log10 = val * FloatExp.LOG10_2;
                return new FloatExp(Math.pow(10, log10 - Math.trunc(log10)), Math.trunc(log10));
            }
        }

        function parseFloatExp(string) {
            var [b, e] = string.toLowerCase().split("e");
            e = parseInt(e)
            var fp = new FloatExp(parseFloat(b), (isNaN(e) ? 0 : e));
            // fp.norm();
            return fp;
        }

        function doubleToFloatExp(num) {
            if (num === 0) return new FloatExp(0, 0);
            // Get the exponent
            let exponent = Math.floor(Math.log10(Math.abs(num)));
            // Calculate the significand
            let significand = num / FloatExp.getExp(exponent);
            return new FloatExp(significand, exponent);
        }

        function decimalToFloatExp(num) {
            let base = num.d[0];
            for (let i = 1; i < 3; i++) {
                if (num.d[i]) base = base * 1e8 + num.d[i];
            }
            if (num.e == 0) return new FloatExp(base, 0);
            let off = Math.floor(Math.log10(base));
            let exp = num.e - off;
            return new FloatExp(base, exp);
        }

        function getFloatExp(obj) {
            if (obj instanceof FloatExp) return obj;
            else if (typeof obj === "number") {
                return doubleToFloatExp(obj);
            } else if (obj instanceof Decimal) {
                return decimalToFloatExp(obj);
            } else return parseFloatExp(obj.toString())
        }

        class Complex {
            absValue;
            constructor(re, im) {
                this.re = re;
                this.im = im;
            }

            abs() {
                if (!this.absValue) this.absValue = this.re ** 2 + this.im ** 2;
                return this.absValue
            }

            toNumberArray() {
                return [this.re, this.im];
            }

            mul(other) {
                if (typeof other === 'number') {
                    return new Complex(this.re * other, this.im * other);
                } else {
                    return new Complex(
                        this.re * other.re - this.im * other.im,
                        this.re * other.im + this.im * other.re
                    );
                }
            }

            mulMut(other) {
                if (typeof other === 'number') {
                    this.re *= other;
                    this.im *= other;
                    return this;
                } else {
                    let re = this.re;
                    let im = this.im;
                    this.re = re * other.re - im * other.im
                    this.im = re * other.im + im * other.re;
                    return this;
                }
            }

            add(other) {
                return new Complex(this.re + other.re, this.im + other.im);
            }

            addMut(other) {
                this.re += other.re;
                this.im += other.im;
                return this;
            }

            sub(other) {
                return new Complex(this.re - other.re, this.im - other.im);
            }

            subMut(other) {
                this.re -= other.re;
                this.im -= other.im;
                return this;
            }

            norm() {
                return Math.max(Math.abs(this.re), Math.abs(this.im));
            }

            div(other) {
                if (typeof other === 'number') {
                    return new Complex(this.re / other, this.im / other);
                } else {
                    const denominator = other.re ** 2 + other.im ** 2;
                    return new Complex(
                        (this.re * other.re + this.im * other.im) / denominator,
                        (this.im * other.re - this.re * other.im) / denominator
                    );
                }
            }
        }

        class DeepComplex {
            constructor(re, im) {
                this.re = re instanceof Decimal ? re : new Decimal(re);
                this.im = im instanceof Decimal ? im : new Decimal(im);
            }

            abs() {
                return this.re.pow(2).plus(this.im.pow(2));
            }

            mul(other) {
                if (other instanceof DeepComplex) {
                    const realPart = this.re.times(other.re).minus(this.im.times(other.im));
                    const imagPart = this.re.times(other.im).plus(this.im.times(other.re));
                    return new DeepComplex(realPart, imagPart);
                } else if (other instanceof Complex) {
                    const realPart = this.re.times(other.re).minus(this.im.times(other.im));
                    const imagPart = this.re.times(other.im).plus(this.im.times(other.re));
                    return new DeepComplex(realPart, imagPart);
                } else if (other instanceof FloatExpComplex) {
                    other = other.toDeepComplex();
                    const realPart = this.re.times(re).minus(this.im.times(im));
                    const imagPart = this.re.times(im).plus(this.im.times(re));
                    return new DeepComplex(realPart, imagPart);
                } else if (typeof other === 'number') {
                    return new DeepComplex(this.re.times(other), this.im.times(other));
                } else {
                    throw new Error('Invalid type for multiplication');
                }
            }

            add(other) {
                if (other instanceof FloatExpComplex) {
                    other = other.toDeepComplex();
                }
                return new DeepComplex(this.re.plus(other.re), this.im.plus(other.im));
            }

            sub(other) {
                if (other instanceof FloatExpComplex) {
                    other = other.toDeepComplex();
                }
                return new DeepComplex(this.re.minus(other.re), this.im.minus(other.im));
            }

            downCast() {
                return new Complex(this.re.toNumber(), this.im.toNumber())
            }

            toFloatExp() {
                return new FloatExpComplex(
                    getFloatExp(this.re.toString()),
                    getFloatExp(this.im.toString())
                )
            }

            square() {
                const realPart = this.re.times(this.re).minus(this.im.times(this.im)); // a^2 - b^2
                const imagPart = this.re.plus(this.re).times(this.im);     // 2ab
                return new DeepComplex(realPart, imagPart);
            }
        }

        class FloatExpComplex {
            constructor(re, im) {
                this.re = getFloatExp(re);
                this.im = getFloatExp(im);
            }

            abs() {
                return this.re.mul(this.re).addMut(this.im.mul(this.im));
            }

            mul(other) {
                if (typeof other === 'number') {
                    return new FloatExpComplex(this.re.mul(new FloatExp(other, 0)), this.im.mul(new FloatExp(other, 0)));
                } else
                    return new FloatExpComplex(
                        this.re.mul(other.re).subMut(this.im.mul(other.im)),
                        this.re.mul(other.im).addMut(this.im.mul(other.re))
                    )
            }

            div(other) {
                if (typeof other === 'number') {
                    return new FloatExpComplex(this.re.div(new FloatExp(other, 0)), this.im.div(new FloatExp(other, 0)));
                } else
                    return new FloatExpComplex(
                        this.re.div(other.re).subMut(this.im.div(other.im)),
                        this.re.div(other.im).addMut(this.im.div(other.re))
                    )
            }

            add(other) {
                return new FloatExpComplex(
                    this.re.add(other.re),
                    this.im.add(other.im)
                )
            }

            sub(other) {
                return new FloatExpComplex(
                    this.re.sub(other.re),
                    this.im.sub(other.im)
                )
            }

            addMut(other) {
                this.re.addMut(other.re);
                this.im.addMut(other.im);
                return this;
            }

            subMut(other) {
                this.re.subMut(other.re);
                this.im.subMut(other.im);
                return this;
            }

            mulMut(other) {
                const x = this.re;
                const y = this.im;
                this.re = x.mul(other.re).subMut(y.mul(other.im));
                this.im = x.mulMut(other.im).addMut(y.mulMut(other.re));
                return this;
            }

            copy() {
                return new FloatExpComplex(this.re.copy(), this.im.copy());
            }

            toComplex() {
                return new Complex(this.re.doubleValue(), this.im.doubleValue());
            }

            toDeepComplex() {
                return new DeepComplex(
                    new Decimal(this.re.toString()),
                    new Decimal(this.im.toString())
                )
            }

            norm() {
                return FEmax(this.re.abs(), this.im.abs());
            }

            square() {
                const realPart = this.re.square().subMut(this.im.square()); // a^2 - b^2
                const imagPart = this.re.mul(this.im).mulMut(new FloatExp(2));     // 2ab
                return new FloatExpComplex(realPart, imagPart);
            }
        }

        function FEmax(a, b) {
            if (a.compareTo(b) > 0) return a;
            else return b;
        }

        function FEmin(a, b) {
            if (a.compareTo(b) < 0) return a;
            else return b;
        }

        const samples = {
            seahorse: {
                re: "-0.74543",
                im: "0.11301",
                zoom: 5e4,
                it: 2048
            },
            snowflake: {
                re: "-0.10109629004872408548585126380133943559",
                im: "0.9562865745329222746947099385459096648",
                zoom: 3.169126e+29,
                it: 2048
            },
            spiral: {
                re: "-1.999993942175717867792242968103527549859576",
                im: "8.6071861910492399703689002138183e-21",
                zoom: 5.192297e+33,
                it: 2048
            },
            luxury: {
                re: "-0.79580869118304321175952779938151856806452507855882",
                im: "0.18469182276676613095841056743436302824144029079562",
                zoom: 1.3e42,
                it: 4096
            },
            horizon: {
                re: "-1.8584343800176784682217288203669595446250882516610855163",
                im: 0,
                zoom: 2.338403e+48,
                it: 8192
            },
            flora: {
                re: "-1.99909599626591118385320862404514647238736998791060410728750271382258617296138194612160227",
                im: "2.7580719798153099801178971305087708486297199751987655897677764832896127755911711978e-7",
                zoom: 1.554135e+85,
                it: 12000
            },
            classic: {
                re: "-1.740062382579339905220844167065825638296641720436171866879862418461182919644153056054840718339483225743450008259172138785492983677915427169",
                im: "0.02817533977921104899241152114431950968753907674299060857040130959588017432409201863854008146585605536156950844867740770006690377105617915918",
                zoom: 3.169127e+129,
                it: 16384
            },
            e200: {
                re: "-1.966802851116594708819298912851462114119985811705618926682822172678211294505900454587066386326486696211109981444987492635874831274786202351721769325471466717092496114767216598301545236111458996508055081585396",
                im: "0.0010977722859744975944199816905137002369183368289711851029920379829671969621655021360812521504061553173015969230096789768757462998082308739346850130554776214016764573717626859656016612926260380492615038665711972",
                zoom: 3.061802e+200,
                it: 2560
            },
            radiant: {
                re: "-1.99999999999999999999999999999999999999999999999999999999999985604992427869224505485316659406169263456244557162707394015035258073628597813990573253878488792954728746460753235734445467801735035140789540329931747966277516467943284583061883624921231436068907582257",
                im: "-8.91471704727989229599363700420508490047745648395754111902776340339365777429490330220597376804879333373511664660430230981300478098523390924266124801444129e-108",
                zoom: 6.190352e+250,
                it: 32768
            },
            branches: {
                re: "-1.6292734442048283318938320396270139993976098667361842769438797568378211896685981215295380430631824444939812959088045104000652511090002918608428367750404559604873908045574737562161798763493882467959347522331334565200535419490490792109572426042012307199142243133244778278658423929305351347449296418283955642234980665610830226069420767708737186375011028341136058680534715563202637094315075646672266222835522732620561624291470918925972479094214439824838059879454955180554531579035878862691173748960700828240715259267985644677355092076437915522889997465324097488586896011539207914088325170690741321143420090542550202239848652811940259393780795046066233233901935939495310855142242101042",
                im: "0.03869400209621531644885884354220643543483856432312340490566021352296232798895918154015224599032404970872042582187369535150768927860463654320654167750197244691011756126324382371624135105468469098307733451525287938447855301549425418319315644599440229040004000393629694918121347776683198213801647169431881760881989559740902877967780796990256450970464951956949842553605553300056814346433987027958609011265495269006410527939833349934593968626122035005120083542187577701148430417027976032242752140056316110069588785859474053819290291277818754134945550976828752797151560991794888216365813883286779093669780620189356923473044461454552716354829377180996852428111452867133487261674235339815",
                zoom: "1.5710523668200003e671",
                it: 22067
            }
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }


        async function* getReferenceOrbit(C, radius, iterations, reportInterval = 10000) {
            let Z = new DeepComplex(0, 0),
                z = new Complex(0, 0),
                dzdc = new Complex(1, 0),
                one = new Complex(1, 0);

            let lpc = C.downCast(), lpz = new Complex(0, 0); // low precision
            const orbit = [new Complex(0, 0)];

            const waypoints = {};

            for (let i = 1; i < iterations; i++) {
                dzdc = z.add(z).mulMut(dzdc).addMut(one);

                Z = Z.square().add(C);
                lpz = lpz.mul(lpz).addMut(lpc)

                z = Z.downCast();
                orbit.push(z);

                const error = z.sub(lpz).norm();
                if (error > 1e-13) {
                    lpz = z;
                    waypoints[i] = z;
                }

                if (dzdc.norm() * radius * 2 > z.norm()) {
                    const predCenter = z.div(dzdc);
                    console.log(predCenter);
                    break;
                };
                if (z.norm() > 16.0) break;
                if (i % reportInterval == 0) {
                    yield i;
                    await delay(1);
                };
            }
            console.log("Compressed ref: ", waypoints)
            return orbit;
        }

        /**
         * Calculates the reference orbit for a given complex number 'c' using the Mandelbrot iteration.
         * @param {DeepComplex} c - The complex number for which the reference orbit is calculated.
         * @param {number} iterations - The number of iterations to perform.
         * @returns {FloatExpComplex[]} - An array containing the reference orbit.
         */
        async function* getReferenceOrbitFE(C, radius, iterations, reportInterval = 10000) {
            let Z = new DeepComplex(0, 0),
                z = new FloatExpComplex(0, 0),
                dzdc = new FloatExpComplex(1, 0),
                one = new FloatExpComplex(1, 0);
            const orbit = [new FloatExpComplex(0, 0)];
            for (let i = 0; i < iterations; i++) {
                dzdc = z.add(z).mulMut(dzdc).add(one);

                Z = Z.mul(Z).add(C);

                z = Z.toFloatExp();
                orbit.push(z);

                if (dzdc.norm().mul(radius).mul(2).compareTo(z.norm()) > 0) break;
                if (z.norm().doubleValue() > 16.0) break;
                if (i % reportInterval == 0) {
                    yield i;
                    await delay(1);
                };
            }
            return orbit;
        }


        /**
         * Calculates the number of iterations required for a complex number to exceed a given bailout value.
         *
         * @param {number} re - The real part of the complex number.
         * @param {number} im - The imaginary part of the complex number.
         * @param {number} bailout - The bailout value.
         * @param {number} maxiter - The maximum number of iterations to perform.
         * @returns {number} - The number of iterations required for the complex number to exceed the bailout value.
         */
        function getDirect(re, im, bailout, maxiter) {
            let it = 0;
            let re1 = re;
            let im1 = im;

            while (it <= maxiter) {
                let re2 = re * re;
                let im2 = im * im;
                if (re2 + im2 > bailout) return it;
                let temp = re2 - im2 + re1;
                im = 2 * re * im + im1;
                re = temp;
                it++;
            }
            return it;
        }


        /**
         * Generate BLA table
         * @param {Complex[]} ref - The reference orbit
         * @param {number} scale - Current image scale
         * */

        function createBLATable(ref, scale) {
            const lv1 = [];
            const table = [lv1];
            for (let i = 1; i < ref.length; i++) {
                const point = ref[i];

                const A = point.mul(2);
                const B = new Complex(1, 0);
                lv1.push({
                    A: A,
                    B: B,
                    radius: Math.max(0,
                        (point.norm() - B.norm() * scale) / (A.norm() + 1) * 5.96e-8
                    )
                })
            }

            let level = 1;
            while (true) {
                table.push([]);

                for (let i = 0; i < table[level - 1].length; i += 2) {
                    const bla1 = table[level - 1][i];
                    const bla2 = table[level - 1][i + 1];

                    if (bla2 == null) {
                        table[level].push(bla1)
                        continue;
                    };

                    table[level].push({
                        A: bla1.A.mul(bla2.A),
                        B: bla1.B.mul(bla2.A).add(bla2.B),
                        radius: Math.min(
                            bla1.radius, Math.max(
                                0, (bla2.radius - bla1.B.norm() * scale) / bla1.A.norm()
                            )
                        )
                    })

                }
                if (table[level].length <= 1) break;
                level++;
            }

            return table;
        }

        function lookup(table, i, refLen, norm_dz, norm_dc) {
            if (i === 0 || i >= refLen || table.length === 0) {
                return {
                    first: null,
                    second: 0
                };
            }

            let result = {
                first: null,
                second: 0
            }; // { step, length }
            let index = i - 1,
                length = 1;

            for (let level of table) {
                if (norm_dz > level[index].radius) {
                    break;
                }
                result.first = level[index];
                result.second = length;

                if (index % 2) {
                    break;
                }
                index >>= 1; // equivalent to index = Math.floor(index / 2)
                length <<= 1; // equivalent to length *= 2
            }

            result.second = Math.min(result.second, refLen - i);
            return result;
        }

        function createBLATableFE(ref, scale) {
            const lv1 = [];
            const table = [lv1];
            for (let i = 1; i < ref.length; i++) {
                const point = ref[i];

                const A = point.mul(2);
                const B = new FloatExpComplex(1, 0);
                lv1.push({
                    A: A,
                    B: B,
                    radius: FEmax(new FloatExp(0),
                        (point.norm().sub(B.norm().mul(scale))).div(A.norm().add(1)).mul(5.96e-8)
                    )
                })
            }

            let level = 1;
            while (true) {
                table.push([]);

                for (let i = 0; i < table[level - 1].length; i += 2) {
                    const bla1 = table[level - 1][i];
                    const bla2 = table[level - 1][i + 1];

                    if (bla2 == null) {
                        table[level].push(bla1)
                        continue;
                    };

                    table[level].push({
                        A: bla1.A.mul(bla2.A),
                        B: bla1.B.mul(bla2.A).add(bla2.B),
                        radius: FEmin(
                            bla1.radius, FEmax(
                                new FloatExp(0), (bla2.radius.sub(bla1.B.norm().mul(scale))).div(bla1.A.norm())
                            )
                        )
                    })

                }
                if (table[level].length <= 1) break;
                level++;
            }

            return table;
        }

        function lookupFE(table, i, refLen, norm_dz, norm_dc) {
            if (i === 0 || i >= refLen || table.length === 0) {
                return {
                    first: null,
                    second: 0
                };
            }

            let result = {
                first: null,
                second: 0
            }; // { step, length }
            let index = i - 1,
                length = 1;

            for (let level of table) {
                if (norm_dz.compareTo(level[index].radius) > 0) {
                    break;
                }
                result.first = level[index];
                result.second = length;

                if (index % 2) {
                    break;
                }
                index >>= 1; // equivalent to index = Math.floor(index / 2)
                length <<= 1; // equivalent to length *= 2
            }

            result.second = Math.min(result.second, refLen - i);
            return result;
        }


        /**
         * Calculates the escape time for a point in the Mandelbrot set using perturbation theory.
         * @param {Complex} dc - The perturbation applied to the point.
         * @param {Complex[]} ref - The reference orbit.
         * @param {Complex[][]} table - The BLA table.
         * @param {number} maxIter - The maximum iteration.
         * @param {number} bailout - The bailout value used for iteration termination.
         * @returns {number|null} - The escape time for the point or null if it doesn't escape.
         */
        function getPTBLA(dc, ref, table, maxIter, bailout, dzRe = 0, dzIm = 0, iter = -1, refIter = 0) {

            let dcNorm = Math.max(Math.abs(dc.re), Math.abs(dc.im));
            while (iter < maxIter) {
                let dzNorm = Math.max(Math.abs(dzRe), Math.abs(dzIm)); // Chebyshev norm

                let result = lookup(table, refIter, ref.length, dzNorm, dcNorm);

                if (result.first != null) {
                    let aRe = result.first.A.re,
                        aIm = result.first.A.im;
                    let bRe = result.first.B.re,
                        bIm = result.first.B.im;

                    let newDzRe = dzRe * aRe - dzIm * aIm + dc.re * bRe - dc.im * bIm;
                    let newDzIm = dzRe * aIm + dzIm * aRe + dc.re * bIm + dc.im * bRe;

                    dzRe = newDzRe;
                    dzIm = newDzIm;

                    iter += result.second;
                    refIter += result.second;
                } else {
                    const Z = ref[refIter];

                    let tempRe = dzRe,
                        tempIm = dzIm;

                    // dz = dz * 2 * Z + dz^2 + dc
                    dzRe = (2 * Z.re + tempRe) * tempRe - (2 * Z.im + tempIm) * tempIm + dc.re;
                    dzIm = 2 * (Z.re * tempIm + Z.im * tempRe + tempRe * tempIm) + dc.im;

                    iter++;
                    refIter++;
                }

                if (refIter >= ref.length) return iter;
                const Z2 = ref[refIter];
                let valRe = Z2.re + dzRe;
                let valIm = Z2.im + dzIm;

                // Squared Euclidean distance (abs squared)
                let valAbsSq = valRe * valRe + valIm * valIm;
                if (valAbsSq > bailout) {
                    let fracIter = Math.log(valAbsSq) / 2;
                    fracIter = Math.log(fracIter / Math.LN2) / Math.LN2;
                    iter += 1 - fracIter;
                    return iter;
                }

                let dzAbsSq = dzRe * dzRe + dzIm * dzIm;
                if (valAbsSq < dzAbsSq || refIter == ref.length - 1) {
                    dzRe = valRe;
                    dzIm = valIm;
                    refIter = 0;
                }
            }
            return iter;
        }

        function getPTBLAFE(dc, ref, table, maxIter, bailout) {
            let dz = new FloatExpComplex(0, 0)

            let iter = -1;
            let refIter = 0;
            let bout = new FloatExp(bailout);
            let zero = new FloatExp(0);
            let dcNorm = dc.norm();

            while (iter < maxIter) {
                let dzNorm = dz.norm();
                let result = lookupFE(table, refIter, ref.length, dzNorm, dcNorm)

                if (result.first != null) {
                    dz.mulMut(result.first.A).addMut(dc.mul(result.first.B));
                    iter += result.second;
                    refIter += result.second;
                } else {
                    const Z = ref[refIter]
                    let dz2 = dz.square();
                    dz.addMut(dz).mulMut(Z).addMut(dz2).addMut(dc)
                    iter++;
                    refIter++;
                }
                if (refIter >= ref.length) return iter;

                const Z2 = ref[refIter]
                const val = Z2.add(dz);
                const valAbs = val.abs();
                if (valAbs.doubleValue() > bailout) {
                    let fracIter = Math.log(valAbs.doubleValue()) / 2;
                    fracIter = Math.log(fracIter / Math.LN2) / Math.LN2;
                    iter += 1 - fracIter;
                    return iter;
                };
                if (valAbs.sub(dzNorm).compareTo(zero) < 0 || refIter == ref.length - 1) { // æ£€æµ‹æ˜¯å¦éœ€è¦å˜åŸº
                    dz = val;
                    refIter = 0;
                }
            }
            return iter;
        }

        /**
         * Generates a rainbow palette of colors.
         * @param {number} numColors - The number of colors to generate.
         * @returns {number[][]} - An array containing RGBA values for each color in the palette.
         */
        function generateRainbowPalette(numColors) {
            const rainbowColors = [];
            const frequency = 0.2; // Adjust the frequency to change the spread of colors

            for (let i = 0; i < numColors; i++) {
                const red = Math.sin(frequency * i) * 127 + 128;
                const green = Math.sin(frequency * 1.1 * i) * 127 + 128;
                const blue = Math.sin(frequency * 1.2 * i) * 127 + 128;
                rainbowColors.push([red | 0, green | 0, blue | 0, 255]);
            }

            return rainbowColors;
        }

        let defaultPalette = [[1, 1, 1], [205, 92, 92], [240, 128, 128], [255, 0, 0], [178, 34, 34], [139, 0, 0], [188, 143, 143], [165, 42, 42], [128, 0, 0], [250, 128, 114], [255, 99, 71], [233, 150, 122], [255, 127, 80], [255, 69, 0], [255, 160, 122], [160, 82, 45], [210, 105, 30], [139, 69, 19], [244, 164, 96], [255, 218, 185], [205, 133, 63], [255, 228, 196], [255, 140, 0], [222, 184, 135], [210, 180, 140], [255, 222, 173], [255, 228, 181], [255, 165, 0], [245, 222, 179], [184, 134, 11], [218, 165, 32], [255, 215, 0], [240, 230, 140], [238, 232, 170], [189, 183, 107], [255, 255, 0], [128, 128, 0], [107, 142, 35], [154, 205, 50], [85, 107, 47], [173, 255, 47], [127, 255, 0], [124, 252, 0], [0, 255, 0], [50, 205, 50], [152, 251, 152], [144, 238, 144], [34, 139, 34], [0, 128, 0], [0, 100, 0], [143, 188, 143], [46, 139, 87], [60, 179, 113], [0, 255, 127], [0, 250, 154], [102, 205, 170], [127, 255, 212], [64, 224, 208], [32, 178, 170], [72, 209, 204], [0, 139, 139], [0, 128, 128], [0, 255, 255], [175, 238, 238], [0, 206, 209], [95, 158, 160], [176, 224, 230], [173, 216, 230], [0, 191, 255], [135, 206, 235], [135, 206, 250], [70, 130, 180], [30, 144, 255], [176, 196, 222], [100, 149, 237], [65, 105, 225], [0, 0, 255], [0, 0, 205], [0, 0, 139], [0, 0, 128], [25, 25, 112], [106, 90, 205], [72, 61, 139], [123, 104, 238], [147, 112, 219], [138, 43, 226], [75, 0, 130], [153, 50, 204], [148, 0, 211], [186, 85, 211], [216, 191, 216], [221, 160, 221], [238, 130, 238], [255, 0, 255], [139, 0, 139], [128, 0, 128], [218, 112, 214], [199, 21, 133], [255, 20, 147], [255, 105, 180], [219, 112, 147], [220, 20, 60], [255, 192, 203], [255, 182, 193], [220, 220, 220], [211, 211, 211], [192, 192, 192], [169, 169, 169], [128, 128, 128], [105, 105, 105], [119, 136, 153], [112, 128, 144], [47, 79, 79]]
        let palette = defaultPalette;
        let colorStep = 6;
        /**
         * Calculates the color transition between two colors in a palette based on a percentage.
         * @param {number[][]} pal - The palette containing RGB values for colors.
         * @param {number} it - The percentage of transition between two colors (0 to 1).
         * @returns {number[]} - An array containing RGB values for the interpolated color.
         */
        function colorTrans(pal, it) {
            var percent = it - Math.floor(it);
            var c1 = Math.floor(it) % pal.length;
            var c2 = (c1 + 1) % pal.length;
            var r = (1 - percent) * pal[c1][0] + (percent) * pal[c2][0];
            var g = (1 - percent) * pal[c1][1] + (percent) * pal[c2][1];
            var b = (1 - percent) * pal[c1][2] + (percent) * pal[c2][2];
            return [r, g, b]
        }

        /**
         * Gets the color associated with the escape time 'it'.
         * @param {number|null} it - The escape time for a point or null if it doesn't escape.
         * @returns {number[]} - An array containing RGBA values for the color associated with the escape time.
         */
        function getColor(it, maxIter) {
            if (it == null || it >= maxIter) return [0, 0, 0, 255];
            else if (it < 0) return [palette[0][0], palette[0][1], palette[0][2], 255];
            let color = colorTrans(palette, it / colorStep);
            return [color[0], color[1], color[2], 255];
        }

        function groupArray(arr, groupSize = 3) {
            if (!arr || arr.length === 0 || groupSize <= 0) {
                return [];
            }

            const result = [];
            for (let i = 0; i < arr.length; i += groupSize) {
                result.push(arr.slice(i, i + groupSize));
            }
            return result;
        }

        function sortByProximityToCenterPixel(array, imageWidth, imageHeight) {
            // é¢„å…ˆè®¡ç®—ä¸­å¿ƒç‚¹åæ ‡
            const centerX = imageWidth / 2;
            const centerY = imageHeight / 2;

            // ä½¿ç”¨mapåˆ›å»ºå¸¦è·ç¦»å¹³æ–¹çš„ä¸´æ—¶æ•°ç»„
            const withDistSq = array.map(item => {
                const centerItemX = item.x + item.w / 2;  // å…ƒç´ ä¸­å¿ƒX
                const centerItemY = item.y + item.h / 2;  // å…ƒç´ ä¸­å¿ƒY
                const dx = centerItemX - centerX;         // Xæ–¹å‘å·®å€¼
                const dy = centerItemY - centerY;         // Yæ–¹å‘å·®å€¼
                return {
                    item: item,
                    distSq: dx * dx + dy * dy            // è·ç¦»å¹³æ–¹ï¼ˆé¿å…å¼€æ–¹ï¼‰
                };
            });

            // æŒ‰è·ç¦»å¹³æ–¹æŽ’åºï¼ˆå‡åºï¼‰
            withDistSq.sort((a, b) => a.distSq - b.distSq);

            // æå–åŽŸå§‹å…ƒç´ 
            return withDistSq.map(entry => entry.item);
        }

        function base64ToByteArray(base64String) {
            try {
                // è¿˜åŽŸå­—ç¬¦å¹¶å°†URLå®‰å…¨çš„Base64è½¬æ¢ä¸ºæ ‡å‡†Base64
                let base64 = base64String.replace(/-/g, '+').replace(/_/g, '/');

                // æ·»åŠ  padding (ç¡®ä¿é•¿åº¦æ˜¯4çš„å€æ•°)
                const padLength = (4 - (base64.length % 4)) % 4;
                base64 += '='.repeat(padLength);

                const binaryString = atob(base64); // è§£ç Base64
                const byteArray = new Uint8Array(binaryString.length);

                for (let i = 0; i < binaryString.length; i++) {
                    byteArray[i] = binaryString.charCodeAt(i);
                }

                return Array.from(byteArray);
            } catch (error) {
                throw new Error("è¾“å…¥ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„URLå®‰å…¨Base64å­—ç¬¦ä¸²ã€‚");
            }
        }

        function byteArrayToBase64(byteArray) {
            if (!Array.isArray(byteArray)) {
                throw new Error("è¾“å…¥å¿…é¡»æ˜¯ä¸€ä¸ªæ•°ç»„ã€‚");
            }

            // éªŒè¯å­—èŠ‚æ•°ç»„
            if (byteArray.some(v => typeof v !== 'number' || !Number.isInteger(v) || v < 0 || v > 255)) {
                throw new Error("æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ å¿…é¡»æ˜¯0-255ä¹‹é—´çš„æ•´æ•°ã€‚");
            }

            // æž„å»ºäºŒè¿›åˆ¶å­—ç¬¦ä¸²
            const binaryString = String.fromCharCode(...byteArray);

            // ç¼–ç å¹¶è½¬æ¢ä¸ºURLå®‰å…¨æ ¼å¼
            const base64 = btoa(binaryString)
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=+$/, '');

            return base64;
        }
        // ============================

        function fExp2Obj(fExp) {
            return { mant: fExp.base, exp: fExp.exp }
        }
        function fExpComplex2Obj(fExpComplex) {
            return {
                re: fExp2Obj(fExpComplex.re),
                im: fExp2Obj(fExpComplex.im)
            }
        }

        function createWorker() {

            function constructRef(refArray) {
                let ref = [];
                for (let i = 0; i < refArray.length; i++) {
                    ref.push(new Complex(refArray[i][0], refArray[i][1]));
                }
                return ref;
            }

            function constructBla(blaArray) {
                let out = []
                for (let i = 0; i < blaArray.length; i++) {
                    out.push([])
                    for (let j = 0; j < blaArray[i].length; j++) {
                        out[i].push({
                            A: new Complex(blaArray[i][j].A[0], blaArray[i][j].A[1]),
                            B: new Complex(blaArray[i][j].B[0], blaArray[i][j].B[1]),
                            radius: blaArray[i][j].radius
                        })
                    }
                }
                return out
            }

            function obj2FExp(obj) {
                return new FloatExp(obj.mant, obj.exp)
            }

            function obj2FExpComplex(obj) {
                return new FloatExpComplex(obj2FExp(obj.re), obj2FExp(obj.im))
            }
            function constructRefFE(refArray) {
                let ref = [];
                for (let i = 0; i < refArray.length; i++) {
                    ref.push(obj2FExpComplex(refArray[i]));
                }
                return ref;
            }

            function constructBlaFE(blaArray) {
                let out = []
                for (let i = 0; i < blaArray.length; i++) {
                    out.push([])
                    for (let j = 0; j < blaArray[i].length; j++) {
                        out[i].push({
                            A: obj2FExpComplex(blaArray[i][j].A),
                            B: obj2FExpComplex(blaArray[i][j].B),
                            radius: obj2FExp(blaArray[i][j].radius)
                        })
                    }
                }
                return out
            }

            self.onmessage = function (event) {
                let calc = []
                switch (event.data.type) {
                    case 'ref':
                        if (!event.data.deep) {
                            self.refArray = constructRef(event.data.ref);
                            self.blaArray = constructBla(event.data.bla);
                        } else {
                            self.refArray = constructRefFE(event.data.ref);
                            self.blaArray = constructBlaFE(event.data.bla);
                        }
                        self.deep = event.data.deep;
                        break
                    case 'calc':
                        const calc = [];
                        if (!self.deep) {
                            for (let delta of event.data.deltas) {
                                try {
                                    let it = getPTBLA(
                                        // 0: re, 1: im, 2: x, 3: y, 4: w, 5: h
                                        new Complex(delta[0], delta[1]),
                                        self.refArray,
                                        self.blaArray,
                                        event.data.maxIter,
                                        event.data.bailout
                                    );
                                    calc.push({
                                        it: it,
                                        x: delta[2],
                                        y: delta[3],
                                        w: delta[4],
                                        h: delta[5]
                                        // x: delta.x,
                                        // y: delta.y,
                                        // w: delta.w,
                                        // h: delta.h
                                    });
                                } catch (e) { }
                            }
                        } else {
                            for (let delta of event.data.deltas) {
                                try {
                                    let it = getPTBLAFE(
                                        new FloatExpComplex(
                                            new FloatExp(delta.re.base, delta.re.exp),
                                            new FloatExp(delta.im.base, delta.im.exp)
                                        ),
                                        self.refArray,
                                        self.blaArray,
                                        event.data.maxIter,
                                        event.data.bailout
                                    );
                                    calc.push({
                                        it: it,
                                        x: delta.x,
                                        y: delta.y,
                                        w: delta.w,
                                        h: delta.h
                                    });
                                } catch (e) { }
                            }
                        }
                        self.postMessage(calc);
                }

            };
        }


        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        const code = new TextEncoder().encode(`
    ${Complex.toString()}${lookup.toString()};${getPTBLA.toString()}
    ${FloatExp.toString()}${FloatExpComplex.toString()}${getFloatExp.toString()}
    ${doubleToFloatExp.toString()}${FEmax.toString()}${FEmin.toString()}
    ${getPTBLAFE.toString()}${lookupFE.toString()}
        (
        ${createWorker.toString()}
        )();`);
        const workerData = 'data:application/javascript;base64,' + arrayBufferToBase64(code)

        /**
         * Represents a Mandelbrot set visualization.
         */
        class Mandelbrot {
            center;
            iterations;
            bailout;
            size;

            canvas;
            context;

            ref;

            refValid;

            stats;

            img;

            rendering;

            /**
             * @param {HTMLCanvasElement} canvas - The canvas element to draw the Mandelbrot set.
             * @param {DeepComplex} center - The center point of the Mandelbrot set.
             * @param {number} iterations - The number of iterations to perform for each point.
             * @param {number} bailout - The bailout value used for iteration termination.
             */
            constructor(canvas, center, iterations, bailout) {
                this.center = center;
                this.iterations = iterations;
                this.bailout = bailout * bailout;

                this.size = new FloatExp(4);
                this.deep = false;

                this.canvas = canvas;
                this.context = canvas.getContext('2d');
                this.context.imageSmoothingEnabled = false;
                this.rendering = false;
                this.iterMap = [...new Array(this.canvas.height)].map(e => [...new Array(this.canvas.width)].map(e => 0))
                this.videoRendering = false;

                canvas.addEventListener('mousedown', e => {
                    if (e.button === 0 && !this.rendering) {
                        // Left click: decrease size
                        console.log(this.getDelta(e.offsetX, e.offsetY));
                        this.click(
                            e.offsetX / canvas.offsetWidth * canvas.width,
                            e.offsetY / canvas.offsetHeight * canvas.height
                        );
                        this.update();
                    }
                });

                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    if (!this.rendering)
                        if (e.deltaY < 0) {
                            this.click(e.offsetX / canvas.offsetWidth * canvas.width, e.offsetY / canvas.offsetHeight * canvas.height);
                            this.update();
                        } else if (e.deltaY > 0) {
                            this.zoomOut();
                            this.update();
                        }
                });

                canvas.addEventListener('contextmenu', e => {
                    e.preventDefault();
                    if (!this.rendering) {
                        this.zoom(this.size.mul(4));
                        this.update();
                    }
                })

                let iterCountSpan = document.getElementById('iter-count')
                canvas.addEventListener('mousemove', e => {
                    let imageX = e.offsetX - canvas.clientLeft;
                    let imageY = e.offsetY - canvas.clientTop;

                    iterCountSpan.textContent = (this.iterMap[imageY]?.[imageX])?.toFixed(2) ?? "-";
                })

                this.stats = {
                    ref: 0,
                    calc: 0,
                    guess: 0,
                    approx: 0,
                    time: performance.now()
                }


                this.counter = 0;
                this.workerCounter = 0;
                this.resolveFunc = null;
                this.workers = []
                for (let i = 0; i < CPU_CORES; i++) {
                    this.workers[i] = new Worker(workerData);
                    this.workers[i].onmessage = event => {
                        this.stats.calc += event.data.length;
                        for (let delta of event.data) {
                            this.setIter(delta.x, delta.y, delta.it, delta.w, delta.h);
                        }
                        this.counter--;
                        // if (this.counter % CPU_CORES == 0) {
                        // };
                        this.showInfo();
                        this.context.putImageData(this.image, 0, 0)

                        if (this.counter <= 0) {
                            this.resolveFunc();
                        }
                    }
                }

            }

            click(x, y) {
                // Calculate the new center and zoom level
                this.goto(this.center.add(this.getDelta(x, y)), false);
                this.zoom(this.size.div(4));

                // Capture the clicked section (a quarter of the canvas size around the click point)
                const zoomWidth = this.canvas.width / 4;
                const zoomHeight = this.canvas.height / 4;
                const startX = x - zoomWidth / 2; // Top-left x of the zoomed region
                const startY = y - zoomHeight / 2; // Top-left y of the zoomed region

                // Scale up the selected region to 4x its size
                this.context.drawImage(
                    this.canvas,
                    startX, startY, zoomWidth, zoomHeight,  // Source region (original size)
                    0, 0, this.canvas.width, this.canvas.height // Destination (scaled to fit canvas)
                );
            }

            zoomOut() {
                let newMap = [...new Array(this.canvas.height)].map(e => [...new Array(this.canvas.width)].map(e => 0))
                for (let y = 0; y < this.canvas.height; y += 2) {
                    for (let x = 0; x < this.canvas.width; x += 2) {
                        newMap
                        [this.canvas.height / 4 + y / 2]
                        [this.canvas.width / 4 + x / 2]
                            =
                            this.iterMap[y][x];
                    }
                }
                this.iterMap = newMap;
                this.size = this.size.mul(2);
            }

            /**
             * Zooms the Mandelbrot set visualization.
             * @param {FloatExp} size - The new size of the visualization.
             */
            zoom(size) {
                Decimal.config({
                    precision: -size.exp + 10
                })
                this.deep = this.size.exp < -300;
                this.size = size;
                this.clear();
            }

            /**
             * Clear iteration map
             */
            clear() {
                this.iterMap.forEach(e => e.fill(0))
            }

            /**
             * Moves the center of the Mandelbrot set visualization.
             * @param {DeepComplex} c - The new center point.
             */
            goto(c, clear = true) {
                this.center = c;
                this.refValid = false;
                if (clear) {
                    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.clear();
                }
            }

            /**
             * Sets the number of iterations for the Mandelbrot set visualization.
             * @param {number} it - The number of iterations.
             */
            setIterations(it) {
                this.iterations = parseInt(it);
            }

            /**
             * Resets the Mandelbrot set visualization to its initial state.
             */
            home() {
                this.goto(new DeepComplex(new Decimal(0), new Decimal(0)))
                this.size = new FloatExp(4);
                this.deep = false;
                this.iterations = 256;
            }

            /**
             * Calculates the delta between a point and the base point on the canvas.
             * @param {number} x - The x-coordinate of the point.
             * @param {number} y - The y-coordinate of the point.
             * @param {number} [baseX] - The x-coordinate of the base point (optional).
             * @param {number} [baseY] - The y-coordinate of the base point (optional).
             * @returns {FloatExpComplex} - The delta as a complex number.
             */
            getDelta(x, y, baseX, baseY) {
                if (!baseX) baseX = this.canvas.width / 2;
                if (!baseY) baseY = this.canvas.height / 2;
                return this.deep ? new FloatExpComplex(
                    this.size.mul((x - baseX) / this.canvas.width),
                    this.size.mul((baseY - y) / this.canvas.height)
                ) : new Complex(
                    (x - baseX) / this.canvas.width * this.size,
                    (baseY - y) / this.canvas.height * this.size
                )
            }


            /**
             * Retrieves the iteration of a pixel in the Mandelbrot set visualization.
             * @param {number} x - The x-coordinate of the pixel.
             * @param {number} y - The y-coordinate of the pixel.
             * @returns {number} - The iteration of the given point.
             */
            getIter(x, y) {
                if (x >= this.canvas.width || x < 0 || y >= this.canvas.height || y <= 0) return -1
                return this.iterMap[y][x];
            }

            /**
             * Sets the iteration of a pixel in the Mandelbrot set visualization.
             * @param {number} x - The x-coordinate of the pixel.
             * @param {number} y - The y-coordinate of the pixel.
             * @param {number} it - The iteration
             * @param {number} w - The width of the pixel.
             * @param {number} h - The height of the pixel.
             */
            setIter(x, y, it, w = 1, h = 1) {
                this.iterMap[y][x] = it;

                const color = getColor(it, this.iterations);

                let i = (y * this.canvas.width + x) << 2;
                for (let dy = 0; dy < h; dy++) {
                    for (let dx = 0; dx < w; dx++) {
                        let j = (dy * this.canvas.width + dx) << 2;
                        this.image.data[i + j] = color[0]
                        this.image.data[i + j + 1] = color[1]
                        this.image.data[i + j + 2] = color[2]
                        this.image.data[i + j + 3] = 255
                    }
                }
                // this.context.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`
                // this.context.fillRect(x, y, w, h)
            }

            showInfo() {
                let totalPixels = this.canvas.width * this.canvas.height;
                let statusText = `Reference: ${this.stats.ref}it\nApproximation: ${this.blaTable?.length ?? 0} levels\nCalculation: ${this.stats.calc} (${(this.stats.calc / totalPixels * 100).toFixed(2)}%)\nGuessed: ${this.stats.guess} (${(this.stats.guess / totalPixels * 100).toFixed(2)}%)\nTime: ${((performance.now() - this.stats.time) / 1000).toFixed(3)}s`;
                progressBar.style.width = `${((this.stats.calc) / totalPixels * 100).toFixed(2)}%`;
                guessedProgressBar.style.width = `${((this.stats.guess) / totalPixels * 100).toFixed(2)}%`;
                if (!this.rendering) {
                    statusText += "\nDone!";
                }
                statsLabel.innerText = statusText;
            }

            setLocked(locked) {
                if (locked) {
                    // Lock buttons
                    document.querySelectorAll('.control-button').forEach(button => {
                        button.disabled = true;
                    });
                    canvas.classList.add('running')
                } else {
                    // Unlock buttons
                    document.querySelectorAll('.control-button').forEach(button => {
                        button.disabled = false;
                    });
                    canvas.classList.remove('running')
                }
            }

            /**
             * Updates the Mandelbrot set visualization.
             *
             */
            async update() {
                this.rendering = true;
                this.setLocked(true)
                this.stats = {
                    ref: 0,
                    calc: 0,
                    guess: 0,
                    approx: 0,
                    time: performance.now()
                };

                let prevDeep = this.deep;
                this.deep = this.size.exp < -300;
                if (prevDeep && !this.deep) this.ref = this.ref.map(e => e.toComplex());

                reInput.value = this.center.re;
                imInput.value = this.center.im;
                zoomInput.value = new FloatExp(4).div(this.size).toString()
                itInput.value = this.iterations;

                this.image = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);

                let base, ref;
                let refLen = 0;

                base = this.center;
                if (!this.refValid) {
                    console.log(performance.now() + " computing reference")
                    let nextTerm;

                    let reportInterval = Math.max(1, Math.floor(200000 / -this.size.exp));

                    const generator = this.deep ?
                        getReferenceOrbitFE(base, this.size, this.iterations, reportInterval) :
                        getReferenceOrbit(base, this.size.doubleValue(), this.iterations, reportInterval);
                    while (!(nextTerm = await generator.next()).done) {
                        this.stats.ref = nextTerm.value;
                        this.showInfo(); // Update progress
                    }
                    ref = nextTerm.value;
                    this.stats.ref = ref.length;

                    this.ref = ref;
                    this.refValid = true;
                } else {
                    ref = this.ref;
                    this.stats.ref = ref.length;
                }
                refLen = ref.length;
                console.log("ref iter: " + ref.length)

                console.log(performance.now() + " bla calculation")

                if (this.deep) {
                    this.blaTable = createBLATableFE(ref, this.size);
                }
                else
                    this.blaTable = createBLATable(ref, this.size.doubleValue())


                let autoIter = Math.max((refLen - 1) * 32, this.iterations);
                this.setIterations(autoIter);

                console.log(performance.now() + " perturbation")

                let workerRef = this.deep ? this.ref.map(e => fExpComplex2Obj(e)) : this.ref.map(e => [e.re, e.im]);
                let workerBla = this.deep ?
                    this.blaTable.map(e => e.map(e2 => {
                        return { A: fExpComplex2Obj(e2.A), B: fExpComplex2Obj(e2.B), radius: fExp2Obj(e2.radius) }
                    }))
                    : this.blaTable.map(e => e.map(e2 => {
                        return { A: [e2.A.re, e2.A.im], B: [e2.B.re, e2.B.im], radius: e2.radius }
                    }))

                for (let i = 0; i < this.workers.length; i++) {
                    this.workers[i].postMessage({
                        type: 'ref',
                        ref: workerRef,
                        bla: workerBla,
                        deep: this.deep
                    });
                }

                let p1 = () => {
                    return new Promise(async (r, j) => {
                        this.counter = 0;
                        this.workerCounter = 0;
                        this.resolveFunc = r;

                        // æ”¶é›†æ‰€æœ‰éœ€è¦è®¡ç®—çš„deltas
                        let allDeltas = [];
                        for (let y = 0; y < this.canvas.height; y += 2) {
                            for (let x = 0; x < this.canvas.width; x += 2) {
                                if (this.iterMap[y][x] > 0) {
                                    this.setIter(x, y, this.iterMap[y][x]);
                                    this.stats.guess++;
                                    continue;
                                }
                                // è®¡ç®—å¹¶æ”¶é›†delta
                                let delta = this.getDelta(x, y);
                                allDeltas.push([delta.re, delta.im, x, y, 2, 2]);
                                // allDeltas.push({
                                //     re: delta.re,
                                //     im: delta.im,
                                //     x: x,
                                //     y: y,
                                //     w: 2,
                                //     h: 2
                                // });
                            }
                        }

                        allDeltas = sortByProximityToCenterPixel(allDeltas, this.canvas.width, this.canvas.height); // æŒ‰ç…§è·ç¦»ä¸­å¿ƒç‚¹æŽ’åº

                        // å°†deltaså‡åˆ†åˆ°æ¯ä¸ªæ ¸å¿ƒ
                        const chunkSize = 64 * 64;
                        const chunks = Math.ceil(allDeltas.length / chunkSize);
                        for (let i = 0; i < chunks; i++) {
                            const start = i * chunkSize;
                            const end = start + chunkSize;
                            const deltasChunk = allDeltas.slice(start, end);
                            if (deltasChunk.length === 0) continue; // è·³è¿‡ç©ºæ•°æ®

                            const data = {
                                type: 'calc',
                                deltas: deltasChunk,
                                maxIter: this.iterations,
                                bailout: this.bailout,
                            };

                            // è½®è¯¢åˆ†é…Worker
                            const workerIndex = this.workerCounter % CPU_CORES;
                            this.workers[workerIndex].postMessage(data);
                            this.counter++; // è¿½è¸ªå‘é€çš„ä»»åŠ¡æ€»æ•°
                            this.workerCounter++;
                        }

                        if (this.counter <= 0) {
                            this.resolveFunc();
                        }
                    });
                };

                let p2 = () => {
                    return new Promise(async (r, j) => {

                        this.counter = 0;
                        this.workerCounter = 0;
                        this.resolveFunc = r;

                        // æ”¶é›†æ‰€æœ‰éœ€è¦è®¡ç®—çš„deltas
                        let allDeltas = [];
                        for (let y = 0; y < this.canvas.height; y += 2) {
                            for (let x = 1; x < this.canvas.width; x += 2) {
                                if (this.iterMap[y][x] > 0) {
                                    this.setIter(x, y, this.iterMap[y][x])
                                    this.stats.guess++;
                                    continue
                                }
                                let leftColor = this.getIter(x - 1, y);
                                let rightColor = this.getIter(x + 1, y);
                                if (Math.floor(leftColor) == Math.floor(rightColor) && leftColor > 0 && rightColor > 0) {
                                    this.setIter(x, y, (leftColor + rightColor) / 2);
                                    this.stats.guess++;
                                } else {
                                    let delta = this.getDelta(x, y);
                                allDeltas.push([delta.re, delta.im, x, y, 1, 2]);
                                    // allDeltas.push({
                                    //     re: delta.re,
                                    //     im: delta.im,
                                    //     x: x,
                                    //     y: y,
                                    //     w: 1,
                                    //     h: 2
                                    // })
                                }
                            }
                        }

                        allDeltas = sortByProximityToCenterPixel(allDeltas, this.canvas.width, this.canvas.height);

                        // å°†deltaså‡åˆ†åˆ°æ¯ä¸ªæ ¸å¿ƒ
                        const chunkSize = 64 * 64;
                        const chunks = Math.ceil(allDeltas.length / chunkSize);
                        for (let i = 0; i < chunks; i++) {
                            const start = i * chunkSize;
                            const end = start + chunkSize;
                            const deltasChunk = allDeltas.slice(start, end);
                            if (deltasChunk.length === 0) continue; // è·³è¿‡ç©ºæ•°æ®

                            const data = {
                                type: 'calc',
                                deltas: deltasChunk,
                                maxIter: this.iterations,
                                bailout: this.bailout,
                            };

                            // è½®è¯¢åˆ†é…Worker
                            const workerIndex = this.workerCounter % CPU_CORES;
                            this.workers[workerIndex].postMessage(data);
                            this.counter++; // è¿½è¸ªå‘é€çš„ä»»åŠ¡æ€»æ•°
                            this.workerCounter++;
                        }

                        if (this.counter <= 0) {
                            this.resolveFunc();
                        }
                    })
                }

                let p3 = () => {
                    return new Promise(async (r, j) => {
                        this.counter = 0;
                        this.workerCounter = 0;
                        this.resolveFunc = r;

                        let allDeltas = [];
                        for (let y = 1; y < this.canvas.height; y += 2) {
                            for (let x = 0; x < this.canvas.width; x++) {
                                if (this.iterMap[y][x] != 0) {
                                    this.setIter(x, y, this.iterMap[y][x])
                                    this.stats.guess++;
                                    continue
                                }

                                let upColor = this.getIter(x, y - 1);
                                let downColor = this.getIter(x, y + 1);
                                if (Math.floor(upColor) == Math.floor(downColor) && upColor > 0 && downColor > 0) {
                                    this.setIter(x, y, (upColor + downColor) / 2);
                                    this.stats.guess++;
                                } else {
                                    let delta = this.getDelta(x, y);
                                allDeltas.push([delta.re, delta.im, x, y, 1,1]);
                                    // allDeltas.push({
                                    //     re: delta.re,
                                    //     im: delta.im,
                                    //     x: x,
                                    //     y: y,
                                    //     w: 1,
                                    //     h: 1
                                    // })
                                }
                            }
                        }

                        allDeltas = sortByProximityToCenterPixel(allDeltas, this.canvas.width, this.canvas.height);

                        // å°†deltaså‡åˆ†åˆ°æ¯ä¸ªæ ¸å¿ƒ
                        const chunkSize = 64 * 64;
                        const chunks = Math.ceil(allDeltas.length / chunkSize);
                        for (let i = 0; i < chunks; i++) {
                            const start = i * chunkSize;
                            const end = start + chunkSize;
                            const deltasChunk = allDeltas.slice(start, end);
                            if (deltasChunk.length === 0) continue; // è·³è¿‡ç©ºæ•°æ®

                            const data = {
                                type: 'calc',
                                deltas: deltasChunk,
                                maxIter: this.iterations,
                                bailout: this.bailout,
                            };

                            // è½®è¯¢åˆ†é…Worker
                            const workerIndex = this.workerCounter % CPU_CORES;
                            this.workers[workerIndex].postMessage(data);
                            this.counter++; // è¿½è¸ªå‘é€çš„ä»»åŠ¡æ€»æ•°
                            this.workerCounter++;
                        }

                        if (this.counter <= 0) {
                            this.resolveFunc();
                        }
                    })
                }

                await p1();
                await p2();
                await p3();

                // Distance estimation
                if (this.distanceEstimation) {
                    for (let y = 0; y < this.canvas.height - 1; y++) {
                        for (let x = 0; x < this.canvas.width - 1; x++) {
                            let gradX = this.iterMap[y][x + 1] - this.iterMap[y][x];
                            let gradY = this.iterMap[y + 1][x] - this.iterMap[y][x];
                            let diff = Math.sqrt(gradX * gradX + gradY * gradY);

                            let j = (y * this.canvas.width + x) << 2;

                            let color = getColor(Math.log1p(diff) * 32 / colorStep, 10000);

                            this.image.data[j] = color[0]
                            this.image.data[j + 1] = color[1]
                            this.image.data[j + 2] = color[2]
                            this.image.data[j + 3] = 255
                        }
                    }
                    this.context.putImageData(this.image, 0, 0)
                }

                console.log('done!')
                this.rendering = false;
                this.showInfo();
                const params = new URLSearchParams(window.location.hash.substring(1));

                // æ›´æ–°æˆ–æ·»åŠ æ–°çš„å‚æ•°
                params.set("rec", compressDecimal(this.center.re.toString()));
                params.set("imc", compressDecimal(this.center.im.toString()));
                params.set("zmc", compressDecimal(new FloatExp(4).div(this.size).toString()));
                params.set("itc", compressDecimal(this.iterations.toString()));
                params.set("bailout", Math.sqrt(this.bailout).toString());
                params.set("colorc", byteArrayToBase64(palette.flat(1)));
                params.set("colorstep", colorStep);

                // é‡å»ºå“ˆå¸Œå­—ç¬¦ä¸²
                window.location.hash = params.toString();

                this.setLocked(false)
            }

            /**
             * Recolorize the Mandelbrot set visualization without recalculating.
             */

            recolorize() {
                this.image = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
                for (let y = 0; y < this.canvas.height; y++) {
                    for (let x = 0; x < this.canvas.width; x++) {
                        let it = this.iterMap[y][x];
                        if (it >= 0) {
                            let color = getColor(it, this.iterations);
                            let i = (y * this.canvas.width + x) << 2;
                            this.image.data[i] = color[0];
                            this.image.data[i + 1] = color[1];
                            this.image.data[i + 2] = color[2];
                            this.image.data[i + 3] = 255;
                        }
                    }
                }
                this.context.putImageData(this.image, 0, 0);
            }


            /**
             * Initiates the download of the Mandelbrot set visualization as a PNG image.
             */
            download() {
                const downloadLink = document.createElement('a');

                downloadLink.href = canvas.toDataURL('image/png');
                downloadLink.download = 'mandelbrot.png';

                downloadLink.click();
            }

            /**
             * Increases the number of iterations for the Mandelbrot set visualization.
             * @param {number} mul - The multiplier for increasing the iterations.
             */
            increaseIteration(mul) {
                let prevIter = this.iterations;
                this.setIterations(this.iterations * mul);

                for (let y = 0; y < this.canvas.height; y++) {
                    for (let x = 0; x < this.canvas.width; x++) {
                        if (this.iterMap[y][x] >= prevIter) {
                            this.setIter(x, y, 0)
                        }
                    }
                }
                this.update()
            }

            async renderFrames() {
                let frames = [];
                let refreshRef = false;
                this.videoRendering = true;
                while (this.size.doubleValue() < 32) {
                    await this.update();
                    let url = canvas.toDataURL('image/png');
                    let img = document.createElement('img');
                    img.src = url;
                    frames.push({ frame: img, scale: this.size });
                    this.zoomOut();
                    if (this.size.exp > -20 && !refreshRef) {
                        this.center = new DeepComplex(
                            new Decimal(this.center.re.toPrecision(30)),
                            new Decimal(this.center.im.toPrecision(30))
                        )
                        this.refValid = false;
                        this.iterations = 256;
                        refreshRef = true;
                    }
                }
                this.videoRendering = false;
                return frames.reverse();
            }
        }

        class KFRReader {
            constructor(arrayBuffer) {
                this.buffer = arrayBuffer;
                this.content = new TextDecoder().decode(arrayBuffer); // Decode ArrayBuffer to string
                this.data = this.parseContent(); // Parse key-value pairs
            }

            // Parse content line by line into key-value pairs
            parseContent() {
                const result = {};
                const lines = this.content.split(/\r?\n/); // Split into lines
                lines.forEach(line => {
                    const [key, value] = line.split(":").map(part => part.trim());
                    if (key && value !== undefined) {
                        result[key] = value;
                    }
                });
                return result;
            }

            // Getter for `Re`
            get re() {
                return this.data.Re;
            }

            // Getter for `Im`
            get im() {
                return this.data.Im;
            }

            // Getter for `Zoom`
            get zoom() {
                return this.data.Zoom;
            }

            // Getter for `Iterations`
            get iter() {
                return parseInt(this.data.Iterations, 10);
            }

            // Getter for `IterDiv`
            get iterDiv() {
                return parseFloat(this.data.IterDiv) ?? 1;
            }

            // Getter for `Colors`, converts the raw color data into an array of [r, g, b] tuples
            get colors() {
                if (!this.data.Colors) return [];
                const colorValues = this.data.Colors.split(",").slice(0, -1).map(Number);
                const rgbArray = [];
                for (let i = 0; i < colorValues.length; i += 3) {
                    rgbArray.push([colorValues[i + 2], colorValues[i + 1], colorValues[i]]);
                }
                return rgbArray;
            }
        }

        class KFRWriter {
            constructor() {
                this.data = {};
            }

            // Setters for `Re`, `Im`, `Zoom`, `Iterations`, `IterDiv`, and `Colors`
            set re(value) {
                this.data.Re = value;
            }

            set im(value) {
                this.data.Im = value;
            }

            set zoom(value) {
                this.data.Zoom = value;
            }

            set iter(value) {
                this.data.Iterations = value;
            }

            set iterDiv(value) {
                this.data.IterDiv = value;
            }

            set colors(value) {
                this.data.Colors = value.map(color => {
                    // convert each color to BGR format
                    return `${color[2]},${color[1]},${color[0]},`;
                }).join("");
            }

            // Convert the data to a KFR formatted string
            toString() {
                return Object.entries(this.data)
                    .map(([key, value]) => `${key}: ${value}`)
                    .join("\r\n");
            }

            load(mandelbrot) {
                this.re = mandelbrot.center.re.toString();
                this.im = mandelbrot.center.im.toString();
                let zoom = new FloatExp(4).div(mandelbrot.size);
                this.zoom = `${zoom.base}E${zoom.exp}`;
                this.iter = mandelbrot.iterations.toString();
                this.iterDiv = (colorStep * palette.length) / 1024
                this.colors = palette;
            }
        }

        const dict = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz123456789'
        function b58Compress(n, pad = true) {
            if (n == 0) return '0'

            // Detect 7 same digits
            let str = n.toString();
            let same = str.split('').every((v, i, a) => v === a[0]) && str.length === 7;
            if (same) {
                let digit = str[0];
                return "I" + digit;
            }

            let b58 = [];
            while (n > 0) {
                b58.push(dict[n % 58]);
                n = Math.floor(n / 58);
            }
            let result = b58.reverse().join("");
            if (pad) result = result.padStart(4, 'A')
            return result;
        }

        function b58Decompress(b58, pad = true) {
            let n = 0;
            let i = 0;
            for (let i = 0; i < b58.length; i++) {
                const char = b58[i];
                n *= 58
                let index = dict.indexOf(char)
                if (index === -1) {
                    throw new Error("Invalid character")
                }
                n += index
            }
            let result = n.toString()
            if (pad) result = result.padStart(7, '0');
            return result
        }

        function compressInteger(str) {
            let hasSign = str[0] === '+' || str[0] === '-';

            let i = 0;
            let builder = []

            if (hasSign) {
                builder.push(str[0] === '+' ? '' : '-');
                i++;
            }

            while (i < str.length) {
                let part = str.slice(i, i + 7);
                let compressed = b58Compress(parseInt(part), part.length === 7)
                builder.push(compressed);
                i += 7;
            }
            return builder.join("")
        }

        function compressDecimal(str) {
            let [mant, exp] = str.toLowerCase().split('e');
            let [dec, frac] = mant.split(".");

            let result = compressInteger(dec)
            if (frac) {
                result += "." + compressInteger(frac);
            }
            if (exp) {
                let expCompressed = compressInteger(exp)
                sign = (expCompressed[0] === '-') ? '' : '_';
                result += sign + expCompressed;
            }

            return result
        }

        function decompressInteger(str) {
            let hasSign = str[0] === '_' || str[0] === '-';

            let i = 0;
            let builder = []

            if (hasSign) {
                builder.push(str[0] === '_' ? '' : '-');
                i++;
            }

            while (i < str.length) {
                if (str[i] === '0') {
                    builder.push("0000000");
                    i++;
                } else if (str[i] === 'I') {
                    let digit = str[i + 1];
                    builder.push(digit.repeat(7));
                    i += 2;
                }
                else {
                    let part = str.slice(i, i + 4);
                    let decompressed = b58Decompress(part, part.length === 4)
                    builder.push(decompressed);
                    i += 4;
                }
            }
            return builder.join("")
        }

        function decompressDecimal(str) {
            let mant, exp;
            let result = '', sign = '';
            str = str.trim();
            if (str.startsWith("_")) {
                mant = str.slice(1)
                sign = ''
            }
            else if (str.startsWith("-")) {
                mant = str.slice(1)
                sign = '-'
            }
            else {
                mant = str;
            }

            let expsign = '';
            if (mant.includes('-')) {
                [mant, exp] = mant.split('-')
                expsign = '-'
            }
            else if (mant.includes('_')) {
                [mant, exp] = mant.split('_')
            }

            let int, frac;
            [int, frac] = mant.split('.')
            result += sign + decompressInteger(int);

            if (frac && frac != '') result += '.' + decompressInteger(frac);

            if (exp && exp != '') {
                result += "e" + expsign + decompressInteger(exp)
            }

            return result;
        }


        let c = new DeepComplex(
            new Decimal(0), new Decimal(0));

        let size = new FloatExp(4);
        let bailout = 16;
        let iterations = 256;

        const params = new URLSearchParams(window.location.hash.substring(1));

        params.forEach((value, key) => {
            switch (key) {

                // readable values
                case "re":
                    c.re = new Decimal(value);
                    params.delete(key);
                    break;
                case "im":
                    c.im = new Decimal(value);
                    params.delete(key);
                    break;
                case "zoom":
                    size = new FloatExp(4).div(getFloatExp(value));
                    params.delete(key);
                    break;
                case "iter":
                    iterations = parseInt(value);
                    params.delete(key);
                    break;
                case "bailout":
                    bailout = parseFloat(value);
                    params.delete(key);
                    break;
                case "colors":
                    palette = groupArray(value.split(",").map(e => parseInt(e)))
                    params.delete(key);
                    break;
                case "colorstep":
                    colorStep = parseFloat(value)
                    break;

                // compressed values
                case "rec":
                    c.re = new Decimal(decompressDecimal(value));
                    break;
                case "imc":
                    c.im = new Decimal(decompressDecimal(value));
                    break;
                case "zmc":
                    size = new FloatExp(4).div(parseFloatExp(decompressDecimal(value)));
                    break;
                case "itc":
                    iterations = parseInt(decompressDecimal(value));
                    break;
                case "colorc":
                    palette = groupArray(base64ToByteArray(value));
                    break;
            }
        });
        location.hash = params.toString();

        const mandelbrot = new Mandelbrot(canvas, c, iterations, bailout)
        mandelbrot.zoom(size)
        mandelbrot.update()

        document.getElementById('goto').addEventListener('click', e => {
            mandelbrot.goto(new DeepComplex(
                new Decimal(reInput.value),
                new Decimal(imInput.value)
            ))

            mandelbrot.zoom(new FloatExp(4).div(parseFloatExp(zoomInput.value)));
            mandelbrot.setIterations(parseInt(itInput.value));

            mandelbrot.update();
        })

        document.getElementById('home').addEventListener('click', e => {
            mandelbrot.home()
            mandelbrot.update()
        })

        document.getElementById('download').addEventListener('click', e => {
            mandelbrot.download()
        })

        sampleLoadBtn.addEventListener('click', e => {
            const loc = samples[sampleSelect.value]
            mandelbrot.goto(new DeepComplex(
                new Decimal(loc.re), new Decimal(loc.im)
            ))
            mandelbrot.zoom(new FloatExp(4).div(getFloatExp(loc.zoom)));
            mandelbrot.setIterations(loc.it);
            mandelbrot.update()
        })


        document.getElementById('zoom-in').addEventListener('click', function () {
            mandelbrot.zoom(mandelbrot.size.div(4));
            mandelbrot.update()
        });

        document.getElementById('zoom-out').addEventListener('click', function () {
            mandelbrot.zoom(mandelbrot.size.mul(4));
            mandelbrot.update()
        });

        document.getElementById('increase-iter').addEventListener('click', function () {
            mandelbrot.increaseIteration(2);
            mandelbrot.update();
        });

        document.getElementById('decrease-iter').addEventListener('click', function () {
            mandelbrot.setIterations(mandelbrot.iterations / 2);
            mandelbrot.clear();
            mandelbrot.update()
        });

        // Dynamically create an input element
        const inputElement = document.createElement("input");
        inputElement.type = "file";
        inputElement.accept = ".kfr"; // Accept only .kfr files
        inputElement.style.display = "none";

        // Append the input element to the document
        document.body.appendChild(inputElement);

        // Trigger file upload when a button is clicked
        document.getElementById("kfr").addEventListener('click', () => {
            inputElement.click(); // Simulate a click on the input element
        });

        document.getElementById("save-kfr").addEventListener('click', () => {
            const writer = new KFRWriter();
            writer.load(mandelbrot);
            const kfrContent = writer.toString();

            // Create a Blob from the KFR content
            const blob = new Blob([kfrContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);

            // Create a link to download the file
            const a = document.createElement('a');
            a.href = url;
            a.download = `mandelbrot-${new Date().toISOString()}.kfr`; // Set the desired file name
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });

        // Handle file selection
        inputElement.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) {
                alert("No file selected!");
                return;
            }

            // Ensure the file is a .kfr file
            if (!file.name.endsWith('.kfr')) {
                alert("Please upload a valid .kfr file.");
                return;
            }

            // Read the file as an ArrayBuffer
            const arrayBuffer = await file.arrayBuffer();

            // Parse the .kfr file using KFRReader
            const reader = new KFRReader(arrayBuffer);

            mandelbrot.goto(new DeepComplex(reader.re, reader.im))
            mandelbrot.zoom(new FloatExp(4).div(parseFloatExp(reader.zoom)));
            mandelbrot.setIterations(reader.iter);
            palette = reader.colors;
            colorStep = 1024 / reader.colors.length * reader.iterDiv;
            mandelbrot.update();
        });

        // Trigger file upload when a button is clicked
        document.getElementById("makeVideo").addEventListener('click', async () => {
            const keyFrames = await mandelbrot.renderFrames();
            console.log(keyFrames);

            const stream = canvas.captureStream();
            const recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=h264', videoBitsPerSecond: 10000000 });
            const data = [];
            recorder.ondataavailable = function (event) {
                if (event.data && event.data.size) {
                    data.push(event.data);
                }
            };
            recorder.onstop = () => {
                const url = URL.createObjectURL(new Blob(data, { type: 'video/webm' }));
                console.log('video url', url)
                var a = document.createElement('a');
                a.download = 'file.webm';
                a.href = url;
                a.click();

                ctx.imageSmoothingEnabled = false;
            };

            let indexFl = 0;
            let ctx = canvas.getContext('2d')
            ctx.imageSmoothingEnabled = true;

            ctx.font = 'bold 26px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;

            const renderer = () => {
                // Ensure `keyFrames` array is defined and has elements
                if (!keyFrames || keyFrames.length < 2) {
                    console.error("keyFrames array is either undefined or contains fewer than 2 frames.");
                    recorder.stop();
                    return;
                }

                // Calculate indices and verify bounds
                let i = Math.floor(indexFl);
                if (i < 0 || i + 1 >= keyFrames.length) {
                    recorder.stop();
                    return;
                }

                // Get the two images for the transition
                const image1 = keyFrames[i].frame;
                const image2 = keyFrames[i + 1].frame;

                // Calculate scaling factors
                const decimalPart = indexFl - i; // Fractional part of the index
                const scale1 = Math.pow(2, decimalPart); // Scale for image1
                const scale2 = scale1 * .5; // Scale for image2 (fixed at half size)

                // Clear canvas (assuming canvas context is `ctx`)
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw image1 at center with scaling factor `scale1`
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;

                ctx.drawImage(image1,
                    centerX - canvas.width * scale1 / 2,
                    centerY - canvas.height * scale1 / 2,
                    canvas.width * scale1,
                    canvas.width * scale1
                );


                ctx.drawImage(image2,
                    centerX - canvas.width * scale2 / 2,
                    centerY - canvas.height * scale2 / 2,
                    canvas.width * scale2,
                    canvas.width * scale2
                );

                more.innerText = indexFl.toFixed(2);

                const scale = new FloatExp(4).div(keyFrames[i].scale);
                const currScale = FloatExp.fromLog2(scale.log2Value() + decimalPart);

                let zoomText;
                if (currScale.exp < 7) {
                    zoomText = currScale.doubleValue().toFixed(2);
                } else zoomText = `${currScale.base.toFixed(2)}E${currScale.exp}`

                ctx.fillText(zoomText, 8, 8)
                ctx.strokeText(zoomText, 8, 8)

                // Increment index for the next frame
                indexFl += 1 / 60;

                // Loop `renderer` to maintain animation (assuming 60fps rendering)
                requestAnimationFrame(renderer);
            };

            // Start the renderer
            recorder.start();
            requestAnimationFrame(renderer);
        });

        function generateRandomPalette(size) {
            const palette = [];
            for (let i = 0; i < size; i++) {
                palette.push([
                    Math.floor(Math.random() * 256),
                    Math.floor(Math.random() * 256),
                    Math.floor(Math.random() * 256)
                ]);
            }
            return palette;
        }

        class PaletteEditor {
            constructor() {
                this.dialog = document.getElementById('palette-dialog');
                this.colorList = document.getElementById('color-list');
                this.applyButton = document.getElementById('apply-colors');
                this.randomButton = document.getElementById('random-colors');
                this.resetButton = document.getElementById('reset-colors');
                this.closeButton = document.getElementById('close-dialog');
                this.colorStepInput = document.getElementById('color-step');
                this.init();
            }

            init() {
                this.applyButton.addEventListener('click', () => {
                    this.applyColors();
                });

                this.randomButton.addEventListener('click', () => {
                    palette = generateRandomPalette(palette.length); // Generate a random palette with 10 colors
                    this.renderColors();
                });

                this.resetButton.addEventListener('click', () => {
                    palette = defaultPalette; // Reset to the default palette
                    this.renderColors();
                });

                this.closeButton.addEventListener('click', () => {
                    this.dialog.close();
                });

                this.colorStepInput.addEventListener('input', (e) => {
                    colorStep = parseFloat(e.target.value);
                });

                this.renderColors();
            }

            renderColors() {
                this.colorList.innerHTML = ''; // Clear existing colors
                palette.forEach((color, index) => {
                    const li = document.createElement('li');
                    li.classList.add('color-item');
                    const label = document.createElement('label');
                    label.textContent = `${index + 1} `;
                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.value = `#${color.map(c => c.toString(16).padStart(2, '0')).join('')}`;
                    colorInput.dataset.index = index;
                    const removeColorButton = document.createElement('button');
                    removeColorButton.classList.add('icon');
                    removeColorButton.dataset.index = index;
                    removeColorButton.textContent = '-';
                    removeColorButton.addEventListener('click', (e) => {
                        const index = e.target.dataset.index;
                        palette.splice(index, 1); // Remove color from palette
                        this.renderColors(); // Re-render colors
                    });
                    const addColorButton = document.createElement('button');
                    addColorButton.className = 'icon';
                    addColorButton.textContent = '+';
                    addColorButton.dataset.index = index;
                    addColorButton.addEventListener('click', () => {
                        // Add a new black color after the current color
                        palette.splice(index + 1, 0, [0, 0, 0]); // Add black color
                        this.renderColors(); // Re-render colors
                    });
                    li.appendChild(label);
                    li.appendChild(colorInput);
                    li.appendChild(removeColorButton);
                    li.appendChild(addColorButton);
                    this.colorList.appendChild(li);
                });

                this.colorStepInput.value = colorStep; // Set the color step input value
            }

            applyColors() {
                const inputs = this.colorList.querySelectorAll('input[type="color"]');
                palette = Array.from(inputs).map(input => {
                    const color = input.value.slice(1); // Remove the '#' character
                    return [
                        parseInt(color.slice(0, 2), 16),
                        parseInt(color.slice(2, 4), 16),
                        parseInt(color.slice(4, 6), 16)
                    ];
                });
                this.dialog.close();
                mandelbrot.recolorize(); // Recolorize the Mandelbrot set with new colors
            }

            show() {
                this.dialog.showModal();
                this.renderColors();
            }
        }

        const paletteEditor = new PaletteEditor();
        document.getElementById('palette').addEventListener('click', () => {
            paletteEditor.show();
        });
    </script>
</body>

</html>