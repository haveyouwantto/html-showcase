<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>复平面高次多项式可视化</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap"
        rel="stylesheet">

    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #111;
            font-family: 'Noto Serif', serif;
            user-select: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* 拖动符号样式 */
        .handle {
            position: absolute;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 1.4rem;
            font-style: italic;
            cursor: grab;
            z-index: 10;
            text-shadow: 0 0 4px #000;
            padding: 10px;
            transition: color 0.2s, transform 0.1s;
        }

        .handle:active {
            cursor: grabbing;
            color: #ffd700;
            z-index: 100;
            /* 拖拽时置顶 */
        }

        /* 辅助对齐点 */
        .handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background: currentColor;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.6;
            pointer-events: none;
        }

        /* UI 控制层 */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            pointer-events: none;
            text-align: center;
            color: white;
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .equation {
            font-size: 1.8rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.9);
            min-height: 2.5rem;
            /* 防止高度跳动 */
        }

        .equation i {
            font-family: 'Noto Serif', serif;
            font-style: italic;
        }

        .controls {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 20px;
            pointer-events: auto;
            display: flex;
            align-items: center;
            gap: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
        }

        .controls label {
            font-size: 0.9rem;
            color: #ccc;
        }

        input[type=range] {
            cursor: pointer;
            width: 150px;
        }

        .guide {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.8rem;
            text-align: right;
            pointer-events: none;
            line-height: 1.5;
        }

        /* 新增：左下角数值解显示 */
        .roots-display {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.8rem;
            text-align: left;
            pointer-events: none;
            line-height: 1.4;
            max-height: 40vh;
            overflow: hidden;
        }
        .roots-display span {
            display: block;
        }
    </style>
</head>

<body>

    <div class="ui-layer">
        <div class="controls">
            <label for="degree-slider">多项式次数 (Degree): <span id="degree-val">2</span></label>
            <input type="range" id="degree-slider" min="1" max="10" value="2" step="1">
        </div>
        <div class="equation" id="equation-display"></div>
    </div>

    <!-- 左下角数值解 -->
    <div class="roots-display" id="roots-container">
        Roots loading...
    </div>

    <div class="guide">
        靠近坐标轴/整数/其他点可自动吸附<br>
        Range: [-2, 2]
    </div>

    <div id="handles-container"></div>
    <canvas id="glCanvas"></canvas>

    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        precision highp float;

        uniform vec2 u_resolution;
        uniform int u_degree;
        // 支持最高10次多项式，即11个系数
        uniform vec2 u_coeffs[11]; 

        #define PI 3.14159265359

        // 复数乘法: (a+bi)(c+di)
        vec2 complexMul(vec2 v1, vec2 v2) {
            return vec2(v1.x * v2.x - v1.y * v2.y, v1.x * v2.y + v1.y * v2.x);
        }

        vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }

        void main() {
            float aspect = u_resolution.x / u_resolution.y;
            float zoom = 4.0;
            vec2 st = (gl_FragCoord.xy - u_resolution.xy * 0.5) / min(u_resolution.x, u_resolution.y) * zoom;
            vec2 z = vec2(st.x, -st.y);

            // --- 秦九韶算法 (Horner's Method) ---
            // P(z) = (...((c_n * z + c_{n-1}) * z + c_{n-2}) * z + ... ) * z + c_0
            
            vec2 w = vec2(0.0, 0.0);
            
            // GLSL loops 必须有常量边界，我们循环最大值，然后在内部判断
            for (int i = 10; i >= 0; i--) {
                if (i <= u_degree) {
                    if (i == u_degree) {
                        // 最高次项系数直接赋值 (避免乘以z前的0)
                        w = u_coeffs[i];
                    } else {
                        w = complexMul(w, z) + u_coeffs[i];
                    }
                }
            }

            // --- 域着色 ---
            float r = length(w);
            float theta = atan(w.y, w.x);
            
            float hue = theta / (2.0 * PI) + 0.5;
            float val = 1.0 / (1.0 + 0.4 * log(r + 1.0) * r); 
            val = clamp(val, 0.05, 1.0);
            float sat = 0.8;
            
            vec3 color = hsv2rgb(vec3(hue, sat, val));

            // --- 网格与坐标轴 ---
            float pixelSize = zoom / min(u_resolution.x, u_resolution.y);
            float lineThickness = 1.5 * pixelSize;

            vec2 gridDist = abs(fract(z + 0.5) - 0.5);
            float gridLine = min(gridDist.x, gridDist.y);
            float gridIntensity = 1.0 - smoothstep(0.0, lineThickness, gridLine);
            
            vec2 axisDist = abs(z);
            float axisLine = min(axisDist.x, axisDist.y);
            float axisIntensity = 1.0 - smoothstep(0.0, lineThickness, axisLine);

            color = mix(color, vec3(1.0), gridIntensity * 0.1);
            color = mix(color, vec3(1.0), axisIntensity * 0.5);

            gl_FragColor = vec4(color, 1.0);
        }
    </script>

    <script>
        const canvas = document.getElementById("glCanvas");
        const gl = canvas.getContext("webgl");
        const container = document.getElementById("handles-container");
        const degreeSlider = document.getElementById("degree-slider");
        const degreeValDisplay = document.getElementById("degree-val");
        const rootsContainer = document.getElementById("roots-container");

        // --- Shader Init ---
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader)); return null;
            }
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, document.getElementById("vertex-shader").text));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, document.getElementById("fragment-shader").text));
        gl.linkProgram(program);
        gl.useProgram(program);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
        const posLoc = gl.getAttribLocation(program, "a_position");
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        // --- Uniform Locations ---
        const locs = {
            res: gl.getUniformLocation(program, "u_resolution"),
            degree: gl.getUniformLocation(program, "u_degree"),
            coeffs: gl.getUniformLocation(program, "u_coeffs")
        };

        // --- State Management ---
        let degree = 2;
        let coefficients = [];

        function getCoeffLabel(index, totalDegree) {
            const map = 'abcdefghijklmnopqrstuvwxy';
            const charIndex = totalDegree - index;
            return map[charIndex] || `c<sub>${index}</sub>`;
        }

        function initCoeffs(newDegree) {
            const newCoeffs = [];
            for (let i = 0; i <= newDegree; i++) {
                if (coefficients[i]) {
                    newCoeffs[i] = coefficients[i];
                } else {
                    if (i === newDegree) newCoeffs[i] = { r: 1, i: 0 };
                    else if (i === 0) newCoeffs[i] = { r: -1, i: 0 };
                    else newCoeffs[i] = { r: 0, i: 0 };
                }
            }
            coefficients = newCoeffs;
            degree = newDegree;
            renderHandles();
            updateEquation();
            requestAnimationFrame(render);
        }

        function renderHandles() {
            container.innerHTML = '';
            for (let i = degree; i >= 0; i--) {
                const div = document.createElement('div');
                div.className = 'handle';
                div.innerHTML = getCoeffLabel(i, degree);
                div.dataset.index = i;

                const pos = complexToScreen(coefficients[i].r, coefficients[i].i);
                div.style.left = pos.x + 'px';
                div.style.top = pos.y + 'px';

                div.addEventListener('mousedown', e => handleStart(e, i));
                div.addEventListener('touchstart', e => handleStart(e, i), { passive: false });

                container.appendChild(div);
            }
        }

        // --- Math Helpers (Basic) ---
        function complexToScreen(r, i) {
            const minDim = Math.min(canvas.width, canvas.height);
            const x = (r * minDim / 4.0) + canvas.width / 2;
            const y = canvas.height / 2 - (i * minDim / 4.0);
            return { x, y };
        }

        function screenToComplex(sx, sy) {
            const minDim = Math.min(canvas.width, canvas.height);
            const r = (sx - canvas.width / 2) / minDim * 4.0;
            const i = -(sy - canvas.height / 2) / minDim * 4.0;
            return { r, i };
        }

        // --- Complex Math for Solver ---
        const C = {
            add: (a, b) => ({ r: a.r + b.r, i: a.i + b.i }),
            sub: (a, b) => ({ r: a.r - b.r, i: a.i - b.i }),
            mul: (a, b) => ({ r: a.r * b.r - a.i * b.i, i: a.r * b.i + a.i * b.r }),
            div: (a, b) => {
                const denom = b.r * b.r + b.i * b.i;
                return { r: (a.r * b.r + a.i * b.i) / denom, i: (a.i * b.r - a.r * b.i) / denom };
            },
            mag: (a) => Math.sqrt(a.r * a.r + a.i * a.i)
        };

        // --- Polynomial Solver (Durand-Kerner Method) ---
        function solvePolynomial() {
            // 找到实际的最高次项（避免首项系数为0导致除零）
            let effDegree = degree;
            while (effDegree > 0 && C.mag(coefficients[effDegree]) < 1e-6) {
                effDegree--;
            }

            if (effDegree < 1) return []; // 常数没有根

            // 归一化系数 (a_n = 1)
            let normCoeffs = [];
            let lead = coefficients[effDegree];
            for (let i = 0; i < effDegree; i++) {
                normCoeffs[i] = C.div(coefficients[i], lead);
            }

            // 初始猜测 (Roots of Unity)
            let roots = [];
            let radius = 0.4 + Math.random() * 0.5;
            for (let i = 0; i < effDegree; i++) {
                let theta = (Math.PI * 2 * i) / effDegree + 0.1; // Offset to avoid symmetry
                roots.push({ r: radius * Math.cos(theta), i: radius * Math.sin(theta) });
            }

            // 迭代 (Durand-Kerner)
            const iterations = 25;
            for (let iter = 0; iter < iterations; iter++) {
                for (let i = 0; i < effDegree; i++) {
                    // Evaluate P(z) at current root guess
                    let pVal = { r: 1, i: 0 }; // Lead coeff is 1 now
                    // Horner's method for normalized poly: z^n + a_{n-1}z^{n-1} ...
                    let val = { r: 0, i: 0 };
                    // P(z) = z^n + sum( a_k * z^k )
                    // Calculate P(z) directly using normalized coeffs
                    let term = { r: 1, i: 0 }; // z^n term coeff is 1
                    
                    // Simple evaluation: sum c_k * z^k
                    let sum = { r: 0, i: 0 };
                    let zPow = { r: 1, i: 0 }; // z^0
                    
                    for(let k=0; k<=effDegree; k++) {
                        let c = (k === effDegree) ? {r:1, i:0} : normCoeffs[k];
                        sum = C.add(sum, C.mul(c, zPow));
                        zPow = C.mul(zPow, roots[i]);
                    }
                    
                    // Product (z - z_j)
                    let product = { r: 1, i: 0 };
                    for (let j = 0; j < effDegree; j++) {
                        if (i !== j) {
                            product = C.mul(product, C.sub(roots[i], roots[j]));
                        }
                    }

                    if (C.mag(product) > 1e-9) {
                        let correction = C.div(sum, product);
                        roots[i] = C.sub(roots[i], correction);
                    }
                }
            }
            
            // 排序根 (实部优先，虚部次之) 以稳定显示
            roots.sort((a, b) => a.r - b.r || a.i - b.i);
            return roots;
        }

        // --- Formatting ---
        function formatComplexLazy(r, i, isLeading) {
            const epsilon = 0.005; 
            if (Math.abs(r) < epsilon && Math.abs(i) < epsilon) return null;

            let str = "";
            let showR = Math.abs(r) >= epsilon;
            let showI = Math.abs(i) >= epsilon;

            if (showR) {
                let rStr = Math.abs(r).toFixed(2).replace(/\.00$/, '');
                if (r < 0) str += isLeading ? "-" : " - ";
                str += rStr;
            }

            if (showI) {
                let iStr = Math.abs(i).toFixed(2).replace(/\.00$/, '');
                if (iStr === "1") iStr = "";
                if (i < 0) str += (showR || !isLeading) ? " - " : "-";
                else str += (showR || !isLeading) ? " + " : "";
                str += iStr + "i";
            }

            let text = str.trim();
            if (!text) return "0";
            if (showR && showI) return `(${text})`;
            return text;
        }

        function formatRoot(c, index) {
            const epsilon = 0.001;
            let r = Math.abs(c.r) < epsilon ? 0 : c.r;
            let i = Math.abs(c.i) < epsilon ? 0 : c.i;
            
            let s = `z<sub>${index+1}</sub> = `;
            s += r.toFixed(3);
            console.log(i)
            if (i > 0) s += " + " + i.toFixed(3) + "i";
            else if (i < 0) s += " - " + Math.abs(i).toFixed(3) + "i";
            return s;
        }

        function updateEquation() {
            const eqDiv = document.getElementById('equation-display');
            let html = "<i>f(z)</i> = ";
            let terms = [];

            for (let i = degree; i >= 0; i--) {
                const c = coefficients[i];
                let coeffStr = formatComplexLazy(c.r, c.i, terms.length === 0);

                if (!coeffStr) continue;

                if (i > 0) {
                    if (coeffStr === "1") coeffStr = "";
                    if (coeffStr === "-1") coeffStr = "-";
                }

                let term = coeffStr;
                if (i === 1) term += "<i>z</i>";
                else if (i > 1) term += `<i>z</i><sup>${i}</sup>`;

                if (terms.length > 0 && !term.startsWith("-") && !term.startsWith(" +") && !term.startsWith(" -")) {
                    term = " + " + term;
                } else if (term.startsWith("-") && terms.length > 0) {
                    term = " - " + term.substring(1);
                }

                terms.push(term);
            }

            if (terms.length === 0) html += "0";
            else html += terms.join("");

            eqDiv.innerHTML = html;

            // Update Roots
            const roots = solvePolynomial();
            if (roots.length === 0) {
                rootsContainer.innerHTML = "No roots (Constant)";
            } else {
                rootsContainer.innerHTML = roots.map((r, idx) => `<span>${formatRoot(r, idx)}</span>`).join("");
            }
        }

        // --- Interaction & Snapping ---
        let dragTargetIndex = null;
        // 缩小吸附半径
        const SNAP_THRESHOLD = 0.08; 

        function handleStart(e, index) {
            dragTargetIndex = index;
            e.preventDefault();
        }

        function handleMove(e) {
            if (dragTargetIndex === null) return;

            let clientX = e.clientX || e.touches[0].clientX;
            let clientY = e.clientY || e.touches[0].clientY;

            // 1. 限制字母不能拖动出屏幕 (保留一点边距)
            const padding = 20;
            clientX = Math.max(padding, Math.min(window.innerWidth - padding, clientX));
            clientY = Math.max(padding, Math.min(window.innerHeight - padding, clientY));

            let c = screenToComplex(clientX, clientY);

            // --- Snapping Logic (增强版) ---
            let snapped = false;

            // A. 吸附到其他字母 (Peer Snapping)
            for (let i = 0; i <= degree; i++) {
                if (i === dragTargetIndex) continue;
                const other = coefficients[i];
                const dist = Math.sqrt(Math.pow(c.r - other.r, 2) + Math.pow(c.i - other.i, 2));
                if (dist < SNAP_THRESHOLD) {
                    c.r = other.r;
                    c.i = other.i;
                    snapped = true;
                    break;
                }
            }

            // B. 如果没吸附到字母，尝试吸附整数
            if (!snapped) {
                const roundR = Math.round(c.r);
                const roundI = Math.round(c.i);
                
                // 检查实部是否接近整数
                if (Math.abs(c.r - roundR) < SNAP_THRESHOLD) {
                    c.r = roundR;
                    snapped = true;
                }
                // 检查虚部是否接近整数
                if (Math.abs(c.i - roundI) < SNAP_THRESHOLD) {
                    c.i = roundI;
                    snapped = true;
                }
            }

            // C. 坐标轴吸附 (如果还未完全锁定整数点)
            if (!snapped) {
                 if (Math.abs(c.r) < SNAP_THRESHOLD) {
                    c.r = 0; snapped = true;
                }
                if (Math.abs(c.i) < SNAP_THRESHOLD) {
                    c.i = 0; snapped = true;
                }
            }

            // 更新数据
            coefficients[dragTargetIndex].r = c.r;
            coefficients[dragTargetIndex].i = c.i;

            // 更新 DOM
            const el = container.querySelector(`div[data-index="${dragTargetIndex}"]`);
            const screenPos = complexToScreen(c.r, c.i);
            el.style.left = screenPos.x + 'px';
            el.style.top = screenPos.y + 'px';

            updateEquation();
            requestAnimationFrame(render);
        }

        function handleEnd() {
            dragTargetIndex = null;
        }

        // --- Render Loop ---
        function render() {
            if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
                renderHandles(); 
            }

            gl.uniform2f(locs.res, canvas.width, canvas.height);
            gl.uniform1i(locs.degree, degree);

            let flatCoeffs = [];
            for (let i = 0; i < 11; i++) {
                if (i <= degree) {
                    flatCoeffs.push(coefficients[i].r, coefficients[i].i);
                } else {
                    flatCoeffs.push(0, 0);
                }
            }
            gl.uniform2fv(locs.coeffs, new Float32Array(flatCoeffs));

            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        // Listeners
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('touchmove', handleMove, { passive: false });
        window.addEventListener('mouseup', handleEnd);
        window.addEventListener('touchend', handleEnd);

        degreeSlider.addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            degreeValDisplay.innerText = val;
            initCoeffs(val);
        });

        // Start
        initCoeffs(2); 

    </script>
</body>

</html>