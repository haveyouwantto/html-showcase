<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSTV Generator</title>
    <style>
        :root {
            --theme-color: #f4704b;
        }

        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #121212;
            color: #e0e0e0;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            font-size: 2rem;
            margin: 20px 0;
            color: var(--theme-color);
        }

        input[type="file"] {
            margin: 20px 10px;
            padding: 10px;
            background-color: #1f1f1f;
            color: #e0e0e0;
            border: 1px solid var(--theme-color);
            border-radius: 5px;
            cursor: pointer;
        }

        button {
            padding: 10px 20px;
            margin: 20px 10px;
            font-size: 1rem;
            color: #121212;
            background-color: var(--theme-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        button:hover:not(:disabled) {
            background-color: var(--theme-color);
        }

        button:active {
            transform: scale(0.98);
        }

        .card {
            border: 1px solid var(--theme-color);
            border-radius: 5px;
        }

        .div {
            padding: 10px;
        }

        canvas {
            border: 2px solid var(--theme-color);
            border-radius: 10px;
            margin-top: 20px;
            background-color: #1f1f1f;
            display: block;
            margin-left: auto;
            margin-right: auto;
            max-width: 100%;
            height: auto;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.5rem;
            }

            button,
            input[type="file"] {
                font-size: 0.9rem;
                padding: 8px 15px;
            }

            canvas {
                width: 90%;
            }
        }
    </style>
</head>

<body>
    <h1>SSTV 生成器</h1>
    <input type="file" accept="image/*" id="upload">
    <div class="card div">
        制式：
        <select id="encoderSelect">
            <option value="scottie1">Scottie 1</option>
            <option value="scottie2">Scottie 2</option>
            <option value="scottiedx">Scottie DX</option>
            <option value="martin1">Martin 1</option>
            <option value="martin2">Martin 2</option>
            <option value="wrassesc2_180">Wrasse SC2-180</option>
        </select>
    </div>
    <button id="generateButton" disabled>发射 SSTV</button>
    <canvas id="imageCanvas"></canvas>

    <script>
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const canvas = document.getElementById('imageCanvas');
        const ctx = canvas.getContext('2d');
        let imageData = null;

        class SSTVEncoder {
            constructor(startTime) {
                this.time = startTime;
            }

            setFreq(freq, time) {
                this.osc.frequency.setValueAtTime(freq, this.time);
                this.time += time;
            }

            encodeHeader(code) {
                // Start Tone
                this.setFreq(1900, 0.3);
                this.setFreq(1200, 0.01);
                this.setFreq(1900, 0.3);

                // 格式
                this.setFreq(1200, 0.03);

                let parity = false;
                for (let i = 0; i < 7; i++) {
                    const bit = (code & 1) === 1;
                    this.setFreq(bit ? 1100 : 1300, 0.03);
                    this.osc.frequency.setValueAtTime(bit ? 1100 : 1300, this.time);
                    code >>= 1;
                    parity = parity ^ bit;
                }
                this.setFreq(parity ? 1100 : 1300, 0.03);

                this.setFreq(1200, 0.03);
            }

            scanLine(data, duration) {
                const freqs = data.map(e => e * 800 + 1500);
                this.osc.frequency.setValueCurveAtTime(freqs, this.time, duration);
                this.time += duration;
            }

            scanImage(canvas) { }


            transmit(osc, now, image) {
                this.osc = osc;
                this.time = now;
                this.osc.start(this.time);
                this.encodeHeader(this.code);
                this.scanImage(image);
                this.osc.stop(this.time);
            }

            getResolution() { }
            get code() { }
        }

        class WrasseSC2_180Encoder extends SSTVEncoder {

            scanImage(canvas) {
                const imgWidth = canvas.width;
                const imgHeight = canvas.height;

                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                for (let line = 0; line < imgHeight; line++) {
                    // 起始脉冲

                    this.setFreq(1200, 0.0055225);
                    this.setFreq(1500, 0.0005);

                    const lineData = imageData.data.slice(line * imgWidth * 4, (line + 1) * imgWidth * 4);

                    // 分离 RGB 通道并逐个处理
                    const rData = [];
                    const gData = [];
                    const bData = [];

                    for (let i = 0; i < imgWidth; i++) {
                        const r = lineData[i * 4] / 255;  // R 通道
                        const g = lineData[i * 4 + 1] / 255;  // G 通道
                        const b = lineData[i * 4 + 2] / 255;  // B 通道

                        rData.push(r);  // R 通道频率
                        gData.push(g);  // G 通道频率
                        bData.push(b);  // B 通道频率
                    }

                    this.scanLine(rData, 0.235);
                    this.scanLine(gData, 0.235);
                    this.scanLine(bData, 0.235);
                }
            }

            getResolution() {
                return [320, 256];
            }

            get code() {
                return 55;
            }
        }

        class ScottieEncoder extends SSTVEncoder {
            scanImage(canvas) {
                const imgWidth = canvas.width;
                const imgHeight = canvas.height;

                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                // 起始脉冲
                this.setFreq(1200, 0.009)

                for (let line = 0; line < imgHeight; line++) {

                    const lineData = imageData.data.slice(line * imgWidth * 4, (line + 1) * imgWidth * 4);

                    // 分离 RGB 通道并逐个处理
                    const rData = [];
                    const gData = [];
                    const bData = [];

                    for (let i = 0; i < imgWidth; i++) {
                        const r = lineData[i * 4] / 255;  // R 通道
                        const g = lineData[i * 4 + 1] / 255;  // G 通道
                        const b = lineData[i * 4 + 2] / 255;  // B 通道

                        rData.push(r);  // R 通道频率
                        gData.push(g);  // G 通道频率
                        bData.push(b);  // B 通道频率
                    }

                    this.setFreq(1500, 0.0015)//separator
                    this.scanLine(gData, this.scanTime);
                    this.setFreq(1500, 0.0015)//separator
                    this.scanLine(bData, this.scanTime);
                    this.setFreq(1200, 0.009) //sync
                    this.setFreq(1500, 0.0015)//separator
                    this.scanLine(rData, this.scanTime);
                }
            }

            getResolution() {
                return [320, 256];
            }

            get scanTime() {
                return 0.13824;
            }

            get code() {
                return 60;
            }
        }

        class Scottie1Encoder extends ScottieEncoder { }
        class Scottie2Encoder extends ScottieEncoder {
            get scanTime() {
                return 0.088064;
            }

            get code() {
                return 56;
            }
        }
        class ScottieDxEncoder extends ScottieEncoder {
            get scanTime() {
                return 0.3456;
            }

            get code() {
                return 76;
            }
        }


        class MartinEncoder extends SSTVEncoder {
            scanImage(canvas) {
                const imgWidth = canvas.width;
                const imgHeight = canvas.height;

                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);


                for (let line = 0; line < imgHeight; line++) {

                    const lineData = imageData.data.slice(line * imgWidth * 4, (line + 1) * imgWidth * 4);

                    // 分离 RGB 通道并逐个处理
                    const rData = [];
                    const gData = [];
                    const bData = [];

                    for (let i = 0; i < imgWidth; i++) {
                        const r = lineData[i * 4] / 255;  // R 通道
                        const g = lineData[i * 4 + 1] / 255;  // G 通道
                        const b = lineData[i * 4 + 2] / 255;  // B 通道

                        rData.push(r);  // R 通道频率
                        gData.push(g);  // G 通道频率
                        bData.push(b);  // B 通道频率
                    }

                    // 起始脉冲
                    this.setFreq(1200, 0.004862)
                    this.setFreq(1500, 0.000572)//separator
                    this.scanLine(gData, this.scanTime);
                    this.setFreq(1500, 0.000572)//separator
                    this.scanLine(bData, this.scanTime);
                    this.setFreq(1500, 0.000572)//separator
                    this.scanLine(rData, this.scanTime);
                    this.setFreq(1500, 0.000572)//separator
                }
            }

            getResolution() {
                return [320, 256];
            }

            get scanTime() {
                return 0.146432;
            }

            get code() {
                return 44;
            }
        }

        class Martin1Encoder extends MartinEncoder { }
        class Martin2Encoder extends MartinEncoder {
            get scanTime() {
                return 0.073216;
            }

            get code() {
                return 40;
            }
        }

        // 处理文件上传
        document.getElementById('upload').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const img = new Image();
            img.onload = () => {
                const aspectRatio = img.width / img.height;
                const size = encoder.getResolution();
                canvas.width = size[0];
                canvas.height = size[1];

                ctx.fillColor = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height)
                if (aspectRatio > 4 / 3) {
                    let div = img.width / size[0];
                    let h = img.height / div;
                    ctx.drawImage(img, 0, (canvas.height - h) / 2, canvas.width, h);
                }
                else {
                    let div = img.height / size[1];
                    let w = img.width / div;
                    ctx.drawImage(img, (canvas.width - w) / 2, 0, w, canvas.height);
                }
                imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                document.getElementById('generateButton').disabled = false;
            };
            img.src = URL.createObjectURL(file);
        };


        let encoder = new ScottieEncoder();
        let isTransmitting = false; // 添加状态标志
        let activeOscillator = null; // 记录当前的发射振荡器

        // 发射 SSTV 信号
        document.getElementById('generateButton').addEventListener('click', () => {
            if (isTransmitting) {
                // 停止发射
                activeOscillator.stop();
                activeOscillator = null;
                isTransmitting = false;
                document.getElementById('generateButton').innerText = '发射 SSTV';
                document.getElementById('generateButton').disabled = false; // 恢复可用状态
            } else {
                // 开始发射
                if (!imageData) {
                    alert('请先上传图像！');
                    return;
                }

                let now = audioCtx.currentTime;
                audioCtx.resume();
                const oscillator = audioCtx.createOscillator();
                oscillator.connect(audioCtx.destination);

                activeOscillator = oscillator; // 记录当前振荡器
                isTransmitting = true;
                document.getElementById('generateButton').innerText = '停止发射';
                document.getElementById('generateButton').disabled = false; // 保持可用状态

                encoder.transmit(oscillator, now, canvas);
            }
        });

        const encoders = {
            martin1: Martin1Encoder,
            martin2: Martin2Encoder,
            scottie1: Scottie1Encoder,
            scottie2: Scottie2Encoder,
            scottiedx: ScottieDxEncoder,
            wrassesc2_180: WrasseSC2_180Encoder
        }
        document.getElementById('encoderSelect').addEventListener('change', (e) => {
            const encoderClass = e.target.value;
            encoder = new encoders[encoderClass](); // 反射创建 encoder 对象
        });
    </script>
</body>

</html>